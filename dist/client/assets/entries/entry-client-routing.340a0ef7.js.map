{"version":3,"mappings":"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","names":["isPlainObject","value","stringifyStringArray","stringList","str","hasPropertyGetter","obj","prop","descriptor","isPromise","val","isCallable","index_page_route$a","index_page_route$9","index_page_route$8","index_page_route$7","index_page_route$6","index_page_route$5","index_page_route$4","index_page_route$3","index_page_route$2","index_page_route$1","index_page_route","setPageFiles","pageFilesExports","getUrlPathname","url","parseUrl","isExternalLink","isReact","_a","_b","_c","_d","isReact1","isReact2","isReact3","isSameErrorMessage","err1","err2","serverSideRouteTo","sleep","milliseconds","r","throttle","func","waitTime","isQueued","assert","isBrowser","assertClientRouting","globalObject","getGlobalObject","urlFirst","getCurrentUrl","navigationState","analyzePageServerSide","pageFilesAll","pageId","pageFilesServerSideOnly","getPageFilesServerSide","p","exportNames","isObjectWithKeys","keys","key","isStringRecord","thing","deduceRouteStringFromFilesystemPath","filesystemRoots","fsBase","filesystemRoot","higherFirst","filesystemRoute","urlRoot","debugInfo","slice","dir","loadPageRoutes","pageConfigs","pageConfigGlobal","allPageIds","onBeforeRouteHook","getGlobalHooks","getPageRoutes","pageRoutes","pageIds","comesFromV1PageConfig","pageConfig","removePageId","pageRoute","routeConfig","route","routeDefinedAt","allowAsync","allowSyncConfig","routeFilesystem","routeFilesystemDefinedBy","isErrorPageId","pageRouteFile","findPageRouteFile","filePath","fileExports","assertUsage","hasProp","routeString","routeFunction","allowKey","hookFn","hookFilePath","onBeforeRoute","dirname","paths","dirPath","length","id","addComputedUrlProps","pageContext","enumerable","urlPathnameGetter","urlGetter","urlParsedGetter","getUrlParsed","urlHandler","urlOriginal","baseServer","pathname","urlPathname","assertWarning","urlParsedOriginal","origin","pathnameOriginal","search","searchAll","searchOriginal","hash","hashOriginal","urlParsed","makeNonEnumerable","assertURLs","PARAM_TOKEN_NEW","PARAM_TOKEN_OLD","assertRouteString","errMsgPrefix","routeStr","resolveRouteString","routeSegments","urlSegments","routeParams","assertGlob","i","routeSegment","urlSegment","isParam","numberOfGlobChars","analyzeRouteString","numberOfStaticSegmentsBeginning","numberOfStaticSegements","s","numberOfParameterSegments","isCatchAll","isStaticRouteString","match","resolvePrecendence","routeMatches","sortMatches","makeFirst","routeMatch","routeMatch1","routeMatch2","precedence1","precedence2","result","resolveRouteFunction","precedence","assertRouteParams","errPrefix","assertPageContextProvidedByUser","pageContextProvidedByUser","hook","errorMessagePrefix","isRenderErrorPage","hookName","isObject","callOnBeforeRouteHook","hookReturn","errPrefix2","pageContextAddendumHook","assertUsageUrl","objectAssign","_debug","debug","args","pageContextAddendum","routeType","winner","BUILT_IN_CLIENT_ROUTER","BUILT_IN_CLIENT","removeBuiltInOverrides","urlToFile","fileExtension","doNotCreateExtraDirectory","hasTrailingSlash","pathnameModified","getPageContextRequestUrl","assertObjectKeys","keysExpected","keysUnknown","assertOnBeforeRenderHookReturn","hookReturnValue","getPageContext","getPageContextFirstRender","getPageContextUponNavigation","getPageContextSerializedInHtml","loadPageFilesClientSide","getPageContextErrorPage","errorPageId","getErrorPageId","getPageContextFromRoute","pageContextFromHook","onBeforeRenderExecute","getHook","onBeforeRender","pageContextReadyForRelease","releasePageContext","hookResult","callHookWithTimeout","onBeforeRenderServerSideExists","pageContextFromServer","retrievePageContextFromServer","getPageConfig","getCodeFilePath","hasOnBeforeRenderServerSideOnlyHook","pageContextFromRoute","err","markIs404","checkIf404","pageContextUrl","response","contentType","isRightContentType","responseText","responseObject","parse","getProjectError","getBaseServer","isBaseServer","createPageContext","pageContextBase","getPageFilesAll","getPageId","routeContext","getExportNames","analyzeExports","pageFilesClientSide","pageFilesServerSide","isHtmlOnly","isClientRouting","assertClientSideRenderHook","hasClientSideRenderHook","determineClientEntry","clientEntries","clientDependencies","clientEntry","getVPSClientEntry","analyzePageClientSide","getPageFilesClientSide","removeOverridenPageFiles","analyzePageClientSideInit","sharedPageFilesAlreadyLoaded","pageFilesClientSide_","analyzeClientSide","getConfigValue","onRenderClientExists","PageExists","isClientSideRoutable","findPageConfig","isClientSideRenderable","skipLink","linkTag","isNewTabLink","isHashUrl","hasBaseServer","isParsable","target","rel","removeHash","getPrefetchSettings","prefetchStaticAssets","getPrefetchStaticAssets","assertInfo","prefetchAttribute","getPrefetchAttribute","wrongUsageMsg","when","correctValue","attr","attrOld","deprecationNotice","linkAlreadyPrefetched","isAlreadyPrefetched","prefetchUrl","getPrefetchUrl","markAsAlreadyPrefetched","linkPrefetchHandlerAdded","prefetch","checkIfClientRouting","isErrorFetchingStaticAssets","disableClientRouting","addLinkPrefetchHandlers","observer","entries","entry","initHistoryState","state","hasModifications","getTimestamp","getScrollPosition","assertState","replaceHistoryState","getHistoryState","saveScrollPosition","scrollPosition","pushHistory","overwriteLastHistoryEntry","timestamp","pushHistoryState","defineNavigate","navigate_","stamp","isRenderErrorPageException","assertRenderErrorPageExceptionUsage","RenderErrorPage","that","getState","setupNativeScrollRestoration","logError","useClientRouter","autoSaveScrollPosition","onLinkClick","keepScrollPosition","fetchAndRender","onBrowserHistoryNavigation","scrollTarget","isBackwardNavigation","renderingCounter","renderPromise","isTransitioning","checkClientSideRenderable","isClientRoutable","renderingNumber","hydrationCanBeAborted","shouldAbort","isFirstRenderAttempt","checkIfAbort","assertHook","changeUrl","executeOnRenderClientHook","onHydrationEnd","setScrollPosition","browserNativeScrollRestoration_disable","callback","onClick","ev","isNormalLeftClick","findLinkTag","parentNode","currentState","isHashNavigation","getUrlHash","hashTarget","setScroll","scroll","done","start","onPageHide","browserNativeScrollRestoration_enable","onPageShow","listener","handleErrorFetchingStaticAssets","onClientEntry_ClientRouting"],"sources":["../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isPlainObject.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/stringifyStringArray.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/hasPropertyGetter.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isPromise.js","../../../../pages/community/create/index.page.route.ts","../../../../pages/community/edit/index.page.route.ts","../../../../pages/community/post/index.page.route.ts","../../../../pages/community/search/index.page.route.ts","../../../../pages/home/index.page.route.ts","../../../../pages/my-lists/bookmark/index.page.route.ts","../../../../pages/search/index.page.route.tsx","../../../../pages/search/keyword/index.page.route.ts","../../../../pages/search/restaurant/index.page.route.ts","../../../../pages/search/restaurant/reviews/create/index.page.route.ts","../../../../pages/search/restaurant/reviews/edit/index.page.route.ts","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/pageFiles.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/getUrlPathname.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isExternalLink.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isReact.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isSameErrorMessage.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/serverSideRouteTo.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/sleep.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/throttle.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/utils.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/navigationState.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageServerSide.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isObjectWithKeys.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isStringRecord.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/utils.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/deduceRouteStringFromFilesystemPath.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/loadPageRoutes.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/addComputedUrlProps.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/resolveRouteString.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/resolvePrecedence.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/resolveRouteFunction.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/assertPageContextProvidedByUser.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/callOnBeforeRouteHook.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/debug.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/index.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/getPageContext/removeBuiltInOverrides.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/urlToFile.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageContextRequestUrl.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/assertObjectKeys.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/assertOnBeforeRenderHookReturn.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/getPageContext.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/getBaseServer.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/createPageContext.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/getPageId.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide/getExportNames.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide/analyzeExports.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide/determineClientEntry.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzeClientSide.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/skipLink/isClientSideRoutable.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/skipLink.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/prefetch/getPrefetchSettings.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/prefetch/alreadyPrefetched.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/prefetch.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/history.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/navigate.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/RenderErrorPage.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/useClientRouter.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/entry.js"],"sourcesContent":["export { isPlainObject };\nfunction isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    // Support `Object.create(null)`\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    return (\n    /* Doesn't work in Cloudlfare Pages workers\n    value.constructor === Object\n    */\n    value.constructor.name === 'Object');\n}\n","export { stringifyStringArray };\nfunction stringifyStringArray(stringList) {\n    return '[' + stringList.map((str) => \"'\" + str + \"'\").join(', ') + ']';\n}\n","export function hasPropertyGetter(obj, prop) {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n    return !!descriptor && !('value' in descriptor) && !!descriptor.get;\n}\n","import { isCallable } from './isCallable';\nexport function isPromise(val) {\n    return typeof val === 'object' && val !== null && 'then' in val && isCallable(val.then);\n}\n","export default '/community/create';\r\n","export default '/community/edit/@postId';\r\n","export default '/community/@postId';\r\n","export default '/community/search/@keyword';\r\n","export default '/';\r\n","export default '/my-lists/bookmark/@bookmarkGroupName';\r\n","export default '/search';\r\n","export default '/search/keyword/@keyword';\r\n","export default '/search/@restaurantId';\r\n","export default '/search/@restaurantId/reviews/create';\r\n","export default '/search/@restaurantId/reviews/@reviewId/edit';\r\n","import { setPageFiles } from '../../shared/getPageFiles';\n// @ts-ignore\nimport * as pageFilesExports from 'virtual:vite-plugin-ssr:importUserCode:client:client-routing';\nsetPageFiles(pageFilesExports);\n","export { getUrlPathname };\nimport { parseUrl } from './parseUrl';\nfunction getUrlPathname(url) {\n    const urlPathname = parseUrl(url, '/').pathname;\n    return urlPathname;\n}\n","export { isExternalLink };\nfunction isExternalLink(url) {\n    return !url.startsWith('/') && !url.startsWith('.') && !url.startsWith('?') && url !== '';\n}\n","// There doesn't seem to be a reliable way to detect React:\n//  - https://stackoverflow.com/questions/73156433/detect-with-javascript-whether-the-website-is-using-react\nexport function isReact() {\n    var _a, _b, _c, _d;\n    // Heuristic using values set by React (Dev Tools)\n    // - `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` is an internal API for React Dev Tools\n    //   - https://stackoverflow.com/questions/46807826/how-does-react-developer-tools-determine-that-the-webpage-is-using-react/46808361#46808361\n    //   - In principle, `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` should exist only if React Dev Tools is installed. (Although it seems that it's sometimes defined even when React Dev Tools isn't installed; I don't know why.)\n    // - We use `isReact1`/`isReact2` merely to validate `isReact3` and `isReact4`. Because `isReact1`/`isReact2` can be false negatives:\n    //   - React populates `__REACT_DEVTOOLS_GLOBAL_HOOK__.renderers` fairly late => false negative early in the rendering phase\n    //   - `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` is `undefined` if React Dev Tools isn't installed => false negative\n    const isReact1 = !!((_b = (_a = window.__REACT_DEVTOOLS_GLOBAL_HOOK__) === null || _a === void 0 ? void 0 : _a.renderers) === null || _b === void 0 ? void 0 : _b.size);\n    const isReact2 = !!((_d = (_c = window.__REACT_DEVTOOLS_GLOBAL_HOOK__) === null || _c === void 0 ? void 0 : _c.rendererInterfaces) === null || _d === void 0 ? void 0 : _d.size);\n    // Heuristic using values set by `@vitejs/plugin-react`\n    const isReact3 = !!window.__vite_plugin_react_preamble_installed__;\n    /* Also set by Preact Vite plugin `@preact/preset-vite`\n    const isReact4 = !!(window as any).$RefreshReg$\n    */\n    // console.log({ isReact1, isReact2, isReact3 })\n    return isReact1 || isReact2 || isReact3;\n}\n","export { isSameErrorMessage };\nfunction isSameErrorMessage(err1, err2) {\n    return (err1 === null || err1 === void 0 ? void 0 : err1.message) === (err2 === null || err2 === void 0 ? void 0 : err2.message);\n}\n","export { serverSideRouteTo };\nfunction serverSideRouteTo(url) {\n    window.location.href = url;\n}\n","export { sleep };\nfunction sleep(milliseconds) {\n    return new Promise((r) => setTimeout(r, milliseconds));\n}\n","export { throttle };\nfunction throttle(func, waitTime) {\n    let isQueued = false;\n    return () => {\n        if (!isQueued) {\n            isQueued = true;\n            setTimeout(() => {\n                isQueued = false;\n                func();\n            }, waitTime);\n        }\n    };\n}\n","// Utils needed by Client Routing.\n// Ensure we don't bloat the server-side with client utils\nimport { isBrowser } from '../../utils/isBrowser';\nimport { assert } from '../../utils/assert';\nassert(isBrowser());\n// Ensure we don't bloat Server Routing with Client Routing utils\nimport { assertClientRouting } from '../../utils/assertRoutingType';\nassertClientRouting();\n// We load the Server Routing utils: we tolerate the tiny amount of code that is only needed by Server Routing (only 1-2 lines).\n// We re-export some of the utils down below only to list the utils needed by Client Routing.\nexport * from '../../client/utils';\nexport * from '../../utils/assert';\nexport * from '../../utils/assertSingleInstance';\nexport * from '../../utils/callHookWithTimeout';\nexport * from '../../utils/getCurrentUrl';\nexport * from '../../utils/getGlobalObject';\nexport * from '../../utils/getUrlPathname';\nexport * from '../../utils/hasProp';\nexport * from '../../utils/isBrowser';\nexport * from '../../utils/isCallable';\nexport * from '../../utils/isExternalLink';\nexport * from '../../utils/isObject';\nexport * from '../../utils/isPlainObject';\nexport * from '../../utils/isReact';\nexport * from '../../utils/isSameErrorMessage';\nexport * from '../../utils/objectAssign';\nexport * from '../../utils/parseUrl';\nexport * from '../../utils/projectInfo';\nexport * from '../../utils/PromiseType';\nexport * from '../../utils/serverSideRouteTo';\nexport * from '../../utils/sleep';\nexport * from '../../utils/slice';\nexport * from '../../utils/throttle';\nexport * from '../../utils/assertRoutingType';\n","import { getCurrentUrl, getGlobalObject } from './utils';\nconst globalObject = getGlobalObject('navigationState.ts', {});\nconst urlFirst = getCurrentUrl();\nexport const navigationState = {\n    markNavigationChange() {\n        globalObject.navigationChanged = true;\n    },\n    get noNavigationChangeYet() {\n        return !globalObject.navigationChanged && this.isFirstUrl(getCurrentUrl());\n    },\n    isFirstUrl(url) {\n        return url === urlFirst;\n    }\n};\n","export { analyzePageServerSide };\nimport { assert } from '../utils';\nimport { getPageFilesServerSide } from './getAllPageIdFiles';\nasync function analyzePageServerSide(pageFilesAll, pageId) {\n    const pageFilesServerSide = getPageFilesServerSide(pageFilesAll, pageId);\n    const pageFilesServerSideOnly = pageFilesServerSide.filter((p) => p.fileType === '.page.server');\n    await Promise.all(pageFilesServerSideOnly.map(async (p) => {\n        // In production, `exportNames` are preload\n        if (p.exportNames) {\n            return;\n        }\n        assert(p.loadExportNames, pageId);\n        await p.loadExportNames();\n    }));\n    const hasOnBeforeRenderServerSideOnlyHook = pageFilesServerSideOnly.some(({ exportNames }) => {\n        assert(exportNames);\n        return exportNames.includes('onBeforeRender');\n    });\n    return { hasOnBeforeRenderServerSideOnlyHook };\n}\n","import { isPlainObject } from './isPlainObject';\nexport { isObjectWithKeys };\nfunction isObjectWithKeys(obj, keys) {\n    if (!isPlainObject(obj)) {\n        return false;\n    }\n    for (const key of Object.keys(obj)) {\n        if (!keys.includes(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n","export function isStringRecord(thing) {\n    return typeof thing === 'object' && thing !== null && Object.values(thing).every((val) => typeof val === 'string');\n}\n","// Utils needed by:\n//  - runtime of server\n//  - runtime of client (Client Routing)\n// Ensure we don't bloat runtime of Server Routing with the utils down below\nimport { assertClientRouting } from '../../utils/assertRoutingType';\nimport { isBrowser } from '../../utils/isBrowser';\nif (isBrowser()) {\n    assertClientRouting();\n}\nexport * from '../../utils/assert';\nexport * from '../../utils/hasProp';\nexport * from '../../utils/isObjectWithKeys';\nexport * from '../../utils/sorter';\nexport * from '../../utils/isPromise';\nexport * from '../../utils/isPlainObject';\nexport * from '../../utils/objectAssign';\nexport * from '../../utils/slice';\nexport * from '../../utils/isStringRecord';\nexport * from '../../utils/unique';\nexport * from '../../utils/isBrowser';\nexport * from '../../utils/parseUrl';\n","// Unit tests at ./deduceRouteStringFromFilesystemPath.spec.ts\nimport { assert, higherFirst, slice } from './utils';\nexport { deduceRouteStringFromFilesystemPath };\n// TODO/next-major-update: remove this and whole filesystemRoot mechanism\nfunction deduceRouteStringFromFilesystemPath(pageId, filesystemRoots) {\n    // Handle Filesystem Routing Root\n    const filesystemRootsMatch = filesystemRoots\n        .filter(({ filesystemRoot }) => pageId.startsWith(filesystemRoot))\n        .sort(higherFirst(({ filesystemRoot }) => filesystemRoot.length));\n    const fsBase = filesystemRootsMatch[0];\n    let filesystemRoute;\n    if (fsBase) {\n        // Example values:\n        //  - `{\"pageId\":\"/pages/index\",\"filesystemRoot\":\"/\",\"urlRoot\":\"/client_portal\"}`\n        const { filesystemRoot, urlRoot } = fsBase;\n        const debugInfo = { pageId, filesystemRoot, urlRoot };\n        assert(urlRoot.startsWith('/') && pageId.startsWith('/') && filesystemRoot.startsWith('/'), debugInfo);\n        assert(pageId.startsWith(filesystemRoot), debugInfo);\n        if (filesystemRoot !== '/') {\n            assert(!filesystemRoot.endsWith('/'), debugInfo);\n            filesystemRoute = slice(pageId, filesystemRoot.length, 0);\n        }\n        else {\n            filesystemRoute = pageId;\n        }\n        assert(filesystemRoute.startsWith('/'), debugInfo);\n        filesystemRoute = urlRoot + (urlRoot.endsWith('/') ? '' : '/') + slice(filesystemRoute, 1, 0);\n    }\n    else {\n        filesystemRoute = pageId;\n    }\n    assert(filesystemRoute.startsWith('/'));\n    // Remove `pages/`, `index/, and `src/`, directories\n    filesystemRoute = filesystemRoute\n        .split('/')\n        .filter((dir) => dir !== 'pages' && dir !== 'src' && dir !== 'index')\n        .join('/');\n    // Hanlde `/index.page.*` suffix\n    assert(!filesystemRoute.includes('.page.'));\n    assert(!filesystemRoute.endsWith('.'));\n    if (filesystemRoute.endsWith('/index')) {\n        filesystemRoute = slice(filesystemRoute, 0, -'/index'.length);\n    }\n    if (filesystemRoute === '') {\n        filesystemRoute = '/';\n    }\n    assert(filesystemRoute.startsWith('/'));\n    assert(!filesystemRoute.endsWith('/') || filesystemRoute === '/');\n    return filesystemRoute;\n}\n","import { isErrorPageId } from '../error-page';\nimport { assert, assertUsage, hasProp, slice } from './utils';\nimport { deduceRouteStringFromFilesystemPath } from './deduceRouteStringFromFilesystemPath';\nimport { isCallable } from '../utils';\nexport { loadPageRoutes };\nexport { findPageRouteFile };\nasync function loadPageRoutes(\n// TODO: remove all arguments and use GlobalContext instead\npageFilesAll, pageConfigs, pageConfigGlobal, allPageIds) {\n    await Promise.all(pageFilesAll.filter((p) => p.fileType === '.page.route').map((p) => { var _a; return (_a = p.loadFile) === null || _a === void 0 ? void 0 : _a.call(p); }));\n    const { onBeforeRouteHook, filesystemRoots } = getGlobalHooks(pageFilesAll, pageConfigs, pageConfigGlobal);\n    const pageRoutes = getPageRoutes(filesystemRoots, pageFilesAll, pageConfigs, allPageIds);\n    return { pageRoutes, onBeforeRouteHook };\n}\nfunction getPageRoutes(filesystemRoots, pageFilesAll, pageConfigs, allPageIds) {\n    const pageRoutes = [];\n    let pageIds = [...allPageIds];\n    // V1 Design\n    if (pageConfigs.length > 0) {\n        assert(filesystemRoots === null);\n        const comesFromV1PageConfig = true;\n        pageConfigs\n            .filter((p) => !p.isErrorPage)\n            .forEach((pageConfig) => {\n            const pageId = pageConfig.pageId;\n            pageIds = removePageId(pageIds, pageId);\n            let pageRoute = null;\n            {\n                const routeConfig = pageConfig.configElements.route;\n                if (routeConfig) {\n                    assert('configValue' in routeConfig); // Route files are eagerly loaded\n                    const route = routeConfig.configValue;\n                    const routeDefinedAt = routeConfig.configDefinedAt;\n                    assert(routeDefinedAt);\n                    if (typeof route === 'string') {\n                        pageRoute = { pageId, comesFromV1PageConfig, routeString: route, routeDefinedAt, routeType: 'STRING' };\n                    }\n                    else {\n                        assert(isCallable(route));\n                        let allowAsync = false;\n                        const allowSyncConfig = pageConfig.configElements.iKnowThePerformanceRisksOfAsyncRouteFunctions;\n                        if (allowSyncConfig) {\n                            const val = allowSyncConfig.configValue;\n                            assert(typeof val === 'boolean', `${allowSyncConfig.configDefinedAt} should be a boolean`);\n                            allowAsync = val;\n                        }\n                        pageRoute = {\n                            pageId,\n                            comesFromV1PageConfig,\n                            routeFunction: route,\n                            routeDefinedAt,\n                            routeType: 'FUNCTION',\n                            allowAsync\n                        };\n                    }\n                }\n            }\n            if (!pageRoute) {\n                const { routeFilesystem, routeFilesystemDefinedBy } = pageConfig;\n                assert(routeFilesystem);\n                assert(routeFilesystem.startsWith('/'));\n                assert(routeFilesystemDefinedBy);\n                pageRoute = {\n                    pageId,\n                    routeFilesystemDefinedBy,\n                    comesFromV1PageConfig,\n                    routeString: routeFilesystem,\n                    routeDefinedAt: null,\n                    routeType: 'FILESYSTEM'\n                };\n            }\n            assert(pageRoute);\n            pageRoutes.push(pageRoute);\n        });\n    }\n    // Old design\n    // TODO/v1-release: remove\n    if (pageConfigs.length === 0) {\n        assert(filesystemRoots);\n        const comesFromV1PageConfig = false;\n        pageIds\n            .filter((pageId) => !isErrorPageId(pageId, false))\n            .forEach((pageId) => {\n            const pageRouteFile = findPageRouteFile(pageId, pageFilesAll);\n            if (!pageRouteFile) {\n                const routeString = deduceRouteStringFromFilesystemPath(pageId, filesystemRoots);\n                assert(routeString.startsWith('/'));\n                assert(!routeString.endsWith('/') || routeString === '/');\n                pageRoutes.push({\n                    pageId,\n                    comesFromV1PageConfig,\n                    routeString,\n                    routeDefinedAt: null,\n                    routeFilesystemDefinedBy: `${pageId}.page.*`,\n                    routeType: 'FILESYSTEM'\n                });\n            }\n            else {\n                const { filePath, fileExports } = pageRouteFile;\n                assert(fileExports);\n                assertUsage('default' in fileExports, `${filePath} should have a default export.`);\n                if (hasProp(fileExports, 'default', 'string')) {\n                    const routeString = fileExports.default;\n                    assertUsage(routeString.startsWith('/'), `A Route String should start with a leading \\`/\\` but \\`${filePath}\\` has \\`export default '${routeString}'\\`. Make sure to \\`export default '/${routeString}'\\` instead.`);\n                    pageRoutes.push({\n                        pageId,\n                        comesFromV1PageConfig,\n                        routeString,\n                        routeDefinedAt: filePath,\n                        routeType: 'STRING'\n                    });\n                    return;\n                }\n                if (hasProp(fileExports, 'default', 'function')) {\n                    const routeFunction = fileExports.default;\n                    let allowAsync = false;\n                    const allowKey = 'iKnowThePerformanceRisksOfAsyncRouteFunctions';\n                    if (allowKey in fileExports) {\n                        assertUsage(hasProp(fileExports, allowKey, 'boolean'), `The export \\`${allowKey}\\` of ${filePath} should be a boolean.`);\n                        allowAsync = fileExports[allowKey];\n                    }\n                    pageRoutes.push({\n                        pageId,\n                        comesFromV1PageConfig,\n                        routeFunction,\n                        routeDefinedAt: filePath,\n                        allowAsync,\n                        routeType: 'FUNCTION'\n                    });\n                    return;\n                }\n                assertUsage(false, `The default export of ${filePath} should be a string or a function.`);\n            }\n        });\n    }\n    return pageRoutes;\n}\nfunction getGlobalHooks(pageFilesAll, pageConfigs, pageConfigGlobal) {\n    // V1 Design\n    if (pageConfigs.length > 0) {\n        if (pageConfigGlobal.onBeforeRoute) {\n            const hookFn = pageConfigGlobal.onBeforeRoute.configValue;\n            if (hookFn) {\n                const hookFilePath = pageConfigGlobal.onBeforeRoute.codeFilePath;\n                assert(hookFilePath);\n                assertUsage(isCallable(hookFn), `The hook onBeforeRoute() defined by ${hookFilePath} should be a function.`);\n                const onBeforeRouteHook = {\n                    hookFilePath: hookFilePath,\n                    onBeforeRoute: hookFn\n                };\n                return { onBeforeRouteHook, filesystemRoots: null };\n            }\n        }\n        return { onBeforeRouteHook: null, filesystemRoots: null };\n    }\n    // Old design\n    // TODO/v1-release: remove\n    let onBeforeRouteHook = null;\n    const filesystemRoots = [];\n    pageFilesAll\n        .filter((p) => p.fileType === '.page.route' && p.isDefaultPageFile)\n        .forEach(({ filePath, fileExports }) => {\n        assert(fileExports);\n        if ('onBeforeRoute' in fileExports) {\n            assertUsage(hasProp(fileExports, 'onBeforeRoute', 'function'), `\\`export { onBeforeRoute }\\` of ${filePath} should be a function.`);\n            const { onBeforeRoute } = fileExports;\n            onBeforeRouteHook = { hookFilePath: `${filePath} > \\`export { onBeforeRoute }\\``, onBeforeRoute };\n        }\n        if ('filesystemRoutingRoot' in fileExports) {\n            assertUsage(hasProp(fileExports, 'filesystemRoutingRoot', 'string'), `\\`export { filesystemRoutingRoot }\\` of ${filePath} should be a string.`);\n            assertUsage(hasProp(fileExports, 'filesystemRoutingRoot', 'string'), `\\`export { filesystemRoutingRoot }\\` of ${filePath} is \\`'${fileExports.filesystemRoutingRoot}'\\` but it should start with a leading slash \\`/\\`.`);\n            filesystemRoots.push({\n                filesystemRoot: dirname(filePath),\n                urlRoot: fileExports.filesystemRoutingRoot\n            });\n        }\n    });\n    return { onBeforeRouteHook, filesystemRoots };\n}\nfunction findPageRouteFile(pageId, pageFilesAll) {\n    return pageFilesAll.find((p) => p.pageId === pageId && p.fileType === '.page.route');\n}\nfunction dirname(filePath) {\n    assert(filePath.startsWith('/'));\n    assert(!filePath.endsWith('/'));\n    const paths = filePath.split('/');\n    const dirPath = slice(paths, 0, -1).join('/') || '/';\n    assert(dirPath.startsWith('/'));\n    assert(!dirPath.endsWith('/') || dirPath === '/');\n    return dirPath;\n}\nfunction removePageId(pageIds, pageId) {\n    const { length } = pageIds;\n    pageIds = pageIds.filter((id) => id !== pageId);\n    assert(pageIds.length === length - 1);\n    return pageIds;\n}\n","import { assert, parseUrl, assertWarning, isPlainObject, hasPropertyGetter } from './utils';\nexport { addComputedUrlProps };\nexport { assertURLs };\nfunction addComputedUrlProps(pageContext, enumerable = true) {\n    assert(pageContext.urlOriginal);\n    if ('urlPathname' in pageContext) {\n        assert(hasPropertyGetter(pageContext, 'urlPathname'));\n    }\n    Object.defineProperty(pageContext, 'urlPathname', {\n        get: urlPathnameGetter,\n        enumerable,\n        configurable: true\n    });\n    // TODO/v1-release: move pageContext.urlParsed to pageContext.url\n    if ('url' in pageContext)\n        assert(hasPropertyGetter(pageContext, 'url'));\n    Object.defineProperty(pageContext, 'url', {\n        get: urlGetter,\n        enumerable: false,\n        configurable: true\n    });\n    if ('urlParsed' in pageContext) {\n        assert(hasPropertyGetter(pageContext, 'urlParsed'));\n    }\n    Object.defineProperty(pageContext, 'urlParsed', {\n        get: urlParsedGetter,\n        enumerable,\n        configurable: true\n    });\n}\nfunction getUrlParsed(pageContext) {\n    let urlHandler = pageContext._urlHandler;\n    if (!urlHandler) {\n        urlHandler = (urlOriginal) => urlOriginal;\n    }\n    const url = urlHandler(pageContext.urlOriginal);\n    const baseServer = pageContext._baseServer;\n    assert(baseServer.startsWith('/'));\n    return parseUrl(url, baseServer);\n}\nfunction urlPathnameGetter() {\n    const { pathname } = getUrlParsed(this);\n    const urlPathname = pathname;\n    assert(urlPathname.startsWith('/'));\n    return urlPathname;\n}\nfunction urlGetter() {\n    assertWarning(false, '`pageContext.url` is outdated. Use `pageContext.urlPathname`, `pageContext.urlParsed`, or `pageContext.urlOriginal` instead. (See https://vite-plugin-ssr.com/migration/0.4.23 for more information.)', { onlyOnce: true, showStackTrace: true });\n    return urlPathnameGetter.call(this);\n}\nfunction urlParsedGetter() {\n    const urlParsedOriginal = getUrlParsed(this);\n    const { origin, pathname, pathnameOriginal, search, searchAll, searchOriginal, hash, hashOriginal } = urlParsedOriginal;\n    const urlParsed = {\n        origin,\n        pathname,\n        pathnameOriginal,\n        search,\n        searchAll,\n        searchOriginal,\n        hash,\n        hashOriginal,\n        get hashString() {\n            assertWarning(false, '`pageContext.urlParsed.hashString` has been renamed to `pageContext.urlParsed.hashOriginal`', { onlyOnce: true, showStackTrace: true });\n            return hashOriginal;\n        },\n        get searchString() {\n            assertWarning(false, '`pageContext.urlParsed.searchString` has been renamed to `pageContext.urlParsed.searchOriginal`', { onlyOnce: true, showStackTrace: true });\n            return searchOriginal;\n        }\n    };\n    makeNonEnumerable(urlParsed, 'hashString');\n    makeNonEnumerable(urlParsed, 'searchString');\n    return urlParsed;\n}\nfunction makeNonEnumerable(obj, prop) {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n    Object.defineProperty(obj, prop, { ...descriptor, enumerable: false });\n}\nfunction assertURLs(pageContext) {\n    assert(typeof pageContext.urlOriginal === 'string');\n    assert(typeof pageContext.urlPathname === 'string');\n    assert(isPlainObject(pageContext.urlParsed));\n    assert(pageContext.urlPathname === pageContext.urlParsed.pathname);\n}\n","// Unit tests at ./resolveRouteString.spec.ts\nexport { resolveRouteString };\nexport { getUrlFromRouteString };\nexport { isStaticRouteString };\nexport { analyzeRouteString };\n// export { assertRouteString }\nimport { assertWarning } from '../utils';\nimport { assert, assertUsage } from './utils';\nconst PARAM_TOKEN_NEW = '@';\nconst PARAM_TOKEN_OLD = ':';\nfunction assertRouteString(routeString, errMsgPrefix) {\n    assertUsage(routeString.startsWith('/') || routeString === '*', (() => {\n        if (!errMsgPrefix) {\n            errMsgPrefix = 'Invalid';\n        }\n        else {\n            errMsgPrefix = errMsgPrefix + ' invalid';\n        }\n        const routeStr = [`'${routeString}'`, routeString !== '' ? null : '(empty string)'].filter(Boolean).join(' ');\n        const errMsg = `${errMsgPrefix} Route String ${routeStr}: Route Strings should start with a leading slash '/' (or be '*')`;\n        return errMsg;\n    })());\n}\nfunction resolveRouteString(routeString, urlPathname) {\n    assertRouteString(routeString);\n    assert(urlPathname.startsWith('/'));\n    const routeSegments = routeString.split('/');\n    const urlSegments = urlPathname.split('/');\n    const routeParams = {};\n    assertGlob(routeString);\n    if (routeString === '*') {\n        routeString = '/*';\n    }\n    for (let i = 0; i < Math.max(routeSegments.length, urlSegments.length); i++) {\n        const routeSegment = routeSegments[i];\n        const urlSegment = urlSegments[i];\n        if (routeSegment === '*') {\n            routeParams['*'] = urlSegments.slice(Math.max(1, i)).join('/');\n            return { routeParams };\n        }\n        else if (routeSegment && isParam(routeSegment)) {\n            assertWarning(!routeSegment.startsWith(PARAM_TOKEN_OLD), `Outdated Route String \\`${routeString}\\`, use \\`${routeString\n                .split(PARAM_TOKEN_OLD)\n                .join(PARAM_TOKEN_NEW)}\\` instead.`, { showStackTrace: false, onlyOnce: true });\n            if (!urlSegment) {\n                return null;\n            }\n            routeParams[routeSegment.slice(1)] = urlSegment;\n        }\n        else {\n            if ((routeSegment || '') !== (urlSegment || '')) {\n                return null;\n            }\n        }\n    }\n    return { routeParams };\n}\nfunction getUrlFromRouteString(routeString) {\n    assert(routeString.startsWith('/'));\n    if (isStaticRouteString(routeString)) {\n        const url = routeString;\n        return url;\n    }\n    return null;\n}\nfunction assertGlob(routeString) {\n    const numberOfGlobChars = routeString.split('*').length - 1;\n    assertUsage(numberOfGlobChars <= 1, `Invalid Route String \\`${routeString}\\`: Route Strings are not allowed to contain more than one glob character \\`*\\`.`);\n    assertUsage(numberOfGlobChars === 0 || (numberOfGlobChars === 1 && routeString.endsWith('*')), `Invalid Route String \\`${routeString}\\`: make sure your Route String ends with the glob character \\`*\\`.`);\n}\nfunction analyzeRouteString(routeString) {\n    const routeSegments = routeString.split('/').filter((routeSegment) => routeSegment !== '' && routeSegment !== '*');\n    let numberOfStaticSegmentsBeginning = 0;\n    for (const routeSegment of routeSegments) {\n        if (isParam(routeSegment)) {\n            break;\n        }\n        numberOfStaticSegmentsBeginning++;\n    }\n    const numberOfStaticSegements = routeSegments.filter((s) => !isParam(s)).length;\n    const numberOfParameterSegments = routeSegments.filter((s) => isParam(s)).length;\n    const isCatchAll = routeString.endsWith('*');\n    return { numberOfParameterSegments, numberOfStaticSegmentsBeginning, numberOfStaticSegements, isCatchAll };\n}\nfunction isParam(routeSegment) {\n    return routeSegment.startsWith(PARAM_TOKEN_NEW) || routeSegment.startsWith(PARAM_TOKEN_OLD);\n}\nfunction isStaticRouteString(routeString) {\n    const url = routeString;\n    const match = resolveRouteString(routeString, url);\n    assert(match);\n    return Object.keys(match.routeParams).length === 0;\n}\n","export { resolvePrecendence };\n// export type { RouteMatch }\nimport { analyzeRouteString } from './resolveRouteString';\nimport { higherFirst } from './utils';\nimport { makeFirst } from './utils';\nimport { isStaticRouteString } from './resolveRouteString';\n// See https://vite-plugin-ssr.com/route-function#precedence\nfunction resolvePrecendence(routeMatches) {\n    // prettier-ignore\n    routeMatches\n        .sort(sortMatches)\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !!routeMatch.precedence && routeMatch.precedence < 0))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'STRING' && isStaticRouteString(routeMatch.routeString) === false))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !routeMatch.precedence))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'STRING' && isStaticRouteString(routeMatch.routeString) === true))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FILESYSTEM'))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !!routeMatch.precedence && routeMatch.precedence > 0));\n}\n// -1 => routeMatch1 higher precedence\n// +1 => routeMatch2 higher precedence\nfunction sortMatches(routeMatch1, routeMatch2) {\n    var _a, _b;\n    {\n        const precedence1 = (_a = routeMatch1.precedence) !== null && _a !== void 0 ? _a : 0;\n        const precedence2 = (_b = routeMatch2.precedence) !== null && _b !== void 0 ? _b : 0;\n        if (precedence1 !== precedence2) {\n            return precedence1 > precedence2 ? -1 : 1;\n        }\n    }\n    if (!routeMatch2.routeString) {\n        return 0;\n    }\n    if (!routeMatch1.routeString) {\n        return 0;\n    }\n    // Return route with highest number of static path segments at beginning first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfStaticSegmentsBeginning;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            return result;\n        }\n    }\n    // Return route with highest number of static path segments in total first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfStaticSegements;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            return result;\n        }\n    }\n    // Return route with most parameter segements first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfParameterSegments;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            return result;\n        }\n    }\n    // Return catch-all routes last\n    {\n        if (analyzeRouteString(routeMatch2.routeString).isCatchAll) {\n            return -1;\n        }\n        if (analyzeRouteString(routeMatch1.routeString).isCatchAll) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","export { resolveRouteFunction };\nexport { assertRouteParams };\nimport { assertURLs } from '../addComputedUrlProps';\nimport { assert, assertUsage, hasProp, isPlainObject, isPromise, isStringRecord } from './utils';\nasync function resolveRouteFunction(routeFunction, allowAsync, pageContext, routeDefinedAt) {\n    assertURLs(pageContext);\n    let result = routeFunction(pageContext);\n    assertUsage(!isPromise(result) || allowAsync, `The Route Function ${routeDefinedAt} returned a promise; async route functions are opt-in, see https://vite-plugin-ssr.com/route-function#async`);\n    result = await result;\n    if (result === false) {\n        return null;\n    }\n    if (result === true) {\n        result = {};\n    }\n    assertUsage(isPlainObject(result), `The Route Function ${routeDefinedAt} should return a boolean or a plain JavaScript object, instead it returns \\`${hasProp(result, 'constructor') ? result.constructor : result}\\`.`);\n    if ('match' in result) {\n        const { match } = result;\n        assertUsage(typeof match === 'boolean', `The \\`match\\` value returned by the Route Function ${routeDefinedAt} should be a boolean.`);\n        if (!match) {\n            return null;\n        }\n    }\n    let precedence = null;\n    if ('precedence' in result) {\n        precedence = result.precedence;\n        assertUsage(typeof precedence === 'number', `The \\`precedence\\` value returned by the Route Function ${routeDefinedAt} should be a number.`);\n    }\n    assertRouteParams(result, `The \\`routeParams\\` object returned by the Route Function ${routeDefinedAt} should`);\n    const routeParams = result.routeParams || {};\n    assertUsage(!('pageContext' in result), 'Providing `pageContext` in Route Functions is prohibited, see https://vite-plugin-ssr.com/route-function#cannot-provide-pagecontext');\n    assert(isPlainObject(routeParams));\n    Object.keys(result).forEach((key) => {\n        assertUsage(key === 'match' || key === 'routeParams' || key === 'precedence', `The Route Function ${routeDefinedAt} returned an object with an unknown key \\`{ ${key} }\\`. Allowed keys: ['match', 'routeParams', 'precedence'].`);\n    });\n    return {\n        precedence,\n        routeParams\n    };\n}\nfunction assertRouteParams(result, errPrefix) {\n    assert(errPrefix.endsWith(' should'));\n    if (!hasProp(result, 'routeParams')) {\n        return;\n    }\n    assert(errPrefix.endsWith(' should'));\n    assertUsage(isPlainObject(result.routeParams), `${errPrefix} be a plain JavaScript object.`);\n    assertUsage(isStringRecord(result.routeParams), `${errPrefix} only hold string values.`);\n}\n","import { assert, assertUsage, assertWarning, isObject } from './utils';\nexport { assertPageContextProvidedByUser };\nfunction assertPageContextProvidedByUser(pageContextProvidedByUser, { hook, errorMessagePrefix, isRenderErrorPage }) {\n    const errPrefix = (() => {\n        if (errorMessagePrefix) {\n            return errorMessagePrefix;\n        }\n        else {\n            assert(hook);\n            const { hookName, hookFilePath } = hook;\n            assert(!hookName.endsWith(')'));\n            return `The \\`pageContext\\` object provided by the ${hookName}() hook defined by ${hookFilePath}`;\n        }\n    })();\n    assertUsage(isObject(pageContextProvidedByUser), `${errPrefix} should be an object instead of \\`${typeof pageContextProvidedByUser}\\``);\n    assertUsage(!('_objectCreatedByVitePluginSsr' in pageContextProvidedByUser), `${errPrefix} shouldn't be the whole \\`pageContext\\` object, see https://vite-plugin-ssr.com/pageContext-manipulation#do-not-return-entire-pagecontext`);\n    // In principle, it's possible to use `onBeforeRoute()` to override and define the whole routing.\n    // Is that a good idea to allow users to do this? Beyond deep integration with Vue Router or React Router, is there a use case for this?\n    assertWarning(!('_pageId' in pageContextProvidedByUser), `${errPrefix} sets \\`pageContext._pageId\\` which means that vite-plugin-ssr's routing is overriden. This is an experimental feature: make sure to contact a vite-plugin-ssr maintainer before using this.`, { showStackTrace: false, onlyOnce: true });\n    if (!isRenderErrorPage) {\n        assertUsage(!('is404' in pageContextProvidedByUser), `${errPrefix} sets \\`pageContext.is404\\` which is forbidden, use \\`throw RenderErrorPage()\\` instead, see https://vite-plugin-ssr.com/RenderErrorPage`);\n    }\n}\n","import { assertPageContextProvidedByUser } from '../assertPageContextProvidedByUser';\nimport { assertUsage, hasProp, isObjectWithKeys, objectAssign, assertWarning, assertUsageUrl } from './utils';\nimport { assertRouteParams } from './resolveRouteFunction';\nexport { callOnBeforeRouteHook };\nasync function callOnBeforeRouteHook(onBeforeRouteHook, pageContext) {\n    const hookReturn = await onBeforeRouteHook.onBeforeRoute(pageContext);\n    const errPrefix = `The onBeforeRoute() hook defined by ${onBeforeRouteHook.hookFilePath}`;\n    assertUsage(hookReturn === null ||\n        hookReturn === undefined ||\n        (isObjectWithKeys(hookReturn, ['pageContext']) && hasProp(hookReturn, 'pageContext')), `${errPrefix} should return \\`null\\`, \\`undefined\\`, or a plain JavaScript object \\`{ pageContext: { /* ... */ } }\\`.`);\n    if (hookReturn === null || hookReturn === undefined) {\n        return null;\n    }\n    assertUsage(hasProp(hookReturn, 'pageContext', 'object'), `${errPrefix} returned \\`{ pageContext }\\` but pageContext should be a plain JavaScript object.`);\n    if (hasProp(hookReturn.pageContext, '_pageId') && !hasProp(hookReturn.pageContext, '_pageId', 'null')) {\n        const errPrefix2 = `${errPrefix} returned \\`{ pageContext: { _pageId } }\\` but _pageId should be`;\n        assertUsage(hasProp(hookReturn.pageContext, '_pageId', 'string'), `${errPrefix2} a string or null`);\n        assertUsage(pageContext._allPageIds.includes(hookReturn.pageContext._pageId), `${errPrefix2} one of following values: \\`[${pageContext._allPageIds.map((s) => `'${s}'`).join(', ')}]\\`.`);\n    }\n    if (hasProp(hookReturn.pageContext, 'routeParams')) {\n        assertRouteParams(hookReturn.pageContext, `${errPrefix} returned \\`{ pageContext: { routeParams } }\\` but routeParams should`);\n    }\n    const pageContextAddendumHook = {};\n    if (hasProp(hookReturn.pageContext, 'url')) {\n        assertWarning(false, `${errPrefix} returned \\`{ pageContext: { url } }\\` but \\`pageContext.url\\` has been renamed to \\`pageContext.urlOriginal\\`. Return \\`{ pageContext: { urlOriginal } }\\` instead. (See https://vite-plugin-ssr.com/migration/0.4.23 for more information.)`, { showStackTrace: false, onlyOnce: true });\n        hookReturn.pageContext.urlOriginal = hookReturn.pageContext.url;\n        delete hookReturn.pageContext.url;\n    }\n    if (hasProp(hookReturn.pageContext, 'urlOriginal')) {\n        assertUsageUrl(hookReturn.pageContext.urlOriginal, `${errPrefix} returned \\`{ pageContext: { urlOriginal } }\\` but urlOriginal`);\n        objectAssign(pageContextAddendumHook, { _urlPristine: pageContext.urlOriginal });\n    }\n    assertPageContextProvidedByUser(hookReturn.pageContext, {\n        hook: { hookFilePath: onBeforeRouteHook.hookFilePath, hookName: 'onBeforeRoute' }\n    });\n    objectAssign(pageContextAddendumHook, hookReturn.pageContext);\n    return pageContextAddendumHook;\n}\n","export { debug };\nvar _debug;\nfunction debug(...args) {\n    var _a, _b;\n    if (!_debug) {\n        // We use this trick instead of `import { createDebugger } from '../../utils/debug` in order to ensure that the `debug` mechanism is only loaded on the server-side\n        _debug = (_b = (_a = globalThis).__brillout_debug_createDebugger) === null || _b === void 0 ? void 0 : _b.call(_a, 'vps:routing');\n    }\n    if (_debug) {\n        _debug(...args);\n    }\n}\n","export { route };\nexport { loadPageRoutes } from './loadPageRoutes';\n// Ensure we don't bloat runtime of Server Routing\nimport { assertClientRouting } from '../../utils/assertRoutingType';\nimport { isBrowser } from '../../utils/isBrowser';\nif (isBrowser()) {\n    assertClientRouting();\n}\nimport { assert, assertUsage, hasProp, isPlainObject, objectAssign } from './utils';\nimport { addComputedUrlProps } from '../addComputedUrlProps';\nimport { resolvePrecendence } from './resolvePrecedence';\nimport { resolveRouteString } from './resolveRouteString';\nimport { resolveRouteFunction } from './resolveRouteFunction';\nimport { callOnBeforeRouteHook } from './callOnBeforeRouteHook';\nimport { loadPageRoutes } from './loadPageRoutes';\nimport { debug } from './debug';\nasync function route(pageContext) {\n    addComputedUrlProps(pageContext);\n    const { pageRoutes, onBeforeRouteHook } = await loadPageRoutes(pageContext._pageFilesAll, pageContext._pageConfigs, pageContext._pageConfigGlobal, pageContext._allPageIds);\n    debug('Pages routes:', pageRoutes);\n    const pageContextAddendum = {};\n    if (onBeforeRouteHook) {\n        const pageContextAddendumHook = await callOnBeforeRouteHook(onBeforeRouteHook, pageContext);\n        if (pageContextAddendumHook) {\n            objectAssign(pageContextAddendum, pageContextAddendumHook);\n            if (hasProp(pageContextAddendum, '_pageId', 'string') || hasProp(pageContextAddendum, '_pageId', 'null')) {\n                // We bypass `vite-plugin-ssr`'s routing\n                if (!hasProp(pageContextAddendum, 'routeParams')) {\n                    objectAssign(pageContextAddendum, { routeParams: {} });\n                }\n                else {\n                    assert(hasProp(pageContextAddendum, 'routeParams', 'object'));\n                }\n                objectAssign(pageContextAddendum, {\n                    _routingProvidedByOnBeforeRouteHook: true,\n                    _routeMatches: 'CUSTOM_ROUTE'\n                });\n                return { pageContextAddendum };\n            }\n            // We already assign so that `pageContext.urlOriginal === pageContextAddendum.urlOriginal`; enabling the `onBeforeRoute()` hook to mutate `pageContext.urlOriginal` before routing.\n            objectAssign(pageContext, pageContextAddendum);\n        }\n    }\n    objectAssign(pageContextAddendum, {\n        _routingProvidedByOnBeforeRouteHook: false\n    });\n    // `vite-plugin-ssr`'s routing\n    const allPageIds = pageContext._allPageIds;\n    assert(allPageIds.length >= 0);\n    assertUsage(pageContext._pageFilesAll.length > 0 || pageContext._pageConfigs.length > 0, 'No *.page.js file found. You must create at least one *.page.js file.');\n    assertUsage(allPageIds.length > 0, \"You must create at least one *.page.js file that isn't _default.page.*\");\n    const { urlPathname } = pageContext;\n    assert(urlPathname.startsWith('/'));\n    const routeMatches = [];\n    await Promise.all(pageRoutes.map(async (pageRoute) => {\n        const { pageId, routeType } = pageRoute;\n        // Filesytem Routing\n        if (pageRoute.routeType === 'FILESYSTEM') {\n            const { routeString } = pageRoute;\n            const match = resolveRouteString(routeString, urlPathname);\n            if (match) {\n                const { routeParams } = match;\n                routeMatches.push({ pageId, routeParams, routeString, routeType });\n            }\n            return;\n        }\n        // Route String defined in `.page.route.js`\n        if (pageRoute.routeType === 'STRING') {\n            const { routeString } = pageRoute;\n            const match = resolveRouteString(routeString, urlPathname);\n            if (match) {\n                const { routeParams } = match;\n                assert(routeType === 'STRING');\n                routeMatches.push({\n                    pageId,\n                    routeString,\n                    routeParams,\n                    routeType\n                });\n            }\n            return;\n        }\n        // Route Function defined in `.page.route.js`\n        if (pageRoute.routeType === 'FUNCTION') {\n            const { routeFunction, allowAsync, routeDefinedAt } = pageRoute;\n            const match = await resolveRouteFunction(routeFunction, allowAsync, pageContext, routeDefinedAt);\n            if (match) {\n                const { routeParams, precedence } = match;\n                routeMatches.push({ pageId, precedence, routeParams, routeType });\n            }\n            return;\n        }\n        assert(false);\n    }));\n    resolvePrecendence(routeMatches);\n    const winner = routeMatches[0];\n    debug(`Route matches for URL \\`${urlPathname}\\` (in precedence order):`, routeMatches);\n    objectAssign(pageContextAddendum, { _routeMatches: routeMatches });\n    if (!winner) {\n        objectAssign(pageContextAddendum, {\n            _pageId: null,\n            routeParams: {}\n        });\n        return { pageContextAddendum };\n    }\n    {\n        const { routeParams } = winner;\n        assert(isPlainObject(routeParams));\n        objectAssign(pageContextAddendum, {\n            _pageId: winner.pageId,\n            routeParams: winner.routeParams\n        });\n    }\n    return { pageContextAddendum };\n}\n","export { removeBuiltInOverrides };\nimport { assert, assertWarning } from '../utils';\nconst BUILT_IN_CLIENT_ROUTER = ['urlPathname', 'urlParsed'];\nconst BUILT_IN_CLIENT = ['Page', 'pageExports', 'exports'];\nfunction removeBuiltInOverrides(pageContext) {\n    const alreadySet = [...BUILT_IN_CLIENT, ...BUILT_IN_CLIENT_ROUTER];\n    alreadySet.forEach((prop) => {\n        if (prop in pageContext) {\n            // We need to cast `BUILT_IN_CLIENT` to `string[]`\n            //  - https://stackoverflow.com/questions/56565528/typescript-const-assertions-how-to-use-array-prototype-includes\n            //  - https://stackoverflow.com/questions/57646355/check-if-string-is-included-in-readonlyarray-in-typescript\n            if (BUILT_IN_CLIENT_ROUTER.includes(prop)) {\n                assert(prop.startsWith('url'));\n                assertWarning(false, `\\`pageContext.${prop}\\` is already available in the browser when using Client Routing; including \\`${prop}\\` in \\`passToClient\\` has no effect.`, { showStackTrace: false, onlyOnce: true });\n            }\n            else {\n                assertWarning(false, `\\`pageContext.${prop}\\` is a built-in that cannot be overriden; including \\`${prop}\\` in \\`passToClient\\` has no effect.`, { showStackTrace: false, onlyOnce: true });\n            }\n            delete pageContext[prop];\n        }\n    });\n}\n","export { urlToFile };\nexport { baseServer };\nimport { assert } from './assert';\nimport { parseUrl } from './parseUrl';\nimport { slice } from './slice';\n// - When doing a `.pageContext.json` HTTP request, the base URL should be preserved. (The server-side will handle the base URL.)\n// - While prerendering there is no base URL\nconst baseServer = '/';\nfunction urlToFile(url, fileExtension, doNotCreateExtraDirectory) {\n    const { pathnameOriginal, searchOriginal, hashOriginal } = parseUrl(url, baseServer);\n    if (url.startsWith('/')) {\n        assert(url === `${pathnameOriginal}${searchOriginal || ''}${hashOriginal || ''}`, { url });\n    }\n    const hasTrailingSlash = pathnameOriginal.endsWith('/');\n    let pathnameModified;\n    if (doNotCreateExtraDirectory && pathnameOriginal !== '/') {\n        if (hasTrailingSlash) {\n            pathnameModified = slice(pathnameOriginal, 0, -1);\n        }\n        else {\n            pathnameModified = pathnameOriginal;\n        }\n        assert(!pathnameModified.endsWith('/'), { url });\n        assert(pathnameModified !== '');\n    }\n    else {\n        pathnameModified = pathnameOriginal + (hasTrailingSlash ? '' : '/') + 'index';\n    }\n    assert(pathnameModified);\n    pathnameModified = pathnameModified + fileExtension;\n    const fileUrl = `${pathnameModified}${searchOriginal || ''}${hashOriginal || ''}`;\n    return fileUrl;\n}\n","export { getPageContextRequestUrl };\nexport { fileExtension };\nexport { doNotCreateExtraDirectory };\n// This module isn't loaded by the client-side of Server Routing => we don't inlcude `urlToFile` to `./utils.ts`\nimport { urlToFile } from '../utils/urlToFile';\nconst fileExtension = '.pageContext.json';\n// `/some-base-url/index.pageContext.json` instead of `/some-base-url.pageContext.json` in order to comply to common reverse proxy setups, see https://github.com/brillout/vite-plugin-ssr/issues/443\nconst doNotCreateExtraDirectory = false;\n// See node/renderPage/handlePageContextRequestUrl.ts\nfunction getPageContextRequestUrl(url) {\n    const pageContextRequestUrl = urlToFile(url, fileExtension, doNotCreateExtraDirectory);\n    return pageContextRequestUrl;\n}\n","export { assertObjectKeys };\nimport { assert, assertUsage, stringifyStringArray } from './utils';\nfunction assertObjectKeys(obj, keysExpected, errPrefix) {\n    assert(!errPrefix.endsWith(' '));\n    const keysUnknown = [];\n    const keys = Object.keys(obj);\n    for (const key of keys) {\n        if (!keysExpected.includes(key)) {\n            keysUnknown.push(key);\n        }\n    }\n    assertUsage(keysUnknown.length === 0, [\n        errPrefix,\n        'returned an object with following unknown keys:',\n        stringifyStringArray(keysUnknown) + '.',\n        'Only following keys are allowed:',\n        stringifyStringArray(keysExpected) + '.'\n    ].join(' '));\n}\n","export { assertOnBeforeRenderHookReturn };\nimport { assertUsage, isPlainObject } from './utils';\nimport { assertPageContextProvidedByUser } from './assertPageContextProvidedByUser';\nimport { assertObjectKeys } from './assertObjectKeys';\nfunction assertOnBeforeRenderHookReturn(hookReturnValue, hookFilePath) {\n    if (hookReturnValue === undefined || hookReturnValue === null) {\n        return;\n    }\n    const errPrefix = `The onBeforeRender() hook defined by ${hookFilePath}`;\n    assertUsage(isPlainObject(hookReturnValue), `${errPrefix} should return a plain JavaScript object or \\`undefined\\`/\\`null\\``);\n    assertObjectKeys(hookReturnValue, ['pageContext'], errPrefix);\n    if (hookReturnValue.pageContext) {\n        assertPageContextProvidedByUser(hookReturnValue['pageContext'], {\n            hook: { hookName: 'onBeforeRender', hookFilePath }\n        });\n    }\n}\n","export { getPageContext };\nexport { getPageContextErrorPage };\nexport { checkIf404 };\nimport { navigationState } from '../navigationState';\nimport { assert, assertUsage, hasProp, isPlainObject, objectAssign, getProjectError, serverSideRouteTo, callHookWithTimeout, isObject } from './utils';\nimport { parse } from '@brillout/json-serializer/parse';\nimport { getPageContextSerializedInHtml } from '../getPageContextSerializedInHtml';\nimport { analyzePageServerSide } from '../../shared/getPageFiles/analyzePageServerSide';\nimport { route } from '../../shared/route';\nimport { getErrorPageId } from '../../shared/error-page';\nimport { getHook } from '../../shared/getHook';\nimport { releasePageContext } from '../releasePageContext';\nimport { loadPageFilesClientSide } from '../loadPageFilesClientSide';\nimport { removeBuiltInOverrides } from './getPageContext/removeBuiltInOverrides';\nimport { getPageContextRequestUrl } from '../../shared/getPageContextRequestUrl';\nimport { getCodeFilePath, getPageConfig } from '../../shared/page-configs/utils';\nimport { assertOnBeforeRenderHookReturn } from '../../shared/assertOnBeforeRenderHookReturn';\nasync function getPageContext(pageContext) {\n    if (pageContext._isFirstRenderAttempt && navigationState.isFirstUrl(pageContext.urlOriginal)) {\n        assert(hasProp(pageContext, '_isFirstRenderAttempt', 'true'));\n        return getPageContextFirstRender(pageContext);\n    }\n    else {\n        assert(hasProp(pageContext, '_isFirstRenderAttempt', 'false'));\n        return getPageContextUponNavigation(pageContext);\n    }\n}\nasync function getPageContextFirstRender(pageContext) {\n    const pageContextAddendum = getPageContextSerializedInHtml();\n    removeBuiltInOverrides(pageContextAddendum);\n    objectAssign(pageContextAddendum, {\n        isHydration: true,\n        _comesDirectlyFromServer: true\n    });\n    objectAssign(pageContextAddendum, await loadPageFilesClientSide(pageContext._pageFilesAll, pageContext._pageConfigs, pageContextAddendum._pageId));\n    return pageContextAddendum;\n}\nasync function getPageContextErrorPage(pageContext) {\n    const errorPageId = getErrorPageId(pageContext._pageFilesAll, pageContext._pageConfigs);\n    if (!errorPageId) {\n        throw new Error('No error page');\n    }\n    const pageContextAddendum = {\n        isHydration: false,\n        _pageId: errorPageId,\n        _pageContextRetrievedFromServer: null,\n        _comesDirectlyFromServer: false\n    };\n    objectAssign(pageContextAddendum, await loadPageFilesClientSide(pageContext._pageFilesAll, pageContext._pageConfigs, pageContextAddendum._pageId));\n    return pageContextAddendum;\n}\nasync function getPageContextUponNavigation(pageContext) {\n    let pageContextAddendum = {};\n    objectAssign(pageContextAddendum, {\n        isHydration: false\n    });\n    objectAssign(pageContextAddendum, await getPageContextFromRoute(pageContext));\n    objectAssign(pageContextAddendum, await loadPageFilesClientSide(pageContext._pageFilesAll, pageContext._pageConfigs, pageContextAddendum._pageId));\n    const pageContextFromHook = await onBeforeRenderExecute({ ...pageContext, ...pageContextAddendum });\n    assert([true, false].includes(pageContextFromHook._comesDirectlyFromServer));\n    if (!pageContextFromHook['_isError']) {\n        objectAssign(pageContextAddendum, pageContextFromHook);\n        return pageContextAddendum;\n    }\n    else {\n        pageContextAddendum = {};\n        assert(pageContextFromHook._comesDirectlyFromServer === true);\n        assert(hasProp(pageContextFromHook, 'is404', 'boolean'));\n        assert(hasProp(pageContextFromHook, 'pageProps', 'object'));\n        assert(hasProp(pageContextFromHook.pageProps, 'is404', 'boolean'));\n        // When the user hasn't define a `_error.page.js` file: the mechanism with `serverSideError: true` is used instead\n        assert(!('serverSideError' in pageContextFromHook));\n        const errorPageId = getErrorPageId(pageContext._pageFilesAll, pageContext._pageConfigs);\n        assert(errorPageId);\n        objectAssign(pageContextAddendum, {\n            isHydration: false,\n            _pageId: errorPageId\n        });\n        objectAssign(pageContextAddendum, pageContextFromHook);\n        objectAssign(pageContextAddendum, await loadPageFilesClientSide(pageContext._pageFilesAll, pageContext._pageConfigs, pageContextAddendum._pageId));\n        return pageContextAddendum;\n    }\n}\nasync function onBeforeRenderExecute(pageContext) {\n    // `export { onBeforeRender }` defined in `.page.client.js` or `.page.js`\n    const hook = getHook(pageContext, 'onBeforeRender');\n    if (hook) {\n        const onBeforeRender = hook.hookFn;\n        const pageContextAddendum = {\n            _comesDirectlyFromServer: false,\n            _pageContextRetrievedFromServer: null\n        };\n        const pageContextReadyForRelease = releasePageContext({\n            ...pageContext,\n            ...pageContextAddendum\n        }, true);\n        const hookResult = await callHookWithTimeout(() => onBeforeRender(pageContextReadyForRelease), 'onBeforeRender', hook.hookFilePath);\n        assertOnBeforeRenderHookReturn(hookResult, hook.hookFilePath);\n        const pageContextFromHook = hookResult === null || hookResult === void 0 ? void 0 : hookResult.pageContext;\n        objectAssign(pageContextAddendum, pageContextFromHook);\n        return pageContextAddendum;\n    }\n    // `export { onBeforeRender }` defined in `.page.server.js`\n    if (await onBeforeRenderServerSideExists(pageContext)) {\n        const pageContextFromServer = await retrievePageContextFromServer(pageContext);\n        const pageContextAddendum = {};\n        Object.assign(pageContextAddendum, pageContextFromServer);\n        objectAssign(pageContextAddendum, {\n            _comesDirectlyFromServer: true,\n            _pageContextRetrievedFromServer: pageContextFromServer\n        });\n        return pageContextAddendum;\n    }\n    // No `export { onBeforeRender }` defined\n    const pageContextAddendum = { _comesDirectlyFromServer: false, _pageContextRetrievedFromServer: null };\n    return pageContextAddendum;\n}\nasync function onBeforeRenderServerSideExists(pageContext) {\n    if (pageContext._pageConfigs.length > 0) {\n        const pageConfig = getPageConfig(pageContext._pageId, pageContext._pageConfigs);\n        return (!!getCodeFilePath(pageConfig, 'onBeforeRender') &&\n            pageConfig.configElements.onBeforeRender.configEnv === 'server-only');\n    }\n    else {\n        const { hasOnBeforeRenderServerSideOnlyHook } = await analyzePageServerSide(pageContext._pageFilesAll, pageContext._pageId);\n        return hasOnBeforeRenderServerSideOnlyHook;\n    }\n}\nasync function getPageContextFromRoute(pageContext) {\n    const routeResult = await route(pageContext);\n    const pageContextFromRoute = routeResult.pageContextAddendum;\n    if (!pageContextFromRoute._pageId) {\n        const err = new Error('No routing match');\n        markIs404(err);\n        throw err;\n    }\n    assert(hasProp(pageContextFromRoute, '_pageId', 'string'));\n    return pageContextFromRoute;\n}\nfunction markIs404(err) {\n    objectAssign(err, { _is404: true });\n}\nfunction checkIf404(err) {\n    return isObject(err) && err._is404 === true;\n}\nasync function retrievePageContextFromServer(pageContext) {\n    var _a;\n    const pageContextUrl = getPageContextRequestUrl((_a = pageContext._urlPristine) !== null && _a !== void 0 ? _a : pageContext.urlOriginal);\n    const response = await fetch(pageContextUrl);\n    {\n        const contentType = response.headers.get('content-type');\n        const isRightContentType = contentType && contentType.includes('application/json');\n        // Static hosts + page doesn't exist\n        if (!isRightContentType && response.status === 404) {\n            serverSideRouteTo(pageContext.urlOriginal);\n            const err = new Error(\"Page doesn't exist\");\n            Object.assign(err, { _abortRendering: true });\n            throw err;\n        }\n        assertUsage(isRightContentType, `Wrong HTTP Response Header \\`content-type\\` value for URL ${pageContextUrl} (it should be \\`application/json\\` but we got \\`${contentType}\\`). Make sure to use \\`pageContext.httpResponse.contentType\\`, see https://github.com/brillout/vite-plugin-ssr/issues/191`);\n    }\n    const responseText = await response.text();\n    const responseObject = parse(responseText);\n    if ('serverSideError' in responseObject) {\n        throw getProjectError('`pageContext` could not be fetched from the server as an error occurred on the server; check your server logs.');\n    }\n    assert(hasProp(responseObject, 'pageContext'));\n    const pageContextFromServer = responseObject.pageContext;\n    assert(isPlainObject(pageContextFromServer));\n    assert(hasProp(pageContextFromServer, '_pageId', 'string'));\n    removeBuiltInOverrides(pageContextFromServer);\n    return pageContextFromServer;\n}\n","import { assert } from './utils';\nexport function getBaseServer() {\n    const baseServer = import.meta.env.BASE_SERVER;\n    assert(isBaseServer(baseServer));\n    return baseServer;\n}\n// We don't use isBaseServer() defined in utils/parseUrl.ts to avoid loading the whole file in the browser\nfunction isBaseServer(baseServer) {\n    return baseServer.startsWith('/');\n}\n","export { createPageContext };\nimport { addComputedUrlProps } from '../../shared/addComputedUrlProps';\nimport { getPageFilesAll } from '../../shared/getPageFiles';\nimport { getBaseServer } from '../getBaseServer';\nimport { assert, isBaseServer, objectAssign, getGlobalObject } from './utils';\nconst globalObject = getGlobalObject('createPageContext.ts', {});\nasync function createPageContext(pageContextBase) {\n    if (!globalObject.pageFilesData) {\n        globalObject.pageFilesData = await getPageFilesAll(true);\n    }\n    const { pageFilesAll, allPageIds, pageConfigs, pageConfigGlobal } = globalObject.pageFilesData;\n    const baseServer = getBaseServer();\n    assert(isBaseServer(baseServer));\n    const pageContext = {\n        _objectCreatedByVitePluginSsr: true,\n        _urlHandler: null,\n        _baseServer: baseServer,\n        _isProduction: import.meta.env.PROD,\n        // TODO: use GlobalContext instead\n        _pageFilesAll: pageFilesAll,\n        _pageConfigs: pageConfigs,\n        _pageConfigGlobal: pageConfigGlobal,\n        _allPageIds: allPageIds\n    };\n    objectAssign(pageContext, pageContextBase);\n    addComputedUrlProps(pageContext);\n    return pageContext;\n}\n","export { getPageId };\nimport { route } from '../../shared/route';\nimport { createPageContext } from './createPageContext';\nasync function getPageId(url) {\n    const pageContext = await createPageContext({\n        urlOriginal: url\n    });\n    const routeContext = await route(pageContext);\n    const pageFilesAll = pageContext._pageFilesAll;\n    const pageConfigs = pageContext._pageConfigs;\n    if (!('pageContextAddendum' in routeContext)) {\n        return { pageId: null, pageFilesAll, pageConfigs };\n    }\n    const pageId = routeContext.pageContextAddendum._pageId;\n    if (!pageId) {\n        return { pageId: null, pageFilesAll, pageConfigs };\n    }\n    return { pageId, pageFilesAll, pageConfigs };\n}\n","export { getExportNames };\nimport { assert } from '../../utils';\nfunction getExportNames(p) {\n    if (p.fileType === '.css') {\n        return [];\n    }\n    if (p.exportNames) {\n        return p.exportNames;\n    }\n    assert(p.fileExports, p.filePath);\n    const exportNames = Object.keys(p.fileExports);\n    return exportNames;\n}\n","export { analyzeExports };\nimport { getExportNames } from './getExportNames';\nimport { assertUsage } from '../../utils';\n// TODO/v1-release: remove\nfunction analyzeExports({ pageFilesClientSide, pageFilesServerSide, pageId }) {\n    return { isHtmlOnly: isHtmlOnly(), isClientRouting: isClientRouting() };\n    function isHtmlOnly() {\n        {\n            const hasPageIdIsmrphFile = pageFilesServerSide.some((p) => p.pageId === pageId && p.fileType === '.page');\n            if (hasPageIdIsmrphFile) {\n                assertClientSideRenderHook();\n                return false;\n            }\n        }\n        {\n            const hasPageIdServerFile = pageFilesServerSide.some((p) => p.pageId === pageId && p.fileType === '.page.server');\n            if (!hasPageIdServerFile) {\n                return false;\n            }\n        }\n        {\n            const definesClientRenderer = pageFilesClientSide.some((p) => p.pageId === pageId && p.fileType === '.page.client' && getExportNames(p).includes('render'));\n            if (definesClientRenderer) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function assertClientSideRenderHook() {\n        const hasClientSideRenderHook = pageFilesClientSide.some((p) => {\n            return getExportNames(p).includes('render');\n        });\n        assertUsage(hasClientSideRenderHook, [\n            'No client-side `render()` hook found.',\n            'See https://vite-plugin-ssr.com/render-modes for more information.',\n            [\n                'Loaded client-side page files (none of them `export { render }`):',\n                ...pageFilesClientSide.map((p, i) => ` (${i + 1}): ${p.filePath}`)\n            ].join('\\n')\n        ].join(' '));\n    }\n    function isClientRouting() {\n        const hasClientRoutingExport = pageFilesClientSide.some((p) => {\n            return getExportNames(p).includes('clientRouting');\n        });\n        return hasClientRoutingExport;\n    }\n}\n","export { determineClientEntry };\nexport { getVPSClientEntry };\nfunction determineClientEntry({ pageFilesClientSide, pageFilesServerSide, isHtmlOnly, isClientRouting }) {\n    let clientEntries = [];\n    const pageFilesServerSideOnly = pageFilesServerSide.filter((p) => !pageFilesClientSide.includes(p));\n    const clientDependencies = [];\n    clientDependencies.push(...pageFilesClientSide.map((p) => ({ id: p.filePath, onlyAssets: false, eagerlyImported: false })));\n    // CSS & assets\n    clientDependencies.push(...pageFilesServerSideOnly.map((p) => ({ id: p.filePath, onlyAssets: true, eagerlyImported: false })));\n    // Handle SPA & SSR pages.\n    if (isHtmlOnly) {\n        clientEntries = pageFilesClientSide.map((p) => p.filePath);\n    }\n    else {\n        // Add the vps client entry\n        const clientEntry = getVPSClientEntry(isClientRouting);\n        clientDependencies.push({ id: clientEntry, onlyAssets: false, eagerlyImported: false });\n        clientEntries = [clientEntry];\n    }\n    // console.log(pageFilesClientSide, pageFilesServerSide, clientDependencies, clientEntry)\n    return { clientEntries, clientDependencies };\n}\nfunction getVPSClientEntry(isClientRouting) {\n    return isClientRouting\n        ? // dist/client/entries/entry-client-routing.js\n            '@@vite-plugin-ssr/dist/esm/client/router/entry.js'\n        : // dist/client/entries/entry-server-routing.js\n            '@@vite-plugin-ssr/dist/esm/client/entry.js';\n}\n","export { analyzePageClientSide };\nexport { analyzePageClientSideInit };\nimport { analyzeExports } from './analyzePageClientSide/analyzeExports';\nimport { determineClientEntry } from './analyzePageClientSide/determineClientEntry';\nimport { getPageFilesClientSide } from './getAllPageIdFiles';\nimport { getPageFilesServerSide } from './getAllPageIdFiles';\nimport { assert } from '../utils';\nimport { getExportNames } from './analyzePageClientSide/getExportNames';\n// TODO/v1-release: remove analyzePageClientSide(), use analyzeClientSide() instead\nfunction analyzePageClientSide(pageFilesAll, pageId) {\n    let pageFilesClientSide = getPageFilesClientSide(pageFilesAll, pageId);\n    const pageFilesServerSide = getPageFilesServerSide(pageFilesAll, pageId);\n    const { isHtmlOnly, isClientRouting } = analyzeExports({ pageFilesClientSide, pageFilesServerSide, pageId });\n    if (isHtmlOnly) {\n        // HTML-only pages don't need any client-side `render()` hook. For apps that have both HTML-only and SSR/SPA pages, we skip the `.page.client.js` file that defines `render()` for HTML-only pages.\n        pageFilesClientSide = pageFilesClientSide.filter((p) => p.isEnv('CLIENT_ONLY') && !getExportNames(p).includes('render'));\n        pageFilesClientSide = removeOverridenPageFiles(pageFilesClientSide);\n    }\n    const { clientEntries, clientDependencies } = determineClientEntry({\n        pageFilesClientSide,\n        pageFilesServerSide,\n        isHtmlOnly,\n        isClientRouting\n    });\n    return { isHtmlOnly, isClientRouting, clientEntries, clientDependencies, pageFilesClientSide, pageFilesServerSide };\n}\nasync function analyzePageClientSideInit(pageFilesAll, pageId, { sharedPageFilesAlreadyLoaded }) {\n    const pageFilesClientSide = getPageFilesClientSide(pageFilesAll, pageId);\n    await Promise.all(pageFilesClientSide.map(async (p) => {\n        var _a;\n        assert(p.isEnv('CLIENT_ONLY') || p.isEnv('CLIENT_AND_SERVER'));\n        if (sharedPageFilesAlreadyLoaded && p.isEnv('CLIENT_AND_SERVER')) {\n            return;\n        }\n        // TODO: Is `loadExportNames()` cached ? Does it use filesExports if possible? HMR?\n        await ((_a = p.loadExportNames) === null || _a === void 0 ? void 0 : _a.call(p));\n        /*\n        if (pageFile.exportNames) {\n          return pageFile.exportNames.includes(clientRouting)\n        }\n        if (pageFile.fileExports) {\n          return Object.keys(pageFile.fileExports).includes(clientRouting)\n        }\n        */\n    }));\n}\n// [WIP] Just an experiment needed by https://vite-plugin-ssr.com/banner\n//  - Not sure I want to make something like a public API: the CSS of `_default.page.server.js` are still loaded -> weird DX.\nfunction removeOverridenPageFiles(pageFilesClientSide) {\n    const pageFilesClientSide_ = [];\n    for (const p of pageFilesClientSide) {\n        pageFilesClientSide_.push(p);\n        if (getExportNames(p).includes('overrideDefaultPages')) {\n            break;\n        }\n    }\n    return pageFilesClientSide_;\n}\n","export { analyzeClientSide };\nimport { getCodeFilePath, getConfigValue } from '../page-configs/utils';\nimport { analyzePageClientSide } from './analyzePageClientSide';\nfunction analyzeClientSide(pageConfig, pageFilesAll, pageId) {\n    var _a;\n    if (pageConfig) {\n        const isClientRouting = (_a = getConfigValue(pageConfig, 'clientRouting', 'boolean')) !== null && _a !== void 0 ? _a : false;\n        const onRenderClientExists = !!getCodeFilePath(pageConfig, 'onRenderClient');\n        const PageExists = !!getCodeFilePath(pageConfig, 'Page') && pageConfig.configElements.Page.configEnv !== 'server-only';\n        const isClientSideRenderable = onRenderClientExists && PageExists;\n        return { isClientSideRenderable, isClientRouting };\n    }\n    else {\n        // TOOD: globally rename isHtmlOnly to !isClientSideRenderable\n        const { isHtmlOnly, isClientRouting } = analyzePageClientSide(pageFilesAll, pageId);\n        return { isClientSideRenderable: !isHtmlOnly, isClientRouting };\n    }\n}\n","export { isClientSideRoutable };\nimport { getPageId } from '../getPageId';\nimport { analyzePageClientSideInit } from '../../../shared/getPageFiles/analyzePageClientSide';\nimport { findPageConfig } from '../../../shared/page-configs/findPageConfig';\nimport { analyzeClientSide } from '../../../shared/getPageFiles/analyzeClientSide';\nasync function isClientSideRoutable(url) {\n    const { pageId, pageFilesAll, pageConfigs } = await getPageId(url);\n    if (!pageId) {\n        return false;\n    }\n    await analyzePageClientSideInit(pageFilesAll, pageId, { sharedPageFilesAlreadyLoaded: false });\n    const pageConfig = findPageConfig(pageConfigs, pageId);\n    const { isClientSideRenderable, isClientRouting } = analyzeClientSide(pageConfig, pageFilesAll, pageId);\n    return isClientSideRenderable && isClientRouting;\n}\n","export { skipLink };\nexport { isClientSideRoutable } from './skipLink/isClientSideRoutable';\nimport { getBaseServer } from '../getBaseServer';\nimport { assert, parseUrl, isBaseServer, isParsable, isExternalLink } from './utils';\nfunction skipLink(linkTag) {\n    const url = linkTag.getAttribute('href');\n    if (url === null)\n        return true;\n    if (url === '')\n        return true;\n    if (isExternalLink(url))\n        return true;\n    if (isNewTabLink(linkTag))\n        return true;\n    if (isHashUrl(url))\n        return true;\n    if (!hasBaseServer(url)) {\n        return true;\n    }\n    if (!isParsable(url)) {\n        return true;\n    }\n    return false;\n}\nfunction isNewTabLink(linkTag) {\n    const target = linkTag.getAttribute('target');\n    const rel = linkTag.getAttribute('rel');\n    return target === '_blank' || target === '_external' || rel === 'external' || linkTag.hasAttribute('download');\n}\nfunction isHashUrl(url) {\n    if (url.startsWith('#')) {\n        return true;\n    }\n    const removeHash = (url) => url.split('#')[0];\n    if (url.includes('#') && removeHash(url) === removeHash(window.location.href)) {\n        return true;\n    }\n    return false;\n}\nfunction hasBaseServer(url) {\n    const baseServer = getBaseServer();\n    assert(isBaseServer(baseServer));\n    const { hasBaseServer } = parseUrl(url, baseServer);\n    return hasBaseServer;\n}\n","export { getPrefetchSettings };\nimport { assert, assertUsage, assertInfo, assertWarning, isPlainObject } from '../utils';\nfunction getPrefetchSettings(pageContext, linkTag) {\n    let prefetchStaticAssets = getPrefetchStaticAssets(pageContext, linkTag);\n    if (prefetchStaticAssets === 'viewport' && !pageContext._isProduction) {\n        assertInfo(false, 'Viewport prefetching is disabled in development', { onlyOnce: true });\n        prefetchStaticAssets = 'hover';\n    }\n    return {\n        prefetchStaticAssets\n    };\n}\nfunction getPrefetchStaticAssets(pageContext, linkTag) {\n    {\n        const prefetchAttribute = getPrefetchAttribute(linkTag);\n        if (prefetchAttribute !== null)\n            return prefetchAttribute;\n    }\n    if ('prefetchLinks' in pageContext.exports) {\n        assertUsage(false, '`export { prefetchLinks }` is deprecated, use `export { prefetchStaticAssets }` instead.');\n    }\n    if ('prefetchStaticAssets' in pageContext.exports) {\n        const { prefetchStaticAssets } = pageContext.exports;\n        if (prefetchStaticAssets === false) {\n            return false;\n        }\n        if (prefetchStaticAssets === 'hover') {\n            return 'hover';\n        }\n        if (prefetchStaticAssets === 'viewport') {\n            return 'viewport';\n        }\n        const wrongUsageMsg = \"prefetchStaticAssets value should be false, 'hover', or 'viewport'\";\n        // TODO/v1-release: remove\n        assertUsage(isPlainObject(prefetchStaticAssets), wrongUsageMsg);\n        const keys = Object.keys(prefetchStaticAssets);\n        assertUsage(keys.length === 1 && keys[0] === 'when', wrongUsageMsg);\n        const { when } = prefetchStaticAssets;\n        if (when === 'HOVER' || when === 'VIEWPORT') {\n            const correctValue = when.toLowerCase();\n            assertWarning(false, `prefetchStaticAssets value \\`{ when: '${when}' }\\` is outdated: set prefetchStaticAssets to '${correctValue}' instead`, { onlyOnce: true, showStackTrace: false });\n            return correctValue;\n        }\n        assertUsage(false, wrongUsageMsg);\n    }\n    return 'hover';\n}\nfunction getPrefetchAttribute(linkTag) {\n    const attr = linkTag.getAttribute('data-prefetch-static-assets');\n    const attrOld = linkTag.getAttribute('data-prefetch');\n    if (attr === null && attrOld === null) {\n        return null;\n    }\n    const deprecationNotice = 'The attribute data-prefetch is outdated, use data-prefetch-static-assets instead.';\n    if (attr) {\n        assertUsage(attrOld === null, deprecationNotice);\n        if (attr === 'hover' || attr === 'viewport') {\n            return attr;\n        }\n        if (attr === 'false') {\n            return false;\n        }\n        assertUsage(false, `data-prefetch-static-assets has value \"${attr}\" but it should instead be \"false\", \"hover\", or \"viewport\"`);\n    }\n    // TODO/v1-release: remove\n    if (attrOld) {\n        assert(!attr);\n        assertWarning(false, deprecationNotice, {\n            showStackTrace: false,\n            onlyOnce: true\n        });\n        if (attrOld === 'true') {\n            return 'viewport';\n        }\n        if (attrOld === 'false') {\n            return 'hover';\n        }\n        assertUsage(false, `data-prefetch has value \"${attrOld}\" but it should instead be \"true\" or \"false\"`);\n    }\n    assert(false);\n}\n","export { isAlreadyPrefetched };\nexport { markAsAlreadyPrefetched };\nimport { getUrlPathname } from '../utils';\nconst linkAlreadyPrefetched = new Map();\nfunction isAlreadyPrefetched(url) {\n    const prefetchUrl = getPrefetchUrl(url);\n    return linkAlreadyPrefetched.has(prefetchUrl);\n}\nfunction markAsAlreadyPrefetched(url) {\n    const prefetchUrl = getPrefetchUrl(url);\n    linkAlreadyPrefetched.set(prefetchUrl, true);\n}\nfunction getPrefetchUrl(url) {\n    return getUrlPathname(url);\n}\n","export { addLinkPrefetchHandlers, prefetch };\nimport { assert, assertClientRouting, assertUsage, checkIfClientRouting, isExternalLink } from './utils';\nimport { isErrorFetchingStaticAssets, loadPageFilesClientSide } from '../loadPageFilesClientSide';\nimport { isClientSideRoutable, skipLink } from './skipLink';\nimport { getPageId } from './getPageId';\nimport { getPrefetchSettings } from './prefetch/getPrefetchSettings';\nimport { isAlreadyPrefetched, markAsAlreadyPrefetched } from './prefetch/alreadyPrefetched';\nimport { disableClientRouting } from './useClientRouter';\nassertClientRouting();\nconst linkPrefetchHandlerAdded = new Map();\nasync function prefetch(url) {\n    assertUsage(checkIfClientRouting(), 'prefetch() only works with Client Routing, see https://vite-plugin-ssr.com/prefetch');\n    assertUsage(!isExternalLink(url), `You are trying to prefetch the URL ${url} of another domain which cannot be prefetched`);\n    if (isAlreadyPrefetched(url))\n        return;\n    markAsAlreadyPrefetched(url);\n    const { pageId, pageFilesAll, pageConfigs } = await getPageId(url);\n    if (pageId) {\n        try {\n            await loadPageFilesClientSide(pageFilesAll, pageConfigs, pageId);\n        }\n        catch (err) {\n            if (isErrorFetchingStaticAssets(err)) {\n                disableClientRouting(err, true);\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n}\nfunction addLinkPrefetchHandlers(pageContext) {\n    // Current URL is already prefetched\n    markAsAlreadyPrefetched(pageContext.urlOriginal);\n    const linkTags = [...document.getElementsByTagName('A')];\n    linkTags.forEach(async (linkTag) => {\n        if (linkPrefetchHandlerAdded.has(linkTag))\n            return;\n        linkPrefetchHandlerAdded.set(linkTag, true);\n        const url = linkTag.getAttribute('href');\n        if (skipLink(linkTag))\n            return;\n        assert(url);\n        try {\n            if (!(await isClientSideRoutable(url)))\n                return;\n        }\n        catch {\n            // If a route() hook has a bug or `throw RenderErrorPage()`\n            return;\n        }\n        if (isAlreadyPrefetched(url))\n            return;\n        const { prefetchStaticAssets } = getPrefetchSettings(pageContext, linkTag);\n        if (!prefetchStaticAssets) {\n            return;\n        }\n        else if (prefetchStaticAssets === 'hover') {\n            linkTag.addEventListener('mouseover', () => prefetch(url));\n            linkTag.addEventListener('touchstart', () => prefetch(url), { passive: true });\n        }\n        else if (prefetchStaticAssets === 'viewport') {\n            const observer = new IntersectionObserver((entries) => {\n                entries.forEach((entry) => {\n                    if (entry.isIntersecting) {\n                        prefetch(url);\n                        observer.disconnect();\n                    }\n                });\n            });\n            observer.observe(linkTag);\n        }\n    });\n}\n","export { initHistoryState, getHistoryState, pushHistory, saveScrollPosition };\nimport { assert, hasProp, isObject } from './utils';\n// Fill missing state information.\n//  - The very first render => `history.state` is uninitialized (`null`).\n//  - The vite-plugin-ssr app runs `location.hash = '#section'` => `history.state` is uninitialized (`null`).\n//  - The user clicks on an anchor link `<a href=\"#section\">Section</a>` => `history.state` is uninitialized (`null`).\n//  - `history.state` set by an old vite-plugin-ssr version => state information may be incomplete. (E.g. `state.timestamp` was introduced for `pageContext.isBackwardNavigation` in `0.4.19`.)\nfunction initHistoryState() {\n    let state = window.history.state;\n    if (!state) {\n        state = {};\n    }\n    let hasModifications = false;\n    if (!('timestamp' in state)) {\n        hasModifications = true;\n        state.timestamp = getTimestamp();\n    }\n    if (!('scrollPosition' in state)) {\n        hasModifications = true;\n        state.scrollPosition = getScrollPosition();\n    }\n    assertState(state);\n    if (hasModifications) {\n        replaceHistoryState(state);\n    }\n}\nfunction getHistoryState() {\n    const state = window.history.state || {};\n    assertState(state);\n    return state;\n}\nfunction getScrollPosition() {\n    const scrollPosition = { x: window.scrollX, y: window.scrollY };\n    return scrollPosition;\n}\nfunction getTimestamp() {\n    return new Date().getTime();\n}\nfunction saveScrollPosition() {\n    const scrollPosition = getScrollPosition();\n    const state = getHistoryState();\n    replaceHistoryState({ ...state, scrollPosition });\n}\nfunction pushHistory(url, overwriteLastHistoryEntry) {\n    if (!overwriteLastHistoryEntry) {\n        const timestamp = getTimestamp();\n        pushHistoryState({ timestamp, scrollPosition: null }, url);\n    }\n    else {\n        replaceHistoryState(getHistoryState(), url);\n    }\n}\nfunction assertState(state) {\n    assert(isObject(state));\n    if ('timestamp' in state) {\n        const { timestamp } = state;\n        assert(typeof timestamp === 'number');\n    }\n    if ('scrollPosition' in state) {\n        const { scrollPosition } = state;\n        if (scrollPosition !== null) {\n            assert(hasProp(scrollPosition, 'x', 'number') && hasProp(scrollPosition, 'y', 'number'));\n        }\n    }\n}\nfunction replaceHistoryState(state, url) {\n    window.history.replaceState(state, '', url !== null && url !== void 0 ? url : null);\n}\nfunction pushHistoryState(state, url) {\n    window.history.pushState(state, '', url);\n}\n","export { navigate };\nexport { defineNavigate };\nimport { assertUsage, isBrowser, getGlobalObject, assertClientRouting, checkIfClientRouting } from './utils';\nassertClientRouting();\nconst globalObject = getGlobalObject('navigate.ts', {});\n/** Programmatically navigate to a new page, see https://vite-plugin-ssr.com/navigate\n * @param url - The URL of the new page.\n * @param keepScrollPosition - Don't scroll to the top of the page, instead keep the current scroll position.\n * @param overwriteLastHistoryEntry - Don't create a new entry in the browser's history, instead let the new URL replace the current URL. (This effectively removes the current URL from the browser history).\n */\nasync function navigate(url, { keepScrollPosition = false, overwriteLastHistoryEntry = false } = {}) {\n    assertUsage(isBrowser(), '[`navigate(url)`] The `navigate(url)` function is only callable in the browser but you are calling it in Node.js.');\n    const errMsg = 'navigate() only works with Client Routing, see https://vite-plugin-ssr.com/navigate';\n    assertUsage(globalObject.navigate, errMsg);\n    assertUsage(checkIfClientRouting(), errMsg);\n    assertUsage(url, '[navigate(url)] Missing argument `url`.');\n    assertUsage(typeof url === 'string', '[navigate(url)] Argument `url` should be a string (but we got `typeof url === \"' + typeof url + '\"`.');\n    assertUsage(typeof keepScrollPosition === 'boolean', '[navigate(url, { keepScrollPosition })] Argument `keepScrollPosition` should be a boolean (but we got `typeof keepScrollPosition === \"' +\n        typeof keepScrollPosition +\n        '\"`.');\n    assertUsage(typeof overwriteLastHistoryEntry === 'boolean', '[navigate(url, { overwriteLastHistoryEntry })] Argument `overwriteLastHistoryEntry` should be a boolean (but we got `typeof keepScrollPosition === \"' +\n        typeof overwriteLastHistoryEntry +\n        '\"`.');\n    assertUsage(url.startsWith('/'), '[navigate(url)] Argument `url` should start with a leading `/`.');\n    await globalObject.navigate(url, { keepScrollPosition, overwriteLastHistoryEntry });\n}\nfunction defineNavigate(navigate_) {\n    globalObject.navigate = navigate_;\n}\n","export { isRenderErrorPageException };\nexport { RenderErrorPage };\nexport { assertRenderErrorPageExceptionUsage };\nimport { assertPageContextProvidedByUser } from '../assertPageContextProvidedByUser';\nimport { assertUsage, objectAssign } from './utils';\nconst stamp = '__isRenderErrorPageException';\nfunction isRenderErrorPageException(thing) {\n    assertRenderErrorPageExceptionUsage(thing);\n    return typeof thing === 'object' && thing !== null && stamp in thing;\n}\nfunction RenderErrorPage({ pageContext } = {}) {\n    {\n        // @ts-ignore\n        const that = this;\n        assertUsage(!(typeof that === 'object' && (that === null || that === void 0 ? void 0 : that.constructor) === RenderErrorPage), \"Don't use the `new` operator: use `throw RenderErrorPage()` instead of `throw new RenderErrorPage()`.\");\n    }\n    assertPageContextProvidedByUser(pageContext, {\n        errorMessagePrefix: 'The `pageContext` object provided by `throw RenderErrorPage({ pageContext })`',\n        isRenderErrorPage: true\n    });\n    const err = new Error('RenderErrorPage');\n    objectAssign(err, { pageContext, [stamp]: true });\n    return err;\n}\nfunction assertRenderErrorPageExceptionUsage(err) {\n    assertUsage(err !== RenderErrorPage, 'Missing parentheses `()` in `throw RenderErrorPage`: it should be `throw RenderErrorPage()`.');\n}\n","export { useClientRouter };\nexport { disableClientRouting };\nimport { assert, getCurrentUrl, isSameErrorMessage, objectAssign, serverSideRouteTo, throttle, sleep, getGlobalObject, callHookWithTimeout, isObject } from './utils';\nimport { navigationState } from '../navigationState';\nimport { checkIf404, getPageContext, getPageContextErrorPage } from './getPageContext';\nimport { createPageContext } from './createPageContext';\nimport { addLinkPrefetchHandlers } from './prefetch';\nimport { assertInfo, assertWarning, isReact } from './utils';\nimport { executeOnRenderClientHook } from '../executeOnRenderClientHook';\nimport { assertHook } from '../../shared/getHook';\nimport { isClientSideRoutable, skipLink } from './skipLink';\nimport { isErrorFetchingStaticAssets } from '../loadPageFilesClientSide';\nimport { initHistoryState, getHistoryState, pushHistory, saveScrollPosition } from './history';\nimport { defineNavigate } from './navigate';\nimport { isRenderErrorPageException } from '../../shared/route/RenderErrorPage';\nconst globalObject = getGlobalObject('useClientRouter.ts', { previousState: getState() });\nsetupNativeScrollRestoration();\ninitHistoryState();\nfunction disableClientRouting(err, logError) {\n    assert(isErrorFetchingStaticAssets(err));\n    globalObject.clientRoutingIsDisabled = true;\n    if (logError) {\n        // We don't use console.error() to avoid flooding error trackers such as Sentry\n        console.log(err);\n    }\n    assertInfo(false, [\n        'Failed to fetch static asset.',\n        import.meta.env.PROD ? 'This usually happens when a new frontend is deployed.' : null,\n        'Falling back to Server Routing.',\n        '(The next page navigation will use Server Routing instead of Client Routing.)'\n    ]\n        .filter(Boolean)\n        .join(' '), { onlyOnce: true });\n}\nfunction useClientRouter() {\n    autoSaveScrollPosition();\n    onLinkClick((url, { keepScrollPosition }) => {\n        const scrollTarget = keepScrollPosition ? 'preserve-scroll' : 'scroll-to-top-or-hash';\n        fetchAndRender({ scrollTarget, url, isBackwardNavigation: false, checkClientSideRenderable: true });\n    });\n    onBrowserHistoryNavigation((scrollTarget, isBackwardNavigation) => {\n        fetchAndRender({ scrollTarget, isBackwardNavigation });\n    });\n    defineNavigate(async (url, { keepScrollPosition = false, overwriteLastHistoryEntry = false } = {}) => {\n        const scrollTarget = keepScrollPosition ? 'preserve-scroll' : 'scroll-to-top-or-hash';\n        await fetchAndRender({\n            scrollTarget,\n            url,\n            overwriteLastHistoryEntry,\n            isBackwardNavigation: false,\n            checkClientSideRenderable: true\n        });\n    });\n    let renderingCounter = 0;\n    let renderPromise;\n    let isTransitioning = false;\n    fetchAndRender({ scrollTarget: 'preserve-scroll', isBackwardNavigation: null });\n    return;\n    async function fetchAndRender({ scrollTarget, url = getCurrentUrl(), overwriteLastHistoryEntry = false, isBackwardNavigation, checkClientSideRenderable }) {\n        var _a;\n        if (globalObject.clientRoutingIsDisabled) {\n            serverSideRouteTo(url);\n            return;\n        }\n        if (checkClientSideRenderable) {\n            let isClientRoutable;\n            try {\n                isClientRoutable = await isClientSideRoutable(url);\n            }\n            catch (err) {\n                if (!isRenderErrorPageException(err)) {\n                    // If a route() hook has a bug\n                    throw err;\n                }\n                else {\n                    // If a route() hook `throw RenderErrorPage()`\n                    // RenderErrorPage is handled down below\n                    isClientRoutable = true;\n                }\n            }\n            if (!isClientRoutable) {\n                serverSideRouteTo(url);\n                return;\n            }\n        }\n        const pageContextBase = {\n            urlOriginal: url,\n            isBackwardNavigation\n        };\n        const renderingNumber = ++renderingCounter;\n        assert(renderingNumber >= 1);\n        // Start transition before any await's\n        if (renderingNumber > 1) {\n            if (isTransitioning === false) {\n                (_a = globalObject.onPageTransitionStart) === null || _a === void 0 ? void 0 : _a.call(globalObject, pageContextBase);\n                isTransitioning = true;\n            }\n        }\n        let hydrationCanBeAborted = false;\n        const shouldAbort = () => {\n            {\n                // We should never abort the hydration if `hydrationCanBeAborted` isn't `true`\n                const isHydration = renderingNumber === 1;\n                if (isHydration && hydrationCanBeAborted === false) {\n                    return false;\n                }\n            }\n            // If there is a newer rendering, we should abort all previous renderings\n            if (renderingNumber !== renderingCounter) {\n                return true;\n            }\n            return false;\n        };\n        const pageContext = await createPageContext(pageContextBase);\n        if (shouldAbort()) {\n            return;\n        }\n        const isFirstRenderAttempt = renderingNumber === 1;\n        objectAssign(pageContext, {\n            _isFirstRenderAttempt: isFirstRenderAttempt\n        });\n        let pageContextAddendum;\n        try {\n            pageContextAddendum = await getPageContext(pageContext);\n        }\n        catch (err) {\n            // We never swallow errors on the client-side, even if it's a 404, because:\n            //  - On the client-side, if the user navigates to a 404 then it means that the UI has a broken link.\n            //    - It isn't expected that users can go to some random URL using the client-side router, as it would require, for example, the user to manually change the URL of a link by manually manipulating the DOM which highly unlikely.\n            //    - In contrast, on the server-side, VPS swallows / doesn't show any 404 error log because it's expected that a user may go to some random non-existent URL, and we don't want to flood the app's error tracking with 404 logs.\n            console.error(err);\n            if (checkIfAbort(err, pageContext))\n                return;\n            if (isRenderErrorPageException(err)) {\n                objectAssign(pageContext, { is404: true });\n                objectAssign(pageContext, err.pageContext);\n            }\n            else {\n                objectAssign(pageContext, { is404: checkIf404(err) });\n            }\n            try {\n                pageContextAddendum = await getPageContextErrorPage(pageContext);\n            }\n            catch (err2) {\n                // - When user hasn't defined a `_error.page.js` file\n                // - Some unpexected vite-plugin-ssr internal error\n                if (checkIfAbort(err2, pageContext))\n                    return;\n                if (!isFirstRenderAttempt) {\n                    setTimeout(() => {\n                        // We let the server show the 404 page\n                        window.location.pathname = url;\n                    }, 0);\n                }\n                if (!isSameErrorMessage(err, err2)) {\n                    throw err2;\n                }\n                else {\n                    // Abort\n                    return;\n                }\n            }\n        }\n        objectAssign(pageContext, pageContextAddendum);\n        assertHook(pageContext, 'onPageTransitionStart');\n        globalObject.onPageTransitionStart = pageContext.exports.onPageTransitionStart;\n        if (pageContext.exports.hydrationCanBeAborted) {\n            hydrationCanBeAborted = true;\n        }\n        else {\n            assertWarning(!isReact(), 'You seem to be using React; we recommend setting `hydrationCanBeAborted` to `true`, see https://vite-plugin-ssr.com/clientRouting', { showStackTrace: false, onlyOnce: true });\n        }\n        if (shouldAbort()) {\n            return;\n        }\n        if (renderPromise) {\n            // Always make sure that the previous render has finished,\n            // otherwise that previous render may finish after this one.\n            await renderPromise;\n        }\n        if (shouldAbort()) {\n            return;\n        }\n        changeUrl(url, overwriteLastHistoryEntry);\n        navigationState.markNavigationChange();\n        assert(renderPromise === undefined);\n        renderPromise = (async () => {\n            await executeOnRenderClientHook(pageContext, true);\n            addLinkPrefetchHandlers(pageContext);\n        })();\n        await renderPromise;\n        renderPromise = undefined;\n        if (pageContext._isFirstRenderAttempt) {\n            assertHook(pageContext, 'onHydrationEnd');\n            const { onHydrationEnd } = pageContext.exports;\n            if (onHydrationEnd) {\n                const hookFilePath = pageContext.exportsAll.onHydrationEnd[0].exportSource;\n                assert(hookFilePath);\n                await callHookWithTimeout(() => onHydrationEnd(pageContext), 'onHydrationEnd', hookFilePath);\n            }\n        }\n        else if (renderingNumber === renderingCounter) {\n            if (pageContext.exports.onPageTransitionEnd) {\n                assertHook(pageContext, 'onPageTransitionEnd');\n                pageContext.exports.onPageTransitionEnd(pageContext);\n            }\n            isTransitioning = false;\n        }\n        setScrollPosition(scrollTarget);\n        browserNativeScrollRestoration_disable();\n        globalObject.initialRenderIsDone = true;\n    }\n}\nfunction onLinkClick(callback) {\n    document.addEventListener('click', onClick);\n    return;\n    // Code adapted from https://github.com/HenrikJoreteg/internal-nav-helper/blob/5199ec5448d0b0db7ec63cf76d88fa6cad878b7d/src/index.js#L11-L29\n    async function onClick(ev) {\n        if (!isNormalLeftClick(ev))\n            return;\n        const linkTag = findLinkTag(ev.target);\n        if (!linkTag)\n            return;\n        const url = linkTag.getAttribute('href');\n        if (skipLink(linkTag))\n            return;\n        assert(url);\n        ev.preventDefault();\n        const keepScrollPosition = ![null, 'false'].includes(linkTag.getAttribute('keep-scroll-position'));\n        callback(url, { keepScrollPosition });\n    }\n    function isNormalLeftClick(ev) {\n        return ev.button === 0 && !ev.ctrlKey && !ev.shiftKey && !ev.altKey && !ev.metaKey;\n    }\n    function findLinkTag(target) {\n        while (target.tagName !== 'A') {\n            const { parentNode } = target;\n            if (!parentNode) {\n                return null;\n            }\n            target = parentNode;\n        }\n        return target;\n    }\n}\nfunction onBrowserHistoryNavigation(callback) {\n    // The `event` of `window.addEventListener('popstate', (event) => /*...*/)` is useless:\n    //  - The History API doesn't provide the previous state (the popped state): https://stackoverflow.com/questions/48055323/is-history-state-always-the-same-as-popstate-event-state\n    window.addEventListener('popstate', () => {\n        const currentState = getState();\n        const scrollTarget = currentState.historyState.scrollPosition || 'scroll-to-top-or-hash';\n        const isHashNavigation = currentState.urlWithoutHash === globalObject.previousState.urlWithoutHash;\n        const isBackwardNavigation = !currentState.historyState.timestamp || !globalObject.previousState.historyState.timestamp\n            ? null\n            : currentState.historyState.timestamp < globalObject.previousState.historyState.timestamp;\n        globalObject.previousState = currentState;\n        if (isHashNavigation) {\n            // - `history.state` is uninitialized (`null`) when:\n            //   - The vite-plugin-ssr app runs `window.location.hash = '#section'`.\n            //   - The user clicks on an anchor link `<a href=\"#section\">Section</a>`. (Because vite-plugin-ssr's `onLinkClick()` handler skips hash links.)\n            // - `history.state` is `null` when uninitialized: https://developer.mozilla.org/en-US/docs/Web/API/History/state\n            // - Alternatively, we completely take over hash navigation and reproduce the browser's native behavior upon hash navigation.\n            //   - Problem: we cannot intercept `window.location.hash = '#section'`. (Or maybe we can with the `hashchange` event?)\n            //   - Other potential problem: would there be a conflict when the user wants to override the browser's default behavior? E.g. for smooth scrolling, or when using hashes for saving states of some fancy animations.\n            // - Another alternative: we use the browser's scroll restoration mechanism (see `browserNativeScrollRestoration_enable()` below).\n            //   - Problem: not clear when to call `browserNativeScrollRestoration_disable()`/`browserNativeScrollRestoration_enable()`\n            //   - Other potential problem are inconsistencies between browsers: specification says that setting `window.history.scrollRestoration` only affects the current entry in the session history. But this seems to contradict what folks saying.\n            //     - Specification: https://html.spec.whatwg.org/multipage/history.html#the-history-interface\n            //     - https://stackoverflow.com/questions/70188241/history-scrollrestoration-manual-doesnt-prevent-safari-from-restoring-scrol\n            if (window.history.state === null) {\n                // The browser already scrolled to `#${hash}` => the current scroll position is the right one => we save it with `initHistoryState()`.\n                initHistoryState();\n                globalObject.previousState = getState();\n            }\n            else {\n                // If `history.state !== null` then it means that `popstate` was triggered by the user clicking on his browser's forward/backward history button.\n                setScrollPosition(scrollTarget);\n            }\n        }\n        else {\n            // Fetch & render new page\n            callback(scrollTarget, isBackwardNavigation);\n        }\n    });\n}\nfunction changeUrl(url, overwriteLastHistoryEntry) {\n    if (getCurrentUrl() === url)\n        return;\n    browserNativeScrollRestoration_disable();\n    pushHistory(url, overwriteLastHistoryEntry);\n    globalObject.previousState = getState();\n}\nfunction getState() {\n    return {\n        urlWithoutHash: getCurrentUrl({ withoutHash: true }),\n        historyState: getHistoryState()\n    };\n}\nfunction setScrollPosition(scrollTarget) {\n    if (scrollTarget === 'preserve-scroll') {\n        return;\n    }\n    let scrollPosition;\n    if (scrollTarget === 'scroll-to-top-or-hash') {\n        const hash = getUrlHash();\n        // We replicate the browser's native behavior\n        if (hash && hash !== 'top') {\n            const hashTarget = document.getElementById(hash) || document.getElementsByName(hash)[0];\n            if (hashTarget) {\n                hashTarget.scrollIntoView();\n                return;\n            }\n        }\n        scrollPosition = { x: 0, y: 0 };\n    }\n    else {\n        assert('x' in scrollTarget && 'y' in scrollTarget);\n        scrollPosition = scrollTarget;\n    }\n    setScroll(scrollPosition);\n}\n/** Change the browser's scoll position, in a way that works during a repaint. */\nfunction setScroll(scrollPosition) {\n    const scroll = () => window.scrollTo(scrollPosition.x, scrollPosition.y);\n    const done = () => window.scrollX === scrollPosition.x && window.scrollY === scrollPosition.y;\n    // In principle, this `done()` call should force the repaint to be finished. But that doesn't seem to be the case with `Firefox 97.0.1`.\n    if (done())\n        return;\n    scroll();\n    // Because `done()` doesn't seem to always force the repaint to be finished, we potentially need to retry again.\n    if (done())\n        return;\n    requestAnimationFrame(() => {\n        scroll();\n        if (done())\n            return;\n        setTimeout(async () => {\n            scroll();\n            if (done())\n                return;\n            // In principle, `requestAnimationFrame() -> setTimeout(, 0)` should be enough.\n            //  - https://stackoverflow.com/questions/61281139/waiting-for-repaint-in-javascript\n            //  - But it's not enough for `Firefox 97.0.1`.\n            //  - The following strategy is very agressive. It doesn't need to be that aggressive for Firefox. But we do it to be safe.\n            const start = new Date().getTime();\n            while (true) {\n                await sleep(10);\n                scroll();\n                if (done())\n                    return;\n                const millisecondsElapsed = new Date().getTime() - start;\n                if (millisecondsElapsed > 100)\n                    return;\n            }\n        }, 0);\n    });\n}\nfunction autoSaveScrollPosition() {\n    // Safari cannot handle more than 100 `history.replaceState()` calls within 30 seconds (https://github.com/brillout/vite-plugin-ssr/issues/46)\n    window.addEventListener('scroll', throttle(saveScrollPosition, Math.ceil(1000 / 3)), { passive: true });\n    onPageHide(saveScrollPosition);\n}\nfunction getUrlHash() {\n    let { hash } = window.location;\n    if (hash === '')\n        return null;\n    assert(hash.startsWith('#'));\n    hash = hash.slice(1);\n    return hash;\n}\n// We use the browser's native scroll restoration mechanism only for the first render\nfunction setupNativeScrollRestoration() {\n    browserNativeScrollRestoration_enable();\n    onPageHide(browserNativeScrollRestoration_enable);\n    onPageShow(() => globalObject.initialRenderIsDone && browserNativeScrollRestoration_disable());\n}\nfunction browserNativeScrollRestoration_disable() {\n    if ('scrollRestoration' in window.history) {\n        window.history.scrollRestoration = 'manual';\n    }\n}\nfunction browserNativeScrollRestoration_enable() {\n    if ('scrollRestoration' in window.history) {\n        window.history.scrollRestoration = 'auto';\n    }\n}\nfunction onPageHide(listener) {\n    window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'hidden') {\n            listener();\n        }\n    });\n}\nfunction onPageShow(listener) {\n    window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'visible') {\n            listener();\n        }\n    });\n}\nfunction checkIfAbort(err, pageContext) {\n    if (isObject(err) && err._abortRendering)\n        return true;\n    if (handleErrorFetchingStaticAssets(err, pageContext)) {\n        return true;\n    }\n    return false;\n}\nfunction handleErrorFetchingStaticAssets(err, pageContext) {\n    if (!isErrorFetchingStaticAssets(err)) {\n        return false;\n    }\n    if (pageContext._isFirstRenderAttempt) {\n        disableClientRouting(err, false);\n        // This may happen if the frontend was newly deployed during hydration.\n        // Ideally: re-try a couple of times by reloading the page (not entirely trivial to implement since `localStorage` is needed.)\n        throw err;\n    }\n    else {\n        disableClientRouting(err, true);\n    }\n    serverSideRouteTo(pageContext.urlOriginal);\n    return true;\n}\n","import { assertClientRouting } from '../../utils/assertRoutingType';\nassertClientRouting();\nimport './pageFiles';\nimport { useClientRouter } from './useClientRouter';\nimport { onClientEntry_ClientRouting } from './utils';\nonClientEntry_ClientRouting(import.meta.env.PROD);\nuseClientRouter();\n"],"file":"assets/entries/entry-client-routing.340a0ef7.js"}