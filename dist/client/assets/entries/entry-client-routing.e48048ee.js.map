{"version":3,"mappings":"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","names":["isPlainObject","value","stringifyStringArray","stringList","str","hasPropertyGetter","obj","prop","descriptor","isPromise","val","isCallable","index_page_route$a","index_page_route$9","index_page_route$8","index_page_route$7","index_page_route$6","index_page_route$5","index_page_route$4","index_page_route$3","index_page_route$2","index_page_route$1","index_page_route","setPageFiles","pageFilesExports","isReact","_a","_b","_c","_d","isReact1","isReact2","isReact3","deepEqual","x","y","ok","tx","key","isEquivalentError","err1","err2","isObject","serverSideRouteTo","url","sleep","milliseconds","r","throttle","func","waitTime","isQueued","assert","isBrowser","assertClientRouting","globalObject","getGlobalObject","urlFirst","getCurrentUrl","navigationState","analyzePageServerSide","pageFilesAll","pageId","pageFilesServerSideOnly","getPageFilesServerSide","p","exportNames","isObjectWithKeys","keys","isStringRecord","thing","addComputedUrlProps","pageContext","enumerable","urlPathnameGetter","urlGetter","urlParsedGetter","getUrlParsed","urlHandler","urlLogical","baseServer","parseUrl","pathname","urlPathname","assertWarning","urlParsedOriginal","origin","pathnameOriginal","search","searchAll","searchOriginal","hash","hashOriginal","urlParsed","makeNonEnumerable","assertURLs","PARAM_TOKEN_NEW","PARAM_TOKEN_OLD","assertRouteString","routeString","errMsgPrefix","assertUsage","routeStr","resolveRouteString","routeSegments","urlSegments","routeParams","assertGlob","i","routeSegment","urlSegment","isParam","numberOfGlobChars","analyzeRouteString","numberOfStaticSegmentsBeginning","numberOfStaticSegements","s","numberOfParameterSegments","isCatchAll","isStaticRouteString","match","resolvePrecendence","routeMatches","sortMatches","makeFirst","routeMatch","routeMatch1","routeMatch2","precedence1","precedence2","result","higherFirst","resolveRouteFunction","routeFunction","routeDefinedAt","assertSyncRouting","hasProp","precedence","assertRouteParams","res","errPrefix","assertPageContextProvidedByUser","pageContextProvidedByUser","hookName","hookFilePath","executeOnBeforeRouteHook","onBeforeRouteHook","hookReturn","errPrefix2","pageContextAddendumHook","assertUsageUrl","objectAssign","_debug","debug","args","route","pageContextAddendum","allPageIds","pageRoute","routeType","winner","BUILT_IN_CLIENT_ROUTER","BUILT_IN_CLIENT","removeBuiltInOverrides","urlToFile","fileExtension","doNotCreateExtraDirectory","hasTrailingSlash","pathnameModified","slice","pageContextJsonFileExtension","getPageContextRequestUrl","getConfigValue","pageConfig","configName","type","configElement","isNullish","configValue","configDefinedAt","codeFilePath","getPageConfig","pageConfigs","assertHookReturnedObject","keysExpected","keysUnknown","assertOnBeforeRenderHookReturn","hookReturnValue","deduceRouteStringFromFilesystemPath","filesystemRoots","fsBase","filesystemRoot","filesystemRoute","urlRoot","debugInfo","dir","loadPageRoutes","pageConfigGlobal","getGlobalHooks","getPageRoutes","pageRoutes","pageIds","comesFromV1PageConfig","removePageId","routeConfig","allowAsyncConfig","routeFilesystem","routeFilesystemDefinedBy","isErrorPageId","pageRouteFile","findPageRouteFile","filePath","fileExports","allowKey","hookFn","onBeforeRoute","dirname","findPageGuard","paths","dirPath","length","id","executeGuardHook","prepareForUserConsumption","hook","getHook","guard","pageContextForUserConsumption","hookResult","executeHook","AbortRender","pageContextAbort","err","stamp","isAbortError","isAbortPageContext","logAbortErrorHandled","isProduction","urlCurrent","abortCall","assertInfo","pc","getPageContextFromAllRewrites","pageContextsFromRewrite","assertNoInfiniteLoop","pageContextFromAllRewrites","pageContextFromRewrite","urlRewrites","urlRewrite","idx","loop","getPageContext","getPageContextFirstRender","setPageContextInitHasClientData","getPageContextUponNavigation","getPageContextSerializedInHtml","loadPageFilesClientSide","getPageContextErrorPage","errorPageId","getErrorPageId","getPageContextAlreadyRouted","getPageContextFromRoute","isErrorPage","hasPageContextServer","pageContextFromServer","fetchPageContextFromServer","preparePageContextForUserConsumptionClientSide","pageContextFromHook","executeOnBeforeRenderHookClientSide","onBeforeRender","onBeforeRenderServerOnlyExists","hasOnBeforeRenderServerSideOnlyHook","pageContextFromRoute","markIs404","checkIf404","pageContextUrl","response","contentType","contentTypeCorrect","isCorrect","AlreadyServerSideRouted","responseText","parse","getProjectError","isAlreadyServerSideRouted","getBaseServer","isBaseServer","createPageContext","pageContextBase","getPageFilesAll","getPageId","routeContext","getExportNames","analyzeExports","pageFilesClientSide","pageFilesServerSide","isHtmlOnly","isClientRouting","assertClientSideRenderHook","hasClientSideRenderHook","determineClientEntry","clientEntries","clientDependencies","clientEntry","getVPSClientEntry","analyzePageClientSide","getPageFilesClientSide","removeOverridenPageFiles","analyzePageClientSideInit","sharedPageFilesAlreadyLoaded","pageFilesClientSide_","analyzeClientSide","isClientSideRoutable","findPageConfig","isClientSideRenderable","isExternalLink","skipLink","linkTag","isNewTabLink","isHashUrl","hasBaseServer","isParsable","isVikeLink","isDisableAutomaticLinkInterception","target","rel","removeHash","getPrefetchSettings","prefetchStaticAssets","getPrefetchStaticAssets","prefetchAttribute","getPrefetchAttribute","wrongUsageMsg","when","correctValue","attr","attrOld","deprecationNotice","linkAlreadyPrefetched","isAlreadyPrefetched","getUrlPathname","markAsAlreadyPrefetched","linkPrefetchHandlerAdded","prefetch","checkIfClientRouting","isErrorFetchingStaticAssets","disableClientRouting","addLinkPrefetchHandlers","observer","entries","entry","initHistoryState","state","hasModifications","getTimestamp","getScrollPosition","assertState","replaceHistoryState","getHistoryState","saveScrollPosition","scrollPosition","pushHistory","overwriteLastHistoryEntry","timestamp","pushHistoryState","defineNavigate","navigate_","getState","setupNativeScrollRestoration","log","useClientRouter","autoSaveScrollPosition","onLinkClick","keepScrollPosition","fetchAndRender","onBrowserHistoryNavigation","scrollTarget","isBackwardNavigation","renderingCounter","renderPromise","isTransitioning","urlOriginal","checkClientSideRenderable","isClientRoutable","renderingNumber","hydrationCanBeAborted","shouldAbort","isFirstRenderAttempt","hasError","err_","shouldSwallowAndInterrupt","errAbort","assertHook","changeUrl","executeOnRenderClientHook","onHydrationEnd","setScrollPosition","browserNativeScrollRestoration_disable","callback","onClick","ev","isNormalLeftClick","findLinkTag","parentNode","currentState","isHashNavigation","getUrlHash","hashTarget","setScroll","scroll","done","start","onPageHide","browserNativeScrollRestoration_enable","onPageShow","listener","handleErrorFetchingStaticAssets","onClientEntry_ClientRouting"],"sources":["../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isPlainObject.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/stringifyStringArray.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/hasPropertyGetter.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isPromise.js","../../../../pages/community/create/index.page.route.ts","../../../../pages/community/edit/index.page.route.ts","../../../../pages/community/post/index.page.route.ts","../../../../pages/community/search/index.page.route.ts","../../../../pages/home/index.page.route.ts","../../../../pages/my-lists/bookmark/index.page.route.ts","../../../../pages/search/index.page.route.tsx","../../../../pages/search/keyword/index.page.route.ts","../../../../pages/search/restaurant/index.page.route.ts","../../../../pages/search/restaurant/reviews/create/index.page.route.ts","../../../../pages/search/restaurant/reviews/edit/index.page.route.ts","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/pageFiles.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isReact.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/deepEqual.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isEquivalentError.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/serverSideRouteTo.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/sleep.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/throttle.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/utils.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/navigationState.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageServerSide.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isObjectWithKeys.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isStringRecord.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/utils.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/addComputedUrlProps.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/resolveRouteString.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/resolvePrecedence.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/resolveRouteFunction.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/assertPageContextProvidedByUser.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/executeOnBeforeRouteHook.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/debug.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/index.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/getPageContext/removeBuiltInOverrides.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/urlToFile.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageContextRequestUrl.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/page-configs/utils.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/assertHookReturnedObject.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/assertOnBeforeRenderHookReturn.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/deduceRouteStringFromFilesystemPath.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/loadPageRoutes.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/executeGuardHook.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/abort.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/getPageContext.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/getBaseServer.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/createPageContext.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/getPageId.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide/getExportNames.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide/analyzeExports.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide/determineClientEntry.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzeClientSide.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/skipLink/isClientSideRoutable.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/isExternalLink.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/skipLink.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/prefetch/getPrefetchSettings.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/prefetch/alreadyPrefetched.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/prefetch.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/history.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/navigate.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/useClientRouter.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/entry.js"],"sourcesContent":["export { isPlainObject };\nfunction isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    // Support `Object.create(null)`\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    return (\n    /* Doesn't work in Cloudlfare Pages workers\n    value.constructor === Object\n    */\n    value.constructor.name === 'Object');\n}\n","export { stringifyStringArray };\nfunction stringifyStringArray(stringList) {\n    return '[' + stringList.map((str) => \"'\" + str + \"'\").join(', ') + ']';\n}\n","export function hasPropertyGetter(obj, prop) {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n    return !!descriptor && !('value' in descriptor) && !!descriptor.get;\n}\n","import { isCallable } from './isCallable';\nexport function isPromise(val) {\n    return typeof val === 'object' && val !== null && 'then' in val && isCallable(val.then);\n}\n","export default '/community/create';\r\n","export default '/community/edit/@postId';\r\n","export default '/community/@postId';\r\n","export default '/community/search/@keyword';\r\n","export default '/';\r\n","export default '/my-lists/bookmark/@bookmarkGroupName';\r\n","export default '/search';\r\n","export default '/search/keyword/@keyword';\r\n","export default '/search/@restaurantId';\r\n","export default '/search/@restaurantId/reviews/create';\r\n","export default '/search/@restaurantId/reviews/@reviewId/edit';\r\n","import { setPageFiles } from '../../shared/getPageFiles';\n// @ts-ignore\nimport * as pageFilesExports from 'virtual:vite-plugin-ssr:importUserCode:client:client-routing';\nsetPageFiles(pageFilesExports);\n","// There doesn't seem to be a reliable way to detect React:\n//  - https://stackoverflow.com/questions/73156433/detect-with-javascript-whether-the-website-is-using-react\nexport function isReact() {\n    var _a, _b, _c, _d;\n    // Heuristic using values set by React (Dev Tools)\n    // - `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` is an internal API for React Dev Tools\n    //   - https://stackoverflow.com/questions/46807826/how-does-react-developer-tools-determine-that-the-webpage-is-using-react/46808361#46808361\n    //   - In principle, `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` should exist only if React Dev Tools is installed. (Although it seems that it's sometimes defined even when React Dev Tools isn't installed; I don't know why.)\n    // - We use `isReact1`/`isReact2` merely to validate `isReact3` and `isReact4`. Because `isReact1`/`isReact2` can be false negatives:\n    //   - React populates `__REACT_DEVTOOLS_GLOBAL_HOOK__.renderers` fairly late => false negative early in the rendering phase\n    //   - `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` is `undefined` if React Dev Tools isn't installed => false negative\n    const isReact1 = !!((_b = (_a = window.__REACT_DEVTOOLS_GLOBAL_HOOK__) === null || _a === void 0 ? void 0 : _a.renderers) === null || _b === void 0 ? void 0 : _b.size);\n    const isReact2 = !!((_d = (_c = window.__REACT_DEVTOOLS_GLOBAL_HOOK__) === null || _c === void 0 ? void 0 : _c.rendererInterfaces) === null || _d === void 0 ? void 0 : _d.size);\n    // Heuristic using values set by `@vitejs/plugin-react`\n    const isReact3 = !!window.__vite_plugin_react_preamble_installed__;\n    /* Also set by Preact Vite plugin `@preact/preset-vite`\n    const isReact4 = !!(window as any).$RefreshReg$\n    */\n    // console.log({ isReact1, isReact2, isReact3 })\n    return isReact1 || isReact2 || isReact3;\n}\n","// https://stackoverflow.com/questions/201183/how-to-determine-equality-for-two-javascript-objects/32922084#32922084\nexport function deepEqual(x, y) {\n    const ok = Object.keys, tx = typeof x, ty = typeof y;\n    return x && y && tx === 'object' && tx === ty\n        ? ok(x).length === ok(y).length && ok(x).every((key) => deepEqual(x[key], y[key]))\n        : x === y;\n}\n","import { isObject } from './isObject';\nimport { deepEqual } from './deepEqual';\nexport { isEquivalentError };\nfunction isEquivalentError(err1, err2) {\n    return (isObject(err1) &&\n        isObject(err2) &&\n        err1.constructor === err2.constructor &&\n        deepEqual({ ...err1, stack: null }, { ...err2, stack: null }) &&\n        // 'message' and 'stack' are usually non-emurable\n        err2.message === err2.message\n    /* Doesn't work because: the stack trace isn't exactly the same between the original page rendering and the fallback error page rendering\n    err2.stack === err2.stack\n    */\n    );\n}\n","export { serverSideRouteTo };\nfunction serverSideRouteTo(url) {\n    window.location.href = url;\n}\n","export { sleep };\nfunction sleep(milliseconds) {\n    return new Promise((r) => setTimeout(r, milliseconds));\n}\n","export { throttle };\nfunction throttle(func, waitTime) {\n    let isQueued = false;\n    return () => {\n        if (!isQueued) {\n            isQueued = true;\n            setTimeout(() => {\n                isQueued = false;\n                func();\n            }, waitTime);\n        }\n    };\n}\n","// Utils needed by Client Routing.\n// Ensure we don't bloat the server-side with client utils\nimport { isBrowser } from '../../utils/isBrowser';\nimport { assert } from '../../utils/assert';\nassert(isBrowser());\n// Ensure we don't bloat Server Routing with Client Routing utils\nimport { assertClientRouting } from '../../utils/assertRoutingType';\nassertClientRouting();\n// We load the Server Routing utils: we tolerate the tiny amount of code that is only needed by Server Routing (only 1-2 lines).\n// We re-export some of the utils down below only to list the utils needed by Client Routing.\nexport * from '../../client/utils';\nexport * from '../../utils/assert';\nexport * from '../../utils/assertSingleInstance';\nexport * from '../../utils/executeHook';\nexport * from '../../utils/getCurrentUrl';\nexport * from '../../utils/getGlobalObject';\nexport * from '../../utils/hasProp';\nexport * from '../../utils/isBrowser';\nexport * from '../../utils/isCallable';\nexport * from '../../utils/isObject';\nexport * from '../../utils/isPlainObject';\nexport * from '../../utils/isReact';\nexport * from '../../utils/isEquivalentError';\nexport * from '../../utils/objectAssign';\nexport * from '../../utils/parseUrl';\nexport * from '../../utils/projectInfo';\nexport * from '../../utils/PromiseType';\nexport * from '../../utils/serverSideRouteTo';\nexport * from '../../utils/sleep';\nexport * from '../../utils/slice';\nexport * from '../../utils/throttle';\nexport * from '../../utils/assertRoutingType';\n","import { getCurrentUrl, getGlobalObject } from './utils';\nconst globalObject = getGlobalObject('navigationState.ts', {});\nconst urlFirst = getCurrentUrl();\nexport const navigationState = {\n    markNavigationChange() {\n        globalObject.navigationChanged = true;\n    },\n    get noNavigationChangeYet() {\n        return !globalObject.navigationChanged && this.isFirstUrl(getCurrentUrl());\n    },\n    isFirstUrl(url) {\n        return url === urlFirst;\n    }\n};\n","export { analyzePageServerSide };\nimport { assert } from '../utils';\nimport { getPageFilesServerSide } from './getAllPageIdFiles';\nasync function analyzePageServerSide(pageFilesAll, pageId) {\n    const pageFilesServerSide = getPageFilesServerSide(pageFilesAll, pageId);\n    const pageFilesServerSideOnly = pageFilesServerSide.filter((p) => p.fileType === '.page.server');\n    await Promise.all(pageFilesServerSideOnly.map(async (p) => {\n        // In production, `exportNames` are preload\n        if (p.exportNames) {\n            return;\n        }\n        assert(p.loadExportNames, pageId);\n        await p.loadExportNames();\n    }));\n    const hasOnBeforeRenderServerSideOnlyHook = pageFilesServerSideOnly.some(({ exportNames }) => {\n        assert(exportNames);\n        return exportNames.includes('onBeforeRender');\n    });\n    return { hasOnBeforeRenderServerSideOnlyHook };\n}\n","import { isPlainObject } from './isPlainObject';\nexport { isObjectWithKeys };\nfunction isObjectWithKeys(obj, keys) {\n    if (!isPlainObject(obj)) {\n        return false;\n    }\n    for (const key of Object.keys(obj)) {\n        if (!keys.includes(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n","export function isStringRecord(thing) {\n    return typeof thing === 'object' && thing !== null && Object.values(thing).every((val) => typeof val === 'string');\n}\n","// Utils needed by:\n//  - runtime of server\n//  - runtime of client (Client Routing)\n// Ensure we don't bloat runtime of Server Routing with the utils down below\nimport { assertClientRouting } from '../../utils/assertRoutingType';\nimport { isBrowser } from '../../utils/isBrowser';\nif (isBrowser()) {\n    assertClientRouting();\n}\nexport * from '../../utils/assert';\nexport * from '../../utils/hasProp';\nexport * from '../../utils/isObjectWithKeys';\nexport * from '../../utils/sorter';\nexport * from '../../utils/isPromise';\nexport * from '../../utils/isPlainObject';\nexport * from '../../utils/objectAssign';\nexport * from '../../utils/slice';\nexport * from '../../utils/isStringRecord';\nexport * from '../../utils/unique';\nexport * from '../../utils/isBrowser';\nexport * from '../../utils/parseUrl';\nexport * from '../../utils/executeHook';\nexport * from '../../utils/checkType';\nexport * from '../../utils/joinEnglish';\nexport * from '../../utils/projectInfo';\nexport * from '../../utils/truncateString';\n","import { assert, parseUrl, assertWarning, isPlainObject, hasPropertyGetter } from './utils';\nexport { addComputedUrlProps };\nexport { assertURLs };\nfunction addComputedUrlProps(pageContext, enumerable = true) {\n    assert(pageContext.urlOriginal);\n    if ('urlPathname' in pageContext) {\n        assert(hasPropertyGetter(pageContext, 'urlPathname'));\n    }\n    Object.defineProperty(pageContext, 'urlPathname', {\n        get: urlPathnameGetter,\n        enumerable,\n        configurable: true\n    });\n    // TODO/v1-release: move pageContext.urlParsed to pageContext.url\n    if ('url' in pageContext)\n        assert(hasPropertyGetter(pageContext, 'url'));\n    Object.defineProperty(pageContext, 'url', {\n        get: urlGetter,\n        enumerable: false,\n        configurable: true\n    });\n    if ('urlParsed' in pageContext) {\n        assert(hasPropertyGetter(pageContext, 'urlParsed'));\n    }\n    Object.defineProperty(pageContext, 'urlParsed', {\n        get: urlParsedGetter,\n        enumerable,\n        configurable: true\n    });\n}\nfunction getUrlParsed(pageContext) {\n    var _a;\n    // We use a url handler function because the onBeforeRoute() hook may modify pageContext.urlOriginal (e.g. for i18n)\n    let urlHandler = pageContext._urlHandler;\n    if (!urlHandler) {\n        urlHandler = (url) => url;\n    }\n    const url = (_a = pageContext._urlRewrite) !== null && _a !== void 0 ? _a : pageContext.urlOriginal;\n    assert(url && typeof url === 'string');\n    const urlLogical = urlHandler(url);\n    const baseServer = pageContext._baseServer;\n    assert(baseServer.startsWith('/'));\n    return parseUrl(urlLogical, baseServer);\n}\nfunction urlPathnameGetter() {\n    const { pathname } = getUrlParsed(this);\n    const urlPathname = pathname;\n    assert(urlPathname.startsWith('/'));\n    return urlPathname;\n}\nfunction urlGetter() {\n    assertWarning(false, '`pageContext.url` is outdated. Use `pageContext.urlPathname`, `pageContext.urlParsed`, or `pageContext.urlOriginal` instead. (See https://vite-plugin-ssr.com/migration/0.4.23 for more information.)', { onlyOnce: true, showStackTrace: true });\n    return urlPathnameGetter.call(this);\n}\nfunction urlParsedGetter() {\n    const urlParsedOriginal = getUrlParsed(this);\n    const { origin, pathname, pathnameOriginal, search, searchAll, searchOriginal, hash, hashOriginal } = urlParsedOriginal;\n    const urlParsed = {\n        origin,\n        pathname,\n        pathnameOriginal,\n        search,\n        searchAll,\n        searchOriginal,\n        hash,\n        hashOriginal,\n        get hashString() {\n            assertWarning(false, '`pageContext.urlParsed.hashString` has been renamed to `pageContext.urlParsed.hashOriginal`', { onlyOnce: true, showStackTrace: true });\n            return hashOriginal;\n        },\n        get searchString() {\n            assertWarning(false, '`pageContext.urlParsed.searchString` has been renamed to `pageContext.urlParsed.searchOriginal`', { onlyOnce: true, showStackTrace: true });\n            return searchOriginal;\n        }\n    };\n    makeNonEnumerable(urlParsed, 'hashString');\n    makeNonEnumerable(urlParsed, 'searchString');\n    return urlParsed;\n}\nfunction makeNonEnumerable(obj, prop) {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n    Object.defineProperty(obj, prop, { ...descriptor, enumerable: false });\n}\nfunction assertURLs(pageContext) {\n    assert(typeof pageContext.urlOriginal === 'string');\n    assert(typeof pageContext.urlPathname === 'string');\n    assert(isPlainObject(pageContext.urlParsed));\n    assert(pageContext.urlPathname === pageContext.urlParsed.pathname);\n}\n","// Unit tests at ./resolveRouteString.spec.ts\nexport { resolveRouteString };\nexport { getUrlFromRouteString };\nexport { isStaticRouteString };\nexport { analyzeRouteString };\n// export { assertRouteString }\nimport { assertWarning } from '../utils';\nimport { assert, assertUsage } from './utils';\nconst PARAM_TOKEN_NEW = '@';\nconst PARAM_TOKEN_OLD = ':';\nfunction assertRouteString(routeString, errMsgPrefix) {\n    assertUsage(routeString.startsWith('/') || routeString === '*', (() => {\n        if (!errMsgPrefix) {\n            errMsgPrefix = 'Invalid';\n        }\n        else {\n            errMsgPrefix = errMsgPrefix + ' invalid';\n        }\n        const routeStr = [`'${routeString}'`, routeString !== '' ? null : '(empty string)'].filter(Boolean).join(' ');\n        const errMsg = `${errMsgPrefix} Route String ${routeStr}: Route Strings should start with a leading slash '/' (or be '*')`;\n        return errMsg;\n    })());\n}\nfunction resolveRouteString(routeString, urlPathname) {\n    assertRouteString(routeString);\n    assert(urlPathname.startsWith('/'));\n    const routeSegments = routeString.split('/');\n    const urlSegments = urlPathname.split('/');\n    const routeParams = {};\n    assertGlob(routeString);\n    if (routeString === '*') {\n        routeString = '/*';\n    }\n    for (let i = 0; i < Math.max(routeSegments.length, urlSegments.length); i++) {\n        const routeSegment = routeSegments[i];\n        const urlSegment = urlSegments[i];\n        if (routeSegment === '*') {\n            routeParams['*'] = urlSegments.slice(Math.max(1, i)).join('/');\n            return { routeParams };\n        }\n        else if (routeSegment && isParam(routeSegment)) {\n            assertWarning(!routeSegment.startsWith(PARAM_TOKEN_OLD), `Outdated Route String \\`${routeString}\\`, use \\`${routeString\n                .split(PARAM_TOKEN_OLD)\n                .join(PARAM_TOKEN_NEW)}\\` instead.`, { onlyOnce: true });\n            if (!urlSegment) {\n                return null;\n            }\n            routeParams[routeSegment.slice(1)] = urlSegment;\n        }\n        else {\n            if ((routeSegment || '') !== (urlSegment || '')) {\n                return null;\n            }\n        }\n    }\n    return { routeParams };\n}\nfunction getUrlFromRouteString(routeString) {\n    assert(routeString.startsWith('/'));\n    if (isStaticRouteString(routeString)) {\n        const url = routeString;\n        return url;\n    }\n    return null;\n}\nfunction assertGlob(routeString) {\n    const numberOfGlobChars = routeString.split('*').length - 1;\n    assertUsage(numberOfGlobChars <= 1, `Invalid Route String '${routeString}': Route Strings are not allowed to contain more than one glob character '*'`);\n    assertUsage(numberOfGlobChars === 0 || (numberOfGlobChars === 1 && routeString.endsWith('*')), `Invalid Route String '${routeString}': make sure your Route String ends with the glob character '*'`);\n}\nfunction analyzeRouteString(routeString) {\n    const routeSegments = routeString.split('/').filter((routeSegment) => routeSegment !== '' && routeSegment !== '*');\n    let numberOfStaticSegmentsBeginning = 0;\n    for (const routeSegment of routeSegments) {\n        if (isParam(routeSegment)) {\n            break;\n        }\n        numberOfStaticSegmentsBeginning++;\n    }\n    const numberOfStaticSegements = routeSegments.filter((s) => !isParam(s)).length;\n    const numberOfParameterSegments = routeSegments.filter((s) => isParam(s)).length;\n    const isCatchAll = routeString.endsWith('*');\n    return { numberOfParameterSegments, numberOfStaticSegmentsBeginning, numberOfStaticSegements, isCatchAll };\n}\nfunction isParam(routeSegment) {\n    return routeSegment.startsWith(PARAM_TOKEN_NEW) || routeSegment.startsWith(PARAM_TOKEN_OLD);\n}\nfunction isStaticRouteString(routeString) {\n    const url = routeString;\n    const match = resolveRouteString(routeString, url);\n    assert(match);\n    return Object.keys(match.routeParams).length === 0;\n}\n","export { resolvePrecendence };\n// export type { RouteMatch }\nimport { analyzeRouteString } from './resolveRouteString';\nimport { higherFirst } from './utils';\nimport { makeFirst } from './utils';\nimport { isStaticRouteString } from './resolveRouteString';\n// See https://vite-plugin-ssr.com/route-function#precedence\nfunction resolvePrecendence(routeMatches) {\n    // prettier-ignore\n    routeMatches\n        .sort(sortMatches)\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !!routeMatch.precedence && routeMatch.precedence < 0))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'STRING' && isStaticRouteString(routeMatch.routeString) === false))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !routeMatch.precedence))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'STRING' && isStaticRouteString(routeMatch.routeString) === true))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FILESYSTEM'))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !!routeMatch.precedence && routeMatch.precedence > 0));\n}\n// -1 => routeMatch1 higher precedence\n// +1 => routeMatch2 higher precedence\nfunction sortMatches(routeMatch1, routeMatch2) {\n    var _a, _b;\n    {\n        const precedence1 = (_a = routeMatch1.precedence) !== null && _a !== void 0 ? _a : 0;\n        const precedence2 = (_b = routeMatch2.precedence) !== null && _b !== void 0 ? _b : 0;\n        if (precedence1 !== precedence2) {\n            return precedence1 > precedence2 ? -1 : 1;\n        }\n    }\n    if (!routeMatch2.routeString) {\n        return 0;\n    }\n    if (!routeMatch1.routeString) {\n        return 0;\n    }\n    // Return route with highest number of static path segments at beginning first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfStaticSegmentsBeginning;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            return result;\n        }\n    }\n    // Return route with highest number of static path segments in total first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfStaticSegements;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            return result;\n        }\n    }\n    // Return route with most parameter segements first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfParameterSegments;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            return result;\n        }\n    }\n    // Return catch-all routes last\n    {\n        if (analyzeRouteString(routeMatch2.routeString).isCatchAll) {\n            return -1;\n        }\n        if (analyzeRouteString(routeMatch1.routeString).isCatchAll) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","export { resolveRouteFunction };\nexport { assertRouteParams };\nexport { assertSyncRouting };\nimport { assertURLs } from '../addComputedUrlProps';\nimport { assert, assertUsage, assertWarning, hasProp, isPlainObject, isPromise, isStringRecord } from './utils';\nasync function resolveRouteFunction(routeFunction, pageContext, routeDefinedAt) {\n    assertURLs(pageContext);\n    let result = routeFunction(pageContext);\n    assertSyncRouting(result, `The Route Function ${routeDefinedAt}`);\n    result = await result;\n    if (result === false) {\n        return null;\n    }\n    if (result === true) {\n        result = {};\n    }\n    assertUsage(isPlainObject(result), `The Route Function ${routeDefinedAt} should return a boolean or a plain JavaScript object, instead it returns \\`${hasProp(result, 'constructor') ? result.constructor : result}\\`.`);\n    if ('match' in result) {\n        const { match } = result;\n        assertUsage(typeof match === 'boolean', `The \\`match\\` value returned by the Route Function ${routeDefinedAt} should be a boolean.`);\n        if (!match) {\n            return null;\n        }\n    }\n    let precedence = null;\n    if ('precedence' in result) {\n        precedence = result.precedence;\n        assertUsage(typeof precedence === 'number', `The \\`precedence\\` value returned by the Route Function ${routeDefinedAt} should be a number.`);\n    }\n    assertRouteParams(result, `The \\`routeParams\\` object returned by the Route Function ${routeDefinedAt} should`);\n    const routeParams = result.routeParams || {};\n    assertUsage(!('pageContext' in result), 'Providing `pageContext` in Route Functions is prohibited, see https://vite-plugin-ssr.com/route-function#cannot-provide-pagecontext');\n    assert(isPlainObject(routeParams));\n    Object.keys(result).forEach((key) => {\n        assertUsage(key === 'match' || key === 'routeParams' || key === 'precedence', `The Route Function ${routeDefinedAt} returned an object with an unknown key \\`{ ${key} }\\`. Allowed keys: ['match', 'routeParams', 'precedence'].`);\n    });\n    return {\n        precedence,\n        routeParams\n    };\n}\nfunction assertSyncRouting(res, errPrefix) {\n    assertWarning(!isPromise(res), `${errPrefix} returned a promise, but asynchronous routing is deprecated and will be removed in the next major release, see https://vite-plugin-ssr.com/route-function#async`, { onlyOnce: true });\n}\nfunction assertRouteParams(result, errPrefix) {\n    assert(errPrefix.endsWith(' should'));\n    if (!hasProp(result, 'routeParams')) {\n        return;\n    }\n    assert(errPrefix.endsWith(' should'));\n    assertUsage(isPlainObject(result.routeParams), `${errPrefix} be a plain JavaScript object.`);\n    assertUsage(isStringRecord(result.routeParams), `${errPrefix} only hold string values.`);\n}\n","import { assert, assertUsage, assertWarning, isObject } from './utils';\nexport { assertPageContextProvidedByUser };\nfunction assertPageContextProvidedByUser(pageContextProvidedByUser, { hookName, hookFilePath }) {\n    if (pageContextProvidedByUser === undefined || pageContextProvidedByUser === null)\n        return;\n    assert(!hookName.endsWith(')'));\n    const errPrefix = `The \\`pageContext\\` object provided by the ${hookName}() hook defined by ${hookFilePath}`;\n    assertUsage(isObject(pageContextProvidedByUser), `${errPrefix} should be an object instead of \\`${typeof pageContextProvidedByUser}\\``);\n    assertUsage(!('_objectCreatedByVitePluginSsr' in pageContextProvidedByUser), `${errPrefix} shouldn't be the whole \\`pageContext\\` object, see https://vite-plugin-ssr.com/pageContext-manipulation#do-not-return-entire-pagecontext`);\n    // In principle, it's possible to use onBeforeRoute()` to override and define the whole routing.\n    // Is that a good idea to allow users to do this? Beyond deep integration with Vue Router or React Router, is there a use case for this?\n    assertWarning(!('_pageId' in pageContextProvidedByUser), `${errPrefix} sets \\`pageContext._pageId\\` which means that vite-plugin-ssr's routing is overriden. This is an experimental feature: make sure to contact a vite-plugin-ssr maintainer before using this.`, { onlyOnce: true });\n    assertUsage(!('is404' in pageContextProvidedByUser), `${errPrefix} sets \\`pageContext.is404\\` which is forbidden, use \\`throw render()\\` instead, see https://vite-plugin-ssr.com/render`);\n}\n","import { assertPageContextProvidedByUser } from '../assertPageContextProvidedByUser';\nimport { assertUsage, hasProp, isObjectWithKeys, objectAssign, assertWarning, assertUsageUrl } from './utils';\nimport { assertRouteParams, assertSyncRouting } from './resolveRouteFunction';\nexport { executeOnBeforeRouteHook };\nasync function executeOnBeforeRouteHook(onBeforeRouteHook, pageContext) {\n    let hookReturn = onBeforeRouteHook.onBeforeRoute(pageContext);\n    assertSyncRouting(hookReturn, `The onBeforeRoute() hook ${onBeforeRouteHook.hookFilePath}`);\n    hookReturn = await hookReturn;\n    const errPrefix = `The onBeforeRoute() hook defined by ${onBeforeRouteHook.hookFilePath}`;\n    assertUsage(hookReturn === null ||\n        hookReturn === undefined ||\n        (isObjectWithKeys(hookReturn, ['pageContext']) && hasProp(hookReturn, 'pageContext')), `${errPrefix} should return \\`null\\`, \\`undefined\\`, or a plain JavaScript object \\`{ pageContext: { /* ... */ } }\\`.`);\n    if (hookReturn === null || hookReturn === undefined) {\n        return null;\n    }\n    assertUsage(hasProp(hookReturn, 'pageContext', 'object'), `${errPrefix} returned \\`{ pageContext }\\` but pageContext should be a plain JavaScript object.`);\n    if (hasProp(hookReturn.pageContext, '_pageId') && !hasProp(hookReturn.pageContext, '_pageId', 'null')) {\n        const errPrefix2 = `${errPrefix} returned \\`{ pageContext: { _pageId } }\\` but _pageId should be`;\n        assertUsage(hasProp(hookReturn.pageContext, '_pageId', 'string'), `${errPrefix2} a string or null`);\n        assertUsage(pageContext._allPageIds.includes(hookReturn.pageContext._pageId), `${errPrefix2} one of following values: \\`[${pageContext._allPageIds.map((s) => `'${s}'`).join(', ')}]\\`.`);\n    }\n    if (hasProp(hookReturn.pageContext, 'routeParams')) {\n        assertRouteParams(hookReturn.pageContext, `${errPrefix} returned \\`{ pageContext: { routeParams } }\\` but routeParams should`);\n    }\n    const pageContextAddendumHook = {};\n    if (hasProp(hookReturn.pageContext, 'url')) {\n        assertWarning(false, `${errPrefix} returned \\`{ pageContext: { url } }\\` but \\`pageContext.url\\` has been renamed to \\`pageContext.urlOriginal\\`. Return \\`{ pageContext: { urlOriginal } }\\` instead. (See https://vite-plugin-ssr.com/migration/0.4.23 for more information.)`, { onlyOnce: true });\n        hookReturn.pageContext.urlOriginal = hookReturn.pageContext.url;\n        delete hookReturn.pageContext.url;\n    }\n    if (hasProp(hookReturn.pageContext, 'urlOriginal')) {\n        assertUsageUrl(hookReturn.pageContext.urlOriginal, `${errPrefix} returned \\`{ pageContext: { urlOriginal } }\\` but urlOriginal`);\n        // Ugly workaround: ideally urlOriginal should be immutable.\n        //  - Instead of using pageContext._urlOriginalPristine, maybe we can keep pageContext.urlOriginal immutable while re-using `pageContext._urlRewrite`.\n        //  - Or better yet we rename pageContext._urlRewrite to pageContext.urlLogical and we allow the user to override pageContext.urlLogical, and we rename pageContext.urlOriginal => `pageContext.urlReal`.\n        //    - pageContext.urlReal / pageContext.urlLogical\n        //                         VS\n        //      pageContext.urlReal / pageContext.urlModified\n        //                         VS\n        //      pageContext.urlOriginal / pageContext.urlModified\n        objectAssign(pageContextAddendumHook, { _urlOriginalPristine: pageContext.urlOriginal });\n    }\n    assertPageContextProvidedByUser(hookReturn.pageContext, {\n        hookFilePath: onBeforeRouteHook.hookFilePath,\n        hookName: 'onBeforeRoute'\n    });\n    objectAssign(pageContextAddendumHook, hookReturn.pageContext);\n    return pageContextAddendumHook;\n}\n","export { debug };\nvar _debug;\nfunction debug(...args) {\n    var _a, _b;\n    if (!_debug) {\n        // We use this trick instead of `import { createDebugger } from '../../utils/debug` in order to ensure that the `debug` mechanism is only loaded on the server-side\n        _debug = (_b = (_a = globalThis).__brillout_debug_createDebugger) === null || _b === void 0 ? void 0 : _b.call(_a, 'vps:routing');\n    }\n    if (_debug) {\n        _debug(...args);\n    }\n}\n","export { route };\n// Ensure we don't bloat runtime of Server Routing\nimport { assertClientRouting } from '../../utils/assertRoutingType';\nimport { isBrowser } from '../../utils/isBrowser';\nif (isBrowser()) {\n    assertClientRouting();\n}\nimport { assert, assertUsage, hasProp, isPlainObject, objectAssign } from './utils';\nimport { addComputedUrlProps } from '../addComputedUrlProps';\nimport { resolvePrecendence } from './resolvePrecedence';\nimport { resolveRouteString } from './resolveRouteString';\nimport { resolveRouteFunction } from './resolveRouteFunction';\nimport { executeOnBeforeRouteHook } from './executeOnBeforeRouteHook';\nimport { debug } from './debug';\nasync function route(pageContext) {\n    addComputedUrlProps(pageContext);\n    debug('Pages routes:', pageContext._pageRoutes);\n    const pageContextAddendum = {};\n    if (pageContext._onBeforeRouteHook) {\n        const pageContextAddendumHook = await executeOnBeforeRouteHook(pageContext._onBeforeRouteHook, pageContext);\n        if (pageContextAddendumHook) {\n            objectAssign(pageContextAddendum, pageContextAddendumHook);\n            if (hasProp(pageContextAddendum, '_pageId', 'string') || hasProp(pageContextAddendum, '_pageId', 'null')) {\n                // We bypass `vite-plugin-ssr`'s routing\n                if (!hasProp(pageContextAddendum, 'routeParams')) {\n                    objectAssign(pageContextAddendum, { routeParams: {} });\n                }\n                else {\n                    assert(hasProp(pageContextAddendum, 'routeParams', 'object'));\n                }\n                objectAssign(pageContextAddendum, {\n                    _routingProvidedByOnBeforeRouteHook: true,\n                    _routeMatches: 'CUSTOM_ROUTE'\n                });\n                return { pageContextAddendum };\n            }\n            // We already assign so that `pageContext.urlOriginal === pageContextAddendum.urlOriginal`; enabling the `onBeforeRoute()` hook to mutate `pageContext.urlOriginal` before routing.\n            objectAssign(pageContext, pageContextAddendum);\n        }\n    }\n    objectAssign(pageContextAddendum, {\n        _routingProvidedByOnBeforeRouteHook: false\n    });\n    // `vite-plugin-ssr`'s routing\n    const allPageIds = pageContext._allPageIds;\n    assert(allPageIds.length >= 0);\n    assertUsage(pageContext._pageFilesAll.length > 0 || pageContext._pageConfigs.length > 0, 'No *.page.js file found. You must create at least one *.page.js file.');\n    assertUsage(allPageIds.length > 0, \"You must create at least one *.page.js file that isn't _default.page.*\");\n    const { urlPathname } = pageContext;\n    assert(urlPathname.startsWith('/'));\n    const routeMatches = [];\n    await Promise.all(pageContext._pageRoutes.map(async (pageRoute) => {\n        const { pageId, routeType } = pageRoute;\n        // Filesytem Routing\n        if (pageRoute.routeType === 'FILESYSTEM') {\n            const { routeString } = pageRoute;\n            const match = resolveRouteString(routeString, urlPathname);\n            if (match) {\n                const { routeParams } = match;\n                routeMatches.push({ pageId, routeParams, routeString, routeType });\n            }\n            return;\n        }\n        // Route String defined in `.page.route.js`\n        if (pageRoute.routeType === 'STRING') {\n            const { routeString } = pageRoute;\n            const match = resolveRouteString(routeString, urlPathname);\n            if (match) {\n                const { routeParams } = match;\n                assert(routeType === 'STRING');\n                routeMatches.push({\n                    pageId,\n                    routeString,\n                    routeParams,\n                    routeType\n                });\n            }\n            return;\n        }\n        // Route Function defined in `.page.route.js`\n        if (pageRoute.routeType === 'FUNCTION') {\n            const { routeFunction, routeDefinedAt } = pageRoute;\n            const match = await resolveRouteFunction(routeFunction, pageContext, routeDefinedAt);\n            if (match) {\n                const { routeParams, precedence } = match;\n                routeMatches.push({ pageId, precedence, routeParams, routeType });\n            }\n            return;\n        }\n        assert(false);\n    }));\n    resolvePrecendence(routeMatches);\n    const winner = routeMatches[0];\n    debug(`Route matches for URL \\`${urlPathname}\\` (in precedence order):`, routeMatches);\n    objectAssign(pageContextAddendum, { _routeMatches: routeMatches });\n    if (!winner) {\n        objectAssign(pageContextAddendum, {\n            _pageId: null,\n            routeParams: {}\n        });\n        return { pageContextAddendum };\n    }\n    {\n        const { routeParams } = winner;\n        assert(isPlainObject(routeParams));\n        objectAssign(pageContextAddendum, {\n            _pageId: winner.pageId,\n            routeParams: winner.routeParams\n        });\n    }\n    return { pageContextAddendum };\n}\n","export { removeBuiltInOverrides };\nimport { assert, assertWarning } from '../utils';\nconst BUILT_IN_CLIENT_ROUTER = ['urlPathname', 'urlParsed'];\nconst BUILT_IN_CLIENT = ['Page', 'pageExports', 'exports'];\nfunction removeBuiltInOverrides(pageContext) {\n    const alreadySet = [...BUILT_IN_CLIENT, ...BUILT_IN_CLIENT_ROUTER];\n    alreadySet.forEach((prop) => {\n        if (prop in pageContext) {\n            // We need to cast `BUILT_IN_CLIENT` to `string[]`\n            //  - https://stackoverflow.com/questions/56565528/typescript-const-assertions-how-to-use-array-prototype-includes\n            //  - https://stackoverflow.com/questions/57646355/check-if-string-is-included-in-readonlyarray-in-typescript\n            if (BUILT_IN_CLIENT_ROUTER.includes(prop)) {\n                assert(prop.startsWith('url'));\n                assertWarning(false, `\\`pageContext.${prop}\\` is already available in the browser when using Client Routing; including \\`${prop}\\` in \\`passToClient\\` has no effect.`, { onlyOnce: true });\n            }\n            else {\n                assertWarning(false, `\\`pageContext.${prop}\\` is a built-in that cannot be overriden; including \\`${prop}\\` in \\`passToClient\\` has no effect.`, { onlyOnce: true });\n            }\n            delete pageContext[prop];\n        }\n    });\n}\n","export { urlToFile };\nexport { baseServer };\nimport { assert } from './assert';\nimport { parseUrl } from './parseUrl';\nimport { slice } from './slice';\n// - When doing a `.pageContext.json` HTTP request, the base URL should be preserved. (The server-side will handle the base URL.)\n// - While prerendering there is no base URL\nconst baseServer = '/';\nfunction urlToFile(url, fileExtension, doNotCreateExtraDirectory) {\n    const { pathnameOriginal, searchOriginal, hashOriginal } = parseUrl(url, baseServer);\n    if (url.startsWith('/')) {\n        assert(url === `${pathnameOriginal}${searchOriginal || ''}${hashOriginal || ''}`, { url });\n    }\n    const hasTrailingSlash = pathnameOriginal.endsWith('/');\n    let pathnameModified;\n    if (doNotCreateExtraDirectory && pathnameOriginal !== '/') {\n        if (hasTrailingSlash) {\n            pathnameModified = slice(pathnameOriginal, 0, -1);\n        }\n        else {\n            pathnameModified = pathnameOriginal;\n        }\n        assert(!pathnameModified.endsWith('/'), { url });\n        assert(pathnameModified !== '');\n    }\n    else {\n        pathnameModified = pathnameOriginal + (hasTrailingSlash ? '' : '/') + 'index';\n    }\n    assert(pathnameModified);\n    pathnameModified = pathnameModified + fileExtension;\n    const fileUrl = `${pathnameModified}${searchOriginal || ''}${hashOriginal || ''}`;\n    return fileUrl;\n}\n","export { getPageContextRequestUrl };\nexport { pageContextJsonFileExtension };\nexport { doNotCreateExtraDirectory };\n// This module isn't loaded by the client-side of Server Routing => we don't inlcude `urlToFile` to `./utils.ts`\nimport { urlToFile } from '../utils/urlToFile';\nconst pageContextJsonFileExtension = '.pageContext.json';\n// `/some-base-url/index.pageContext.json` instead of `/some-base-url.pageContext.json` in order to comply to common reverse proxy setups, see https://github.com/brillout/vite-plugin-ssr/issues/443\nconst doNotCreateExtraDirectory = false;\n// See node/renderPage/handlePageContextRequestUrl.ts\nfunction getPageContextRequestUrl(url) {\n    const pageContextRequestUrl = urlToFile(url, pageContextJsonFileExtension, doNotCreateExtraDirectory);\n    return pageContextRequestUrl;\n}\n","export { getConfigValue };\nexport { getCodeFilePath };\nexport { getPageConfig };\nimport { assert, assertUsage } from '../utils';\n// function getConfigValue(pageConfig: PageConfigData, configName: ConfigName): unknown\nfunction getConfigValue(pageConfig, configName, type) {\n    const configElement = pageConfig.configElements[configName];\n    if (!configElement || isNullish(pageConfig, configName)) {\n        return null;\n    }\n    const { configValue, configDefinedAt } = configElement;\n    assertUsage(typeof configValue === type, `${configDefinedAt} has an invalid type \\`${typeof configValue}\\`: is should be a ${type} instead`);\n    return configValue;\n}\nfunction getCodeFilePath(pageConfig, configName) {\n    const configElement = pageConfig.configElements[configName];\n    if (!configElement || isNullish(pageConfig, configName)) {\n        return null;\n    }\n    if (configElement.codeFilePath !== null) {\n        return configElement.codeFilePath;\n    }\n    const { configValue, configDefinedAt } = configElement;\n    assertUsage(typeof configValue === 'string', `${configDefinedAt} has an invalid type \\`${typeof configValue}\\`: it should be a \\`string\\` instead`);\n    assertUsage(false, `${configDefinedAt} has an invalid value \\`${configValue}\\`: it should be a file path instead`);\n}\nfunction isNullish(pageConfig, configName) {\n    const configElement = pageConfig.configElements[configName];\n    if (!configElement)\n        return true;\n    const { codeFilePath, configValue } = configElement;\n    if (codeFilePath)\n        return false;\n    return configValue === null || configValue === undefined;\n}\nfunction getPageConfig(pageId, pageConfigs) {\n    const pageConfig = pageConfigs.find((p) => p.pageId === pageId);\n    assert(pageConfigs.length > 0);\n    assert(pageConfig);\n    return pageConfig;\n}\n","export { assertHookReturnedObject };\nimport { assert, assertUsage, stringifyStringArray } from './utils';\nfunction assertHookReturnedObject(obj, keysExpected, errPrefix) {\n    assert(!errPrefix.endsWith(' '));\n    const keysUnknown = [];\n    const keys = Object.keys(obj);\n    for (const key of keys) {\n        if (!keysExpected.includes(key)) {\n            keysUnknown.push(key);\n        }\n    }\n    assertUsage(keysUnknown.length === 0, [\n        errPrefix,\n        'returned an object with following unknown keys:',\n        stringifyStringArray(keysUnknown) + '.',\n        'Only following keys are allowed:',\n        stringifyStringArray(keysExpected) + '.'\n    ].join(' '));\n}\n","export { assertOnBeforeRenderHookReturn };\nimport { assertUsage, isPlainObject } from './utils';\nimport { assertPageContextProvidedByUser } from './assertPageContextProvidedByUser';\nimport { assertHookReturnedObject } from './assertHookReturnedObject';\nfunction assertOnBeforeRenderHookReturn(hookReturnValue, hookFilePath) {\n    if (hookReturnValue === undefined || hookReturnValue === null) {\n        return;\n    }\n    const errPrefix = `The onBeforeRender() hook defined by ${hookFilePath}`;\n    assertUsage(isPlainObject(hookReturnValue), `${errPrefix} should return a plain JavaScript object or \\`undefined\\`/\\`null\\``);\n    assertHookReturnedObject(hookReturnValue, ['pageContext'], errPrefix);\n    if (hookReturnValue.pageContext) {\n        assertPageContextProvidedByUser(hookReturnValue['pageContext'], { hookName: 'onBeforeRender', hookFilePath });\n    }\n}\n","// Unit tests at ./deduceRouteStringFromFilesystemPath.spec.ts\nimport { assert, higherFirst, slice } from './utils';\nexport { deduceRouteStringFromFilesystemPath };\n// TODO/next-major-update: remove this and whole filesystemRoot mechanism\nfunction deduceRouteStringFromFilesystemPath(pageId, filesystemRoots) {\n    // Handle Filesystem Routing Root\n    const filesystemRootsMatch = filesystemRoots\n        .filter(({ filesystemRoot }) => pageId.startsWith(filesystemRoot))\n        .sort(higherFirst(({ filesystemRoot }) => filesystemRoot.length));\n    const fsBase = filesystemRootsMatch[0];\n    let filesystemRoute;\n    if (fsBase) {\n        // Example values:\n        //  - `{\"pageId\":\"/pages/index\",\"filesystemRoot\":\"/\",\"urlRoot\":\"/client_portal\"}`\n        const { filesystemRoot, urlRoot } = fsBase;\n        const debugInfo = { pageId, filesystemRoot, urlRoot };\n        assert(urlRoot.startsWith('/') && pageId.startsWith('/') && filesystemRoot.startsWith('/'), debugInfo);\n        assert(pageId.startsWith(filesystemRoot), debugInfo);\n        if (filesystemRoot !== '/') {\n            assert(!filesystemRoot.endsWith('/'), debugInfo);\n            filesystemRoute = slice(pageId, filesystemRoot.length, 0);\n        }\n        else {\n            filesystemRoute = pageId;\n        }\n        assert(filesystemRoute.startsWith('/'), debugInfo);\n        filesystemRoute = urlRoot + (urlRoot.endsWith('/') ? '' : '/') + slice(filesystemRoute, 1, 0);\n    }\n    else {\n        filesystemRoute = pageId;\n    }\n    assert(filesystemRoute.startsWith('/'));\n    // Remove `pages/`, `index/, and `src/`, directories\n    filesystemRoute = filesystemRoute\n        .split('/')\n        .filter((dir) => dir !== 'pages' && dir !== 'src' && dir !== 'index')\n        .join('/');\n    // Hanlde `/index.page.*` suffix\n    assert(!filesystemRoute.includes('.page.'));\n    assert(!filesystemRoute.endsWith('.'));\n    if (filesystemRoute.endsWith('/index')) {\n        filesystemRoute = slice(filesystemRoute, 0, -'/index'.length);\n    }\n    if (filesystemRoute === '') {\n        filesystemRoute = '/';\n    }\n    assert(filesystemRoute.startsWith('/'));\n    assert(!filesystemRoute.endsWith('/') || filesystemRoute === '/');\n    return filesystemRoute;\n}\n","export { loadPageRoutes };\nexport { findPageRouteFile };\nexport { findPageGuard };\nimport { isErrorPageId } from '../error-page';\nimport { assert, assertUsage, hasProp, slice } from './utils';\nimport { deduceRouteStringFromFilesystemPath } from './deduceRouteStringFromFilesystemPath';\nimport { isCallable } from '../utils';\nasync function loadPageRoutes(\n// TODO: remove all arguments and use GlobalContext instead\npageFilesAll, pageConfigs, pageConfigGlobal, allPageIds) {\n    await Promise.all(pageFilesAll.filter((p) => p.fileType === '.page.route').map((p) => { var _a; return (_a = p.loadFile) === null || _a === void 0 ? void 0 : _a.call(p); }));\n    const { onBeforeRouteHook, filesystemRoots } = getGlobalHooks(pageFilesAll, pageConfigs, pageConfigGlobal);\n    const pageRoutes = getPageRoutes(filesystemRoots, pageFilesAll, pageConfigs, allPageIds);\n    return { pageRoutes, onBeforeRouteHook };\n}\nfunction getPageRoutes(filesystemRoots, pageFilesAll, pageConfigs, allPageIds) {\n    const pageRoutes = [];\n    let pageIds = [...allPageIds];\n    // V1 Design\n    if (pageConfigs.length > 0) {\n        assert(filesystemRoots === null);\n        const comesFromV1PageConfig = true;\n        pageConfigs\n            .filter((p) => !p.isErrorPage)\n            .forEach((pageConfig) => {\n            const pageId = pageConfig.pageId;\n            pageIds = removePageId(pageIds, pageId);\n            let pageRoute = null;\n            {\n                const routeConfig = pageConfig.configElements.route;\n                if (routeConfig) {\n                    assert('configValue' in routeConfig); // Route files are eagerly loaded\n                    const route = routeConfig.configValue;\n                    const routeDefinedAt = routeConfig.configDefinedAt;\n                    assert(routeDefinedAt);\n                    if (typeof route === 'string') {\n                        pageRoute = { pageId, comesFromV1PageConfig, routeString: route, routeDefinedAt, routeType: 'STRING' };\n                    }\n                    else {\n                        assert(isCallable(route));\n                        {\n                            // TODO/v1-release: remove\n                            const allowAsyncConfig = pageConfig.configElements.iKnowThePerformanceRisksOfAsyncRouteFunctions;\n                            if (allowAsyncConfig) {\n                                const val = allowAsyncConfig.configValue;\n                                assert(typeof val === 'boolean', `${allowAsyncConfig.configDefinedAt} should be a boolean`);\n                            }\n                        }\n                        pageRoute = {\n                            pageId,\n                            comesFromV1PageConfig,\n                            routeFunction: route,\n                            routeDefinedAt,\n                            routeType: 'FUNCTION'\n                        };\n                    }\n                }\n            }\n            if (!pageRoute) {\n                const { routeFilesystem, routeFilesystemDefinedBy } = pageConfig;\n                assert(routeFilesystem);\n                assert(routeFilesystem.startsWith('/'));\n                assert(routeFilesystemDefinedBy);\n                pageRoute = {\n                    pageId,\n                    routeFilesystemDefinedBy,\n                    comesFromV1PageConfig,\n                    routeString: routeFilesystem,\n                    routeDefinedAt: null,\n                    routeType: 'FILESYSTEM'\n                };\n            }\n            assert(pageRoute);\n            pageRoutes.push(pageRoute);\n        });\n    }\n    // Old design\n    // TODO/v1-release: remove\n    if (pageConfigs.length === 0) {\n        assert(filesystemRoots);\n        const comesFromV1PageConfig = false;\n        pageIds\n            .filter((pageId) => !isErrorPageId(pageId, false))\n            .forEach((pageId) => {\n            const pageRouteFile = findPageRouteFile(pageId, pageFilesAll);\n            if (!pageRouteFile || !('default' in pageRouteFile.fileExports)) {\n                const routeString = deduceRouteStringFromFilesystemPath(pageId, filesystemRoots);\n                assert(routeString.startsWith('/'));\n                assert(!routeString.endsWith('/') || routeString === '/');\n                pageRoutes.push({\n                    pageId,\n                    comesFromV1PageConfig,\n                    routeString,\n                    routeDefinedAt: null,\n                    routeFilesystemDefinedBy: `${pageId}.page.*`,\n                    routeType: 'FILESYSTEM'\n                });\n            }\n            else {\n                const { filePath, fileExports } = pageRouteFile;\n                assert(fileExports.default);\n                if (hasProp(fileExports, 'default', 'string')) {\n                    const routeString = fileExports.default;\n                    assertUsage(routeString.startsWith('/'), `A Route String should start with a leading slash '/' but ${filePath} has \\`export default '${routeString}'\\`. Make sure to \\`export default '/${routeString}'\\` instead.`);\n                    pageRoutes.push({\n                        pageId,\n                        comesFromV1PageConfig,\n                        routeString,\n                        routeDefinedAt: filePath,\n                        routeType: 'STRING'\n                    });\n                    return;\n                }\n                if (hasProp(fileExports, 'default', 'function')) {\n                    const routeFunction = fileExports.default;\n                    {\n                        // TODO/v1-release: remove\n                        const allowKey = 'iKnowThePerformanceRisksOfAsyncRouteFunctions';\n                        if (allowKey in fileExports) {\n                            assertUsage(hasProp(fileExports, allowKey, 'boolean'), `The export \\`${allowKey}\\` of ${filePath} should be a boolean.`);\n                        }\n                    }\n                    pageRoutes.push({\n                        pageId,\n                        comesFromV1PageConfig,\n                        routeFunction,\n                        routeDefinedAt: filePath,\n                        routeType: 'FUNCTION'\n                    });\n                    return;\n                }\n                assertUsage(false, `The default export of ${filePath} should be a string or a function.`);\n            }\n        });\n    }\n    return pageRoutes;\n}\nfunction getGlobalHooks(pageFilesAll, pageConfigs, pageConfigGlobal) {\n    // V1 Design\n    if (pageConfigs.length > 0) {\n        if (pageConfigGlobal.onBeforeRoute) {\n            const hookFn = pageConfigGlobal.onBeforeRoute.configValue;\n            if (hookFn) {\n                const hookFilePath = pageConfigGlobal.onBeforeRoute.codeFilePath;\n                assert(hookFilePath);\n                assertUsage(isCallable(hookFn), `The hook onBeforeRoute() defined by ${hookFilePath} should be a function.`);\n                const onBeforeRouteHook = {\n                    hookFilePath: hookFilePath,\n                    onBeforeRoute: hookFn\n                };\n                return { onBeforeRouteHook, filesystemRoots: null };\n            }\n        }\n        return { onBeforeRouteHook: null, filesystemRoots: null };\n    }\n    // Old design\n    // TODO/v1-release: remove\n    let onBeforeRouteHook = null;\n    const filesystemRoots = [];\n    pageFilesAll\n        .filter((p) => p.fileType === '.page.route' && p.isDefaultPageFile)\n        .forEach(({ filePath, fileExports }) => {\n        assert(fileExports);\n        if ('onBeforeRoute' in fileExports) {\n            assertUsage(hasProp(fileExports, 'onBeforeRoute', 'function'), `\\`export { onBeforeRoute }\\` of ${filePath} should be a function.`);\n            const { onBeforeRoute } = fileExports;\n            onBeforeRouteHook = { hookFilePath: `${filePath} > \\`export { onBeforeRoute }\\``, onBeforeRoute };\n        }\n        if ('filesystemRoutingRoot' in fileExports) {\n            assertUsage(hasProp(fileExports, 'filesystemRoutingRoot', 'string'), `\\`export { filesystemRoutingRoot }\\` of ${filePath} should be a string.`);\n            assertUsage(hasProp(fileExports, 'filesystemRoutingRoot', 'string'), `\\`export { filesystemRoutingRoot }\\` of ${filePath} is \\`'${fileExports.filesystemRoutingRoot}'\\` but it should start with a leading slash \\`/\\`.`);\n            filesystemRoots.push({\n                filesystemRoot: dirname(filePath),\n                urlRoot: fileExports.filesystemRoutingRoot\n            });\n        }\n    });\n    return { onBeforeRouteHook, filesystemRoots };\n}\nfunction findPageRouteFile(pageId, pageFilesAll) {\n    return pageFilesAll.find((p) => p.pageId === pageId && p.fileType === '.page.route');\n}\nfunction findPageGuard(pageId, pageFilesAll) {\n    const pageRouteFile = findPageRouteFile(pageId, pageFilesAll);\n    if (!pageRouteFile)\n        return null;\n    const { filePath, fileExports } = pageRouteFile;\n    assert(fileExports); // loadPageRoutes() should already have been called\n    const hookFn = fileExports.guard;\n    if (!hookFn)\n        return null;\n    const hookFilePath = filePath;\n    assertUsage(isCallable(hookFn), `guard() defined by ${hookFilePath} should be a function`);\n    return { hookFn, hookFilePath };\n}\nfunction dirname(filePath) {\n    assert(filePath.startsWith('/'));\n    assert(!filePath.endsWith('/'));\n    const paths = filePath.split('/');\n    const dirPath = slice(paths, 0, -1).join('/') || '/';\n    assert(dirPath.startsWith('/'));\n    assert(!dirPath.endsWith('/') || dirPath === '/');\n    return dirPath;\n}\nfunction removePageId(pageIds, pageId) {\n    const { length } = pageIds;\n    pageIds = pageIds.filter((id) => id !== pageId);\n    assert(pageIds.length === length - 1);\n    return pageIds;\n}\n","export { executeGuardHook };\nimport { getHook } from '../getHook';\nimport { assert, assertUsage, executeHook } from './utils';\nimport { findPageGuard } from './loadPageRoutes';\nasync function executeGuardHook(pageContext, prepareForUserConsumption) {\n    let hook;\n    if (pageContext._pageFilesAll.length > 0) {\n        // V0.4 design\n        assert(pageContext._pageConfigs.length === 0);\n        hook = findPageGuard(pageContext._pageId, pageContext._pageFilesAll);\n    }\n    else {\n        // V1 design\n        hook = getHook(pageContext, 'guard');\n    }\n    if (!hook)\n        return;\n    const guard = hook.hookFn;\n    let pageContextForUserConsumption = pageContext;\n    const res = prepareForUserConsumption(pageContext);\n    if (res)\n        pageContextForUserConsumption = res;\n    const hookResult = await executeHook(() => guard(pageContextForUserConsumption), 'guard', hook.hookFilePath);\n    assertUsage(hookResult === undefined, `The guard() hook of ${hook.hookFilePath} returns a value, but guard() doesn't accept any return value`);\n}\n","export { redirect };\nexport { render };\nexport { RenderErrorPage };\nexport { isAbortError };\nexport { isAbortPageContext };\nexport { logAbortErrorHandled };\nexport { getPageContextFromAllRewrites };\nexport { AbortRender };\nimport { assert, assertInfo, assertUsage, assertWarning, checkType, hasProp, joinEnglish, objectAssign, projectInfo, truncateString } from './utils';\nimport pc from '@brillout/picocolors';\nfunction redirect(url, statusCode) {\n    const abortCaller = 'redirect';\n    statusCode !== null && statusCode !== void 0 ? statusCode : (statusCode = 302);\n    assertStatusCode(statusCode, [301, 302], 'redirect');\n    assertWarning(statusCode !== 301, \"Status code 301 for `throw redirect()' is experimental and may be removed at any point\", { onlyOnce: true });\n    const pageContextAbort = {};\n    objectAssign(pageContextAbort, {\n        _abortCaller: abortCaller,\n        _abortCall: `throw redirect(${statusCode})`,\n        _urlRedirect: {\n            url,\n            statusCode\n        }\n    });\n    return AbortRender(pageContextAbort);\n}\nfunction render(value, abortReason) {\n    return render_(value, abortReason);\n}\nfunction render_(value, abortReason, pageContextAddendum) {\n    const pageContextAbort = { abortReason };\n    if (pageContextAddendum) {\n        assert(pageContextAddendum._isLegacyRenderErrorPage === true);\n        objectAssign(pageContextAbort, pageContextAddendum);\n    }\n    {\n        const args = [typeof value === 'number' ? String(value) : JSON.stringify(value)];\n        if (abortReason !== undefined)\n            args.push(truncateString(JSON.stringify(abortReason), 30, null));\n        objectAssign(pageContextAbort, {\n            _abortCaller: 'render',\n            _abortCall: `throw render(${args.join(', ')})`\n        });\n    }\n    if (typeof value === 'string') {\n        const url = value;\n        objectAssign(pageContextAbort, {\n            _urlRewrite: url\n        });\n        return AbortRender(pageContextAbort);\n    }\n    else {\n        const statusCode = value;\n        assertStatusCode(value, [401, 403, 404, 429, 500, 503], 'render');\n        objectAssign(pageContextAbort, {\n            _abortStatusCode: statusCode,\n            is404: statusCode === 404\n        });\n        return AbortRender(pageContextAbort);\n    }\n}\nfunction AbortRender(pageContextAbort) {\n    const err = new Error('AbortRender');\n    objectAssign(err, { _pageContextAbort: pageContextAbort, [stamp]: true });\n    checkType(err);\n    return err;\n}\n/**\n * @deprecated Use `throw render()` or `throw redirect()` instead, see https://vite-plugin-ssr.com/render'\n */\nfunction RenderErrorPage({ pageContext = {} } = {}) {\n    var _a;\n    assertWarning(false, '`throw RenderErrorPage()` is deprecated and will be removed in the next major release. Use `throw render()` or `throw redirect()` instead, see https://vite-plugin-ssr.com/render', { onlyOnce: true });\n    let statusCode = 404;\n    let abortReason = 'Page Not Found';\n    if (pageContext.is404 === false || ((_a = pageContext.pageProps) === null || _a === void 0 ? void 0 : _a.is404) === false) {\n        statusCode = 500;\n        abortReason = 'Something went wrong';\n    }\n    objectAssign(pageContext, { _isLegacyRenderErrorPage: true });\n    return render_(statusCode, abortReason, pageContext);\n}\nconst stamp = '_isAbortError';\nfunction isAbortError(thing) {\n    return typeof thing === 'object' && thing !== null && stamp in thing;\n}\nfunction isAbortPageContext(pageContext) {\n    if (!(pageContext._urlRewrite || pageContext._urlRedirect || pageContext._abortStatusCode)) {\n        return false;\n    }\n    assert(hasProp(pageContext, '_abortCall', 'string'));\n    assert(hasProp(pageContext, '_abortCaller', 'string'));\n    checkType(pageContext);\n    return true;\n}\nfunction logAbortErrorHandled(err, isProduction, pageContext) {\n    var _a;\n    if (isProduction)\n        return;\n    const urlCurrent = (_a = pageContext._urlRewrite) !== null && _a !== void 0 ? _a : pageContext.urlOriginal;\n    assert(urlCurrent);\n    const abortCall = err._pageContextAbort._abortCall;\n    assertInfo(false, `${pc.cyan(abortCall)} intercepted while rendering URL ${pc.bold(urlCurrent)}`, { onlyOnce: false });\n}\nfunction assertStatusCode(statusCode, expected, caller) {\n    const expectedEnglish = joinEnglish(expected.map((s) => s.toString()), 'or');\n    assertWarning(expected.includes(statusCode), `Unepexected status code ${statusCode} passed to ${caller}(), we recommend ${expectedEnglish} instead. (Or reach out at ${projectInfo.githubRepository}/issues/1008 if you believe ${statusCode} should be added.)`, { onlyOnce: true });\n}\nfunction getPageContextFromAllRewrites(pageContextsFromRewrite) {\n    assertNoInfiniteLoop(pageContextsFromRewrite);\n    const pageContextFromAllRewrites = { _urlRewrite: null };\n    pageContextsFromRewrite.forEach((pageContextFromRewrite) => {\n        Object.assign(pageContextFromAllRewrites, pageContextFromRewrite);\n    });\n    return pageContextFromAllRewrites;\n}\nfunction assertNoInfiniteLoop(pageContextsFromRewrite) {\n    const urlRewrites = [];\n    pageContextsFromRewrite.forEach((pageContext) => {\n        const urlRewrite = pageContext._urlRewrite;\n        {\n            const idx = urlRewrites.indexOf(urlRewrite);\n            if (idx !== -1) {\n                const loop = [...urlRewrites.slice(idx), urlRewrite].map((url) => `render('${url}')`).join(' => ');\n                assertUsage(false, `Infinite loop of render() calls: ${loop}`);\n            }\n        }\n        urlRewrites.push(urlRewrite);\n    });\n}\n","export { getPageContext };\nexport { getPageContextErrorPage };\nexport { checkIf404 };\nexport { isAlreadyServerSideRouted };\nimport { navigationState } from '../navigationState';\nimport { assert, assertUsage, hasProp, objectAssign, getProjectError, serverSideRouteTo, executeHook, isObject, getGlobalObject } from './utils';\nimport { parse } from '@brillout/json-serializer/parse';\nimport { getPageContextSerializedInHtml } from '../getPageContextSerializedInHtml';\nimport { analyzePageServerSide } from '../../shared/getPageFiles/analyzePageServerSide';\nimport { route } from '../../shared/route';\nimport { getErrorPageId } from '../../shared/error-page';\nimport { getHook } from '../../shared/getHook';\nimport { preparePageContextForUserConsumptionClientSide } from '../preparePageContextForUserConsumptionClientSide';\nimport { loadPageFilesClientSide } from '../loadPageFilesClientSide';\nimport { removeBuiltInOverrides } from './getPageContext/removeBuiltInOverrides';\nimport { getPageContextRequestUrl } from '../../shared/getPageContextRequestUrl';\nimport { getConfigValue, getPageConfig } from '../../shared/page-configs/utils';\nimport { assertOnBeforeRenderHookReturn } from '../../shared/assertOnBeforeRenderHookReturn';\nimport { executeGuardHook } from '../../shared/route/executeGuardHook';\nimport { AbortRender, isAbortPageContext } from '../../shared/route/abort';\nconst globalObject = getGlobalObject('router/getPageContext.ts', {});\nasync function getPageContext(pageContext) {\n    if (pageContext._isFirstRenderAttempt && navigationState.isFirstUrl(pageContext.urlOriginal)) {\n        assert(hasProp(pageContext, '_isFirstRenderAttempt', 'true'));\n        const pageContextAddendum = await getPageContextFirstRender(pageContext);\n        setPageContextInitHasClientData(pageContextAddendum);\n        return pageContextAddendum;\n    }\n    else {\n        assert(hasProp(pageContext, '_isFirstRenderAttempt', 'false'));\n        const pageContextAddendum = await getPageContextUponNavigation(pageContext);\n        setPageContextInitHasClientData(pageContextAddendum);\n        return pageContextAddendum;\n    }\n}\nasync function getPageContextFirstRender(pageContext) {\n    const pageContextAddendum = getPageContextSerializedInHtml();\n    removeBuiltInOverrides(pageContextAddendum);\n    objectAssign(pageContextAddendum, {\n        isHydration: true,\n        _hasPageContextFromClient: false\n    });\n    objectAssign(pageContextAddendum, await loadPageFilesClientSide(pageContext._pageFilesAll, pageContext._pageConfigs, pageContextAddendum._pageId));\n    return pageContextAddendum;\n}\nasync function getPageContextErrorPage(pageContext) {\n    const errorPageId = getErrorPageId(pageContext._pageFilesAll, pageContext._pageConfigs);\n    if (!errorPageId)\n        throw new Error('No error page defined.');\n    const pageContextAddendum = {\n        isHydration: false,\n        _pageId: errorPageId\n    };\n    objectAssign(pageContextAddendum, await getPageContextAlreadyRouted({ ...pageContext, ...pageContextAddendum }, true));\n    return pageContextAddendum;\n}\nasync function getPageContextUponNavigation(pageContext) {\n    const pageContextAddendum = {\n        isHydration: false\n    };\n    objectAssign(pageContextAddendum, await getPageContextFromRoute(pageContext));\n    objectAssign(pageContextAddendum, await getPageContextAlreadyRouted({ ...pageContext, ...pageContextAddendum }, false));\n    return pageContextAddendum;\n}\nasync function getPageContextAlreadyRouted(pageContext, isErrorPage) {\n    let pageContextAddendum = {};\n    objectAssign(pageContextAddendum, await loadPageFilesClientSide(pageContext._pageFilesAll, pageContext._pageConfigs, pageContext._pageId));\n    // Needs to be called before any client-side hook, because it may contain pageContextInit.user which is needed for guard() and onBeforeRender()\n    if (\n    // For the error page, we cannot fetch pageContext from the server because the pageContext JSON request is based on the URL\n    !isErrorPage &&\n        (await hasPageContextServer({ ...pageContext, ...pageContextAddendum }))) {\n        const pageContextFromServer = await fetchPageContextFromServer(pageContext);\n        if (!pageContextFromServer['_isError']) {\n            objectAssign(pageContextAddendum, pageContextFromServer);\n        }\n        else {\n            const errorPageId = getErrorPageId(pageContext._pageFilesAll, pageContext._pageConfigs);\n            assert(errorPageId);\n            pageContextAddendum = {};\n            objectAssign(pageContextAddendum, {\n                isHydration: false,\n                _pageId: errorPageId\n            });\n            objectAssign(pageContextAddendum, await loadPageFilesClientSide(pageContext._pageFilesAll, pageContext._pageConfigs, pageContextAddendum._pageId));\n            assert(hasProp(pageContextFromServer, 'is404', 'boolean'));\n            assert(hasProp(pageContextFromServer, 'pageProps', 'object'));\n            assert(hasProp(pageContextFromServer.pageProps, 'is404', 'boolean'));\n            // When the user hasn't define a `_error.page.js` file: the mechanism with `serverSideError: true` is used instead\n            assert(!('serverSideError' in pageContextFromServer));\n            objectAssign(pageContextAddendum, pageContextFromServer);\n        }\n    }\n    else {\n        objectAssign(pageContextAddendum, { _hasPageContextFromServer: false });\n        // We don't need to call guard() on the client-side if we fetch pageContext from the server side. (Because the `${url}.pageContext.json` HTTP request will already trigger the routing and guard() hook on the serve-side.)\n        // We cannot call guard() before retrieving pageContext from server, since the server-side may define pageContextInit.user which is paramount for guard() hooks\n        if (!isErrorPage) {\n            await executeGuardHook({\n                _hasPageContextFromClient: false,\n                ...pageContext,\n                ...pageContextAddendum\n            }, (pageContext) => preparePageContextForUserConsumptionClientSide(pageContext, true));\n        }\n    }\n    {\n        // For the error page, we also execute the client-side onBeforeRender() hook, but maybe we shouldn't? The server-side does it as well (but maybe it shouldn't).\n        const pageContextFromHook = await executeOnBeforeRenderHookClientSide({ ...pageContext, ...pageContextAddendum });\n        if (pageContextFromHook) {\n            objectAssign(pageContextAddendum, pageContextFromHook);\n        }\n        else {\n            objectAssign(pageContextAddendum, { _hasPageContextFromClient: false });\n        }\n    }\n    return pageContextAddendum;\n}\nasync function executeOnBeforeRenderHookClientSide(pageContext) {\n    const hook = getHook(pageContext, 'onBeforeRender');\n    if (!hook)\n        return null;\n    const onBeforeRender = hook.hookFn;\n    const pageContextAddendum = {\n        _hasPageContextFromClient: true\n    };\n    const pageContextForUserConsumption = preparePageContextForUserConsumptionClientSide({\n        ...pageContext,\n        ...pageContextAddendum\n    }, true);\n    const hookResult = await executeHook(() => onBeforeRender(pageContextForUserConsumption), 'onBeforeRender', hook.hookFilePath);\n    assertOnBeforeRenderHookReturn(hookResult, hook.hookFilePath);\n    const pageContextFromHook = hookResult === null || hookResult === void 0 ? void 0 : hookResult.pageContext;\n    objectAssign(pageContextAddendum, pageContextFromHook);\n    return pageContextAddendum;\n}\nasync function hasPageContextServer(pageContext) {\n    return !!globalObject.pageContextInitHasClientData || (await onBeforeRenderServerOnlyExists(pageContext));\n}\n// Workaround for the fact that the client-side cannot known whether a pageContext JSON request is needed in order to fetch pageContextInit data passed to the client.\n//  - The workaround is reliable as long as the user sets additional pageContextInit to undefined instead of not defining the property:\n//    ```diff\n//    - // Breaks the workaround:\n//    - const pageContextInit = { urlOriginal: req.url }\n//    - if (user) pageContextInit.user = user\n//    + // Makes the workaround reliable:\n//    + const pageContextInit = { urlOriginal: req.url, user }\n//    ```\n// - We can show a warning to users when the pageContextInit keys aren't always the same. (We didn't implement the waning yet because it would require a new doc page https://vite-plugin-ssr.com/pageContextInit#avoid-conditional-properties\n// - Workaround cannot be made completely reliable because the workaround assumes that passToClient is always the same, but the user may set a different passToClient value for another page\n// - Alternatively, we could define a new config `alwaysFetchPageContextFromServer: boolean`\nfunction setPageContextInitHasClientData(pageContext) {\n    if (pageContext._pageContextInitHasClientData) {\n        globalObject.pageContextInitHasClientData = true;\n    }\n}\nasync function onBeforeRenderServerOnlyExists(pageContext) {\n    var _a;\n    if (pageContext._pageConfigs.length > 0) {\n        // V1\n        const pageConfig = getPageConfig(pageContext._pageId, pageContext._pageConfigs);\n        return (_a = getConfigValue(pageConfig, 'hasServerOnBeforeRender', 'boolean')) !== null && _a !== void 0 ? _a : false;\n    }\n    else {\n        // TODO/v1-release: remove\n        // V0.4\n        const { hasOnBeforeRenderServerSideOnlyHook } = await analyzePageServerSide(pageContext._pageFilesAll, pageContext._pageId);\n        return hasOnBeforeRenderServerSideOnlyHook;\n    }\n}\nasync function getPageContextFromRoute(pageContext) {\n    const routeResult = await route(pageContext);\n    const pageContextFromRoute = routeResult.pageContextAddendum;\n    if (!pageContextFromRoute._pageId) {\n        const err = new Error('No routing match');\n        markIs404(err);\n        throw err;\n    }\n    assert(hasProp(pageContextFromRoute, '_pageId', 'string'));\n    return pageContextFromRoute;\n}\nfunction markIs404(err) {\n    objectAssign(err, { _is404: true });\n}\nfunction checkIf404(err) {\n    return isObject(err) && err._is404 === true;\n}\nasync function fetchPageContextFromServer(pageContext) {\n    var _a, _b;\n    const urlLogical = (_b = (_a = pageContext._urlRewrite) !== null && _a !== void 0 ? _a : pageContext._urlOriginalPristine) !== null && _b !== void 0 ? _b : pageContext.urlOriginal;\n    const pageContextUrl = getPageContextRequestUrl(urlLogical);\n    const response = await fetch(pageContextUrl);\n    {\n        const contentType = response.headers.get('content-type');\n        const contentTypeCorrect = 'application/json';\n        const isCorrect = contentType && contentType.includes(contentTypeCorrect);\n        // Static hosts + page doesn't exist\n        if (!isCorrect && response.status === 404) {\n            serverSideRouteTo(pageContext.urlOriginal);\n            throw AlreadyServerSideRouted();\n        }\n        assertUsage(isCorrect, `Wrong Content-Type for ${pageContextUrl}: it should be ${contentTypeCorrect} but it's ${contentType} instead. Make sure to properly use pageContext.httpResponse.headers, see https://vite-plugin-ssr.com/renderPage`);\n    }\n    const responseText = await response.text();\n    const pageContextFromServer = parse(responseText);\n    assert(isObject(pageContextFromServer));\n    if ('serverSideError' in pageContextFromServer) {\n        throw getProjectError('`pageContext` could not be fetched from the server as an error occurred on the server; check your server logs.');\n    }\n    if (isAbortPageContext(pageContextFromServer)) {\n        throw AbortRender(pageContextFromServer);\n    }\n    assert(hasProp(pageContextFromServer, '_pageId', 'string'));\n    removeBuiltInOverrides(pageContextFromServer);\n    objectAssign(pageContextFromServer, { _hasPageContextFromServer: true });\n    return pageContextFromServer;\n}\nfunction isAlreadyServerSideRouted(err) {\n    return isObject(err) && !!err._alreadyServerSideRouted;\n}\nfunction AlreadyServerSideRouted() {\n    const err = new Error(\"Page doesn't exist\");\n    Object.assign(err, { _alreadyServerSideRouted: true });\n    return err;\n}\n","import { assert } from './utils';\nexport function getBaseServer() {\n    const baseServer = import.meta.env.BASE_SERVER;\n    assert(isBaseServer(baseServer));\n    return baseServer;\n}\n// We don't use isBaseServer() defined in utils/parseUrl.ts to avoid loading the whole file in the browser\nfunction isBaseServer(baseServer) {\n    return baseServer.startsWith('/');\n}\n","export { createPageContext };\nimport { addComputedUrlProps } from '../../shared/addComputedUrlProps';\nimport { getPageFilesAll } from '../../shared/getPageFiles';\nimport { loadPageRoutes } from '../../shared/route/loadPageRoutes';\nimport { getBaseServer } from '../getBaseServer';\nimport { assert, isBaseServer, objectAssign, getGlobalObject } from './utils';\nconst globalObject = getGlobalObject('createPageContext.ts', {});\nasync function createPageContext(pageContextBase) {\n    if (!globalObject.pageFilesData) {\n        globalObject.pageFilesData = await getPageFilesAll(true);\n    }\n    const { pageFilesAll, allPageIds, pageConfigs, pageConfigGlobal } = globalObject.pageFilesData;\n    const { pageRoutes, onBeforeRouteHook } = await loadPageRoutes(pageFilesAll, pageConfigs, pageConfigGlobal, allPageIds);\n    const baseServer = getBaseServer();\n    assert(isBaseServer(baseServer));\n    const pageContext = {\n        _objectCreatedByVitePluginSsr: true,\n        _urlHandler: null,\n        _urlRewrite: null,\n        _baseServer: baseServer,\n        _isProduction: import.meta.env.PROD,\n        // TODO: use GlobalContext instead\n        _pageFilesAll: pageFilesAll,\n        _pageConfigs: pageConfigs,\n        _pageConfigGlobal: pageConfigGlobal,\n        _allPageIds: allPageIds,\n        _pageRoutes: pageRoutes,\n        _onBeforeRouteHook: onBeforeRouteHook\n    };\n    objectAssign(pageContext, pageContextBase);\n    addComputedUrlProps(pageContext);\n    return pageContext;\n}\n","export { getPageId };\nimport { route } from '../../shared/route';\nimport { createPageContext } from './createPageContext';\nasync function getPageId(url) {\n    const pageContext = await createPageContext({ urlOriginal: url });\n    const routeContext = await route(pageContext);\n    const pageFilesAll = pageContext._pageFilesAll;\n    const pageConfigs = pageContext._pageConfigs;\n    if (!('pageContextAddendum' in routeContext)) {\n        return { pageId: null, pageFilesAll, pageConfigs };\n    }\n    const pageId = routeContext.pageContextAddendum._pageId;\n    if (!pageId) {\n        return { pageId: null, pageFilesAll, pageConfigs };\n    }\n    return { pageId, pageFilesAll, pageConfigs };\n}\n","export { getExportNames };\nimport { assert } from '../../utils';\nfunction getExportNames(p) {\n    if (p.fileType === '.css') {\n        return [];\n    }\n    if (p.exportNames) {\n        return p.exportNames;\n    }\n    assert(p.fileExports, p.filePath);\n    const exportNames = Object.keys(p.fileExports);\n    return exportNames;\n}\n","export { analyzeExports };\nimport { getExportNames } from './getExportNames';\nimport { assertUsage } from '../../utils';\n// TODO/v1-release: remove\nfunction analyzeExports({ pageFilesClientSide, pageFilesServerSide, pageId }) {\n    return { isHtmlOnly: isHtmlOnly(), isClientRouting: isClientRouting() };\n    function isHtmlOnly() {\n        {\n            const hasPageIdIsmrphFile = pageFilesServerSide.some((p) => p.pageId === pageId && p.fileType === '.page');\n            if (hasPageIdIsmrphFile) {\n                assertClientSideRenderHook();\n                return false;\n            }\n        }\n        {\n            const hasPageIdServerFile = pageFilesServerSide.some((p) => p.pageId === pageId && p.fileType === '.page.server');\n            if (!hasPageIdServerFile) {\n                return false;\n            }\n        }\n        {\n            const definesClientRenderer = pageFilesClientSide.some((p) => p.pageId === pageId && p.fileType === '.page.client' && getExportNames(p).includes('render'));\n            if (definesClientRenderer) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function assertClientSideRenderHook() {\n        const hasClientSideRenderHook = pageFilesClientSide.some((p) => {\n            return getExportNames(p).includes('render');\n        });\n        assertUsage(hasClientSideRenderHook, [\n            'No client-side `render()` hook found.',\n            'See https://vite-plugin-ssr.com/render-modes for more information.',\n            [\n                'Loaded client-side page files (none of them `export { render }`):',\n                ...pageFilesClientSide.map((p, i) => ` (${i + 1}): ${p.filePath}`)\n            ].join('\\n')\n        ].join(' '));\n    }\n    function isClientRouting() {\n        const hasClientRoutingExport = pageFilesClientSide.some((p) => {\n            return getExportNames(p).includes('clientRouting');\n        });\n        return hasClientRoutingExport;\n    }\n}\n","export { determineClientEntry };\nexport { getVPSClientEntry };\nfunction determineClientEntry({ pageFilesClientSide, pageFilesServerSide, isHtmlOnly, isClientRouting }) {\n    let clientEntries = [];\n    const pageFilesServerSideOnly = pageFilesServerSide.filter((p) => !pageFilesClientSide.includes(p));\n    const clientDependencies = [];\n    clientDependencies.push(...pageFilesClientSide.map((p) => ({ id: p.filePath, onlyAssets: false, eagerlyImported: false })));\n    // CSS & assets\n    clientDependencies.push(...pageFilesServerSideOnly.map((p) => ({ id: p.filePath, onlyAssets: true, eagerlyImported: false })));\n    // Handle SPA & SSR pages.\n    if (isHtmlOnly) {\n        clientEntries = pageFilesClientSide.map((p) => p.filePath);\n    }\n    else {\n        // Add the vps client entry\n        const clientEntry = getVPSClientEntry(isClientRouting);\n        clientDependencies.push({ id: clientEntry, onlyAssets: false, eagerlyImported: false });\n        clientEntries = [clientEntry];\n    }\n    // console.log(pageFilesClientSide, pageFilesServerSide, clientDependencies, clientEntry)\n    return { clientEntries, clientDependencies };\n}\nfunction getVPSClientEntry(isClientRouting) {\n    return isClientRouting\n        ? // dist/client/entries/entry-client-routing.js\n            '@@vite-plugin-ssr/dist/esm/client/router/entry.js'\n        : // dist/client/entries/entry-server-routing.js\n            '@@vite-plugin-ssr/dist/esm/client/entry.js';\n}\n","export { analyzePageClientSide };\nexport { analyzePageClientSideInit };\nimport { analyzeExports } from './analyzePageClientSide/analyzeExports';\nimport { determineClientEntry } from './analyzePageClientSide/determineClientEntry';\nimport { getPageFilesClientSide } from './getAllPageIdFiles';\nimport { getPageFilesServerSide } from './getAllPageIdFiles';\nimport { assert } from '../utils';\nimport { getExportNames } from './analyzePageClientSide/getExportNames';\n// TODO/v1-release: remove analyzePageClientSide(), use analyzeClientSide() instead\nfunction analyzePageClientSide(pageFilesAll, pageId) {\n    let pageFilesClientSide = getPageFilesClientSide(pageFilesAll, pageId);\n    const pageFilesServerSide = getPageFilesServerSide(pageFilesAll, pageId);\n    const { isHtmlOnly, isClientRouting } = analyzeExports({ pageFilesClientSide, pageFilesServerSide, pageId });\n    if (isHtmlOnly) {\n        // HTML-only pages don't need any client-side `render()` hook. For apps that have both HTML-only and SSR/SPA pages, we skip the `.page.client.js` file that defines `render()` for HTML-only pages.\n        pageFilesClientSide = pageFilesClientSide.filter((p) => p.isEnv('CLIENT_ONLY') && !getExportNames(p).includes('render'));\n        pageFilesClientSide = removeOverridenPageFiles(pageFilesClientSide);\n    }\n    const { clientEntries, clientDependencies } = determineClientEntry({\n        pageFilesClientSide,\n        pageFilesServerSide,\n        isHtmlOnly,\n        isClientRouting\n    });\n    return { isHtmlOnly, isClientRouting, clientEntries, clientDependencies, pageFilesClientSide, pageFilesServerSide };\n}\n// TODO:v1-release: remove\nasync function analyzePageClientSideInit(pageFilesAll, pageId, { sharedPageFilesAlreadyLoaded }) {\n    const pageFilesClientSide = getPageFilesClientSide(pageFilesAll, pageId);\n    await Promise.all(pageFilesClientSide.map(async (p) => {\n        var _a;\n        assert(p.isEnv('CLIENT_ONLY') || p.isEnv('CLIENT_AND_SERVER'));\n        if (sharedPageFilesAlreadyLoaded && p.isEnv('CLIENT_AND_SERVER')) {\n            return;\n        }\n        // TODO: Is `loadExportNames()` cached ? Does it use filesExports if possible? HMR?\n        await ((_a = p.loadExportNames) === null || _a === void 0 ? void 0 : _a.call(p));\n        /*\n        if (pageFile.exportNames) {\n          return pageFile.exportNames.includes(clientRouting)\n        }\n        if (pageFile.fileExports) {\n          return Object.keys(pageFile.fileExports).includes(clientRouting)\n        }\n        */\n    }));\n}\n// [WIP] Just an experiment needed by https://vite-plugin-ssr.com/banner\n//  - Not sure I want to make something like a public API: the CSS of `_default.page.server.js` are still loaded -> weird DX.\nfunction removeOverridenPageFiles(pageFilesClientSide) {\n    const pageFilesClientSide_ = [];\n    for (const p of pageFilesClientSide) {\n        pageFilesClientSide_.push(p);\n        if (getExportNames(p).includes('overrideDefaultPages')) {\n            break;\n        }\n    }\n    return pageFilesClientSide_;\n}\n","export { analyzeClientSide };\nimport { getConfigValue } from '../page-configs/utils';\nimport { analyzePageClientSide } from './analyzePageClientSide';\nfunction analyzeClientSide(pageConfig, pageFilesAll, pageId) {\n    var _a, _b;\n    // V1 design\n    if (pageConfig) {\n        const isClientRouting = (_a = getConfigValue(pageConfig, 'clientRouting', 'boolean')) !== null && _a !== void 0 ? _a : false;\n        const isClientSideRenderable = (_b = getConfigValue(pageConfig, 'isClientSideRenderable', 'boolean')) !== null && _b !== void 0 ? _b : false;\n        return { isClientSideRenderable, isClientRouting };\n    }\n    else {\n        // TODO/v1-release:\n        //  - remove V0.4 implementation\n        //  - globally rename isHtmlOnly to !isClientSideRenderable\n        // V0.4 design\n        const { isHtmlOnly, isClientRouting } = analyzePageClientSide(pageFilesAll, pageId);\n        return { isClientSideRenderable: !isHtmlOnly, isClientRouting };\n    }\n}\n","export { isClientSideRoutable };\nimport { getPageId } from '../getPageId';\nimport { analyzePageClientSideInit } from '../../../shared/getPageFiles/analyzePageClientSide';\nimport { findPageConfig } from '../../../shared/page-configs/findPageConfig';\nimport { analyzeClientSide } from '../../../shared/getPageFiles/analyzeClientSide';\nasync function isClientSideRoutable(url) {\n    const { pageId, pageFilesAll, pageConfigs } = await getPageId(url);\n    if (!pageId) {\n        return false;\n    }\n    await analyzePageClientSideInit(pageFilesAll, pageId, { sharedPageFilesAlreadyLoaded: false });\n    const pageConfig = findPageConfig(pageConfigs, pageId);\n    const { isClientSideRenderable, isClientRouting } = analyzeClientSide(pageConfig, pageFilesAll, pageId);\n    return isClientSideRenderable && isClientRouting;\n}\n","export { isExternalLink };\nfunction isExternalLink(url) {\n    return !url.startsWith('/') && !url.startsWith('.') && !url.startsWith('?') && url !== '';\n}\n","export { skipLink };\nexport { isClientSideRoutable } from './skipLink/isClientSideRoutable';\nimport { getBaseServer } from '../getBaseServer';\nimport { isExternalLink } from './isExternalLink';\nimport { assert, parseUrl, isBaseServer, isParsable } from './utils';\nimport { isDisableAutomaticLinkInterception } from './useClientRouter';\nfunction skipLink(linkTag) {\n    const url = linkTag.getAttribute('href');\n    if (url === null)\n        return true;\n    if (url === '')\n        return true;\n    if (isExternalLink(url))\n        return true;\n    if (isNewTabLink(linkTag))\n        return true;\n    if (isHashUrl(url))\n        return true;\n    if (!hasBaseServer(url)) {\n        return true;\n    }\n    if (!isParsable(url)) {\n        return true;\n    }\n    // Purposely last because disableAutomaticLinkInterception will be removed in the major release\n    if (!isVikeLink(linkTag))\n        return true;\n    return false;\n}\n// TODO/v1-release: remove this in favor of synchronously checking whether URL matches the route of a page (possible since Async Route Functions are now deprecated)\nfunction isVikeLink(linkTag) {\n    const disableAutomaticLinkInterception = isDisableAutomaticLinkInterception();\n    if (!disableAutomaticLinkInterception) {\n        return true;\n    }\n    else {\n        const target = linkTag.getAttribute('data-vike-link');\n        return target !== null && target !== 'false';\n    }\n}\nfunction isNewTabLink(linkTag) {\n    const target = linkTag.getAttribute('target');\n    const rel = linkTag.getAttribute('rel');\n    return target === '_blank' || target === '_external' || rel === 'external' || linkTag.hasAttribute('download');\n}\nfunction isHashUrl(url) {\n    if (url.startsWith('#')) {\n        return true;\n    }\n    const removeHash = (url) => url.split('#')[0];\n    if (url.includes('#') && removeHash(url) === removeHash(window.location.href)) {\n        return true;\n    }\n    return false;\n}\nfunction hasBaseServer(url) {\n    const baseServer = getBaseServer();\n    assert(isBaseServer(baseServer));\n    const { hasBaseServer } = parseUrl(url, baseServer);\n    return hasBaseServer;\n}\n","export { getPrefetchSettings };\nimport { assert, assertUsage, assertInfo, assertWarning, isPlainObject } from '../utils';\nfunction getPrefetchSettings(pageContext, linkTag) {\n    let prefetchStaticAssets = getPrefetchStaticAssets(pageContext, linkTag);\n    if (prefetchStaticAssets === 'viewport' && !pageContext._isProduction) {\n        assertInfo(false, 'Viewport prefetching is disabled in development', { onlyOnce: true });\n        prefetchStaticAssets = 'hover';\n    }\n    return {\n        prefetchStaticAssets\n    };\n}\nfunction getPrefetchStaticAssets(pageContext, linkTag) {\n    {\n        const prefetchAttribute = getPrefetchAttribute(linkTag);\n        if (prefetchAttribute !== null)\n            return prefetchAttribute;\n    }\n    if ('prefetchLinks' in pageContext.exports) {\n        assertUsage(false, '`export { prefetchLinks }` is deprecated, use `export { prefetchStaticAssets }` instead.');\n    }\n    if ('prefetchStaticAssets' in pageContext.exports) {\n        const { prefetchStaticAssets } = pageContext.exports;\n        if (prefetchStaticAssets === false) {\n            return false;\n        }\n        if (prefetchStaticAssets === 'hover') {\n            return 'hover';\n        }\n        if (prefetchStaticAssets === 'viewport') {\n            return 'viewport';\n        }\n        const wrongUsageMsg = \"prefetchStaticAssets value should be false, 'hover', or 'viewport'\";\n        // TODO/v1-release: remove\n        assertUsage(isPlainObject(prefetchStaticAssets), wrongUsageMsg);\n        const keys = Object.keys(prefetchStaticAssets);\n        assertUsage(keys.length === 1 && keys[0] === 'when', wrongUsageMsg);\n        const { when } = prefetchStaticAssets;\n        if (when === 'HOVER' || when === 'VIEWPORT') {\n            const correctValue = when.toLowerCase();\n            assertWarning(false, `prefetchStaticAssets value \\`{ when: '${when}' }\\` is outdated: set prefetchStaticAssets to '${correctValue}' instead`, { onlyOnce: true });\n            return correctValue;\n        }\n        assertUsage(false, wrongUsageMsg);\n    }\n    return 'hover';\n}\nfunction getPrefetchAttribute(linkTag) {\n    const attr = linkTag.getAttribute('data-prefetch-static-assets');\n    const attrOld = linkTag.getAttribute('data-prefetch');\n    if (attr === null && attrOld === null) {\n        return null;\n    }\n    const deprecationNotice = 'The attribute data-prefetch is outdated, use data-prefetch-static-assets instead.';\n    if (attr) {\n        assertUsage(attrOld === null, deprecationNotice);\n        if (attr === 'hover' || attr === 'viewport') {\n            return attr;\n        }\n        if (attr === 'false') {\n            return false;\n        }\n        assertUsage(false, `data-prefetch-static-assets has value \"${attr}\" but it should instead be \"false\", \"hover\", or \"viewport\"`);\n    }\n    // TODO/v1-release: remove\n    if (attrOld) {\n        assert(!attr);\n        assertWarning(false, deprecationNotice, {\n            onlyOnce: true\n        });\n        if (attrOld === 'true') {\n            return 'viewport';\n        }\n        if (attrOld === 'false') {\n            return 'hover';\n        }\n        assertUsage(false, `data-prefetch has value \"${attrOld}\" but it should instead be \"true\" or \"false\"`);\n    }\n    assert(false);\n}\n","export { isAlreadyPrefetched };\nexport { markAsAlreadyPrefetched };\nimport { parseUrl } from '../utils';\nconst linkAlreadyPrefetched = new Map();\nfunction isAlreadyPrefetched(url) {\n    const urlPathname = getUrlPathname(url);\n    return linkAlreadyPrefetched.has(urlPathname);\n}\nfunction markAsAlreadyPrefetched(url) {\n    const urlPathname = getUrlPathname(url);\n    linkAlreadyPrefetched.set(urlPathname, true);\n}\nfunction getUrlPathname(url) {\n    const urlPathname = parseUrl(url, '/').pathname;\n    return urlPathname;\n}\n","export { prefetch };\nexport { addLinkPrefetchHandlers };\nimport { assert, assertClientRouting, assertUsage, checkIfClientRouting } from './utils';\nimport { isErrorFetchingStaticAssets, loadPageFilesClientSide } from '../loadPageFilesClientSide';\nimport { isClientSideRoutable, skipLink } from './skipLink';\nimport { getPageId } from './getPageId';\nimport { getPrefetchSettings } from './prefetch/getPrefetchSettings';\nimport { isAlreadyPrefetched, markAsAlreadyPrefetched } from './prefetch/alreadyPrefetched';\nimport { disableClientRouting } from './useClientRouter';\nimport { isExternalLink } from './isExternalLink';\nassertClientRouting();\nconst linkPrefetchHandlerAdded = new Map();\n/**\n * Programmatically prefetch client assets.\n *\n * https://vite-plugin-ssr.com/prefetch\n *\n * @param url - The URL of the page you want to prefetch.\n */\nasync function prefetch(url) {\n    assertUsage(checkIfClientRouting(), 'prefetch() only works with Client Routing, see https://vite-plugin-ssr.com/prefetch', { showStackTrace: true });\n    assertUsage(!isExternalLink(url), `You are trying to prefetch the URL ${url} of another domain which cannot be prefetched`, { showStackTrace: true });\n    if (isAlreadyPrefetched(url))\n        return;\n    markAsAlreadyPrefetched(url);\n    const { pageId, pageFilesAll, pageConfigs } = await getPageId(url);\n    if (pageId) {\n        try {\n            await loadPageFilesClientSide(pageFilesAll, pageConfigs, pageId);\n        }\n        catch (err) {\n            if (isErrorFetchingStaticAssets(err)) {\n                disableClientRouting(err, true);\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n}\nfunction addLinkPrefetchHandlers(pageContext) {\n    // Current URL is already prefetched\n    markAsAlreadyPrefetched(pageContext.urlPathname);\n    const linkTags = [...document.getElementsByTagName('A')];\n    linkTags.forEach(async (linkTag) => {\n        if (linkPrefetchHandlerAdded.has(linkTag))\n            return;\n        linkPrefetchHandlerAdded.set(linkTag, true);\n        const url = linkTag.getAttribute('href');\n        if (skipLink(linkTag))\n            return;\n        assert(url);\n        try {\n            if (!(await isClientSideRoutable(url)))\n                return;\n        }\n        catch {\n            // If a route() hook has a bug or `throw render()` / `throw redirect()`\n            return;\n        }\n        if (isAlreadyPrefetched(url))\n            return;\n        const { prefetchStaticAssets } = getPrefetchSettings(pageContext, linkTag);\n        if (!prefetchStaticAssets) {\n            return;\n        }\n        else if (prefetchStaticAssets === 'hover') {\n            linkTag.addEventListener('mouseover', () => prefetch(url));\n            linkTag.addEventListener('touchstart', () => prefetch(url), { passive: true });\n        }\n        else if (prefetchStaticAssets === 'viewport') {\n            const observer = new IntersectionObserver((entries) => {\n                entries.forEach((entry) => {\n                    if (entry.isIntersecting) {\n                        prefetch(url);\n                        observer.disconnect();\n                    }\n                });\n            });\n            observer.observe(linkTag);\n        }\n    });\n}\n","export { initHistoryState, getHistoryState, pushHistory, saveScrollPosition };\nimport { assert, hasProp, isObject } from './utils';\n// Fill missing state information.\n//  - The very first render => `history.state` is uninitialized (`null`).\n//  - The vite-plugin-ssr app runs `location.hash = '#section'` => `history.state` is uninitialized (`null`).\n//  - The user clicks on an anchor link `<a href=\"#section\">Section</a>` => `history.state` is uninitialized (`null`).\n//  - `history.state` set by an old vite-plugin-ssr version => state information may be incomplete. (E.g. `state.timestamp` was introduced for `pageContext.isBackwardNavigation` in `0.4.19`.)\nfunction initHistoryState() {\n    let state = window.history.state;\n    if (!state) {\n        state = {};\n    }\n    let hasModifications = false;\n    if (!('timestamp' in state)) {\n        hasModifications = true;\n        state.timestamp = getTimestamp();\n    }\n    if (!('scrollPosition' in state)) {\n        hasModifications = true;\n        state.scrollPosition = getScrollPosition();\n    }\n    assertState(state);\n    if (hasModifications) {\n        replaceHistoryState(state);\n    }\n}\nfunction getHistoryState() {\n    const state = window.history.state || {};\n    assertState(state);\n    return state;\n}\nfunction getScrollPosition() {\n    const scrollPosition = { x: window.scrollX, y: window.scrollY };\n    return scrollPosition;\n}\nfunction getTimestamp() {\n    return new Date().getTime();\n}\nfunction saveScrollPosition() {\n    const scrollPosition = getScrollPosition();\n    const state = getHistoryState();\n    replaceHistoryState({ ...state, scrollPosition });\n}\nfunction pushHistory(url, overwriteLastHistoryEntry) {\n    if (!overwriteLastHistoryEntry) {\n        const timestamp = getTimestamp();\n        pushHistoryState({ timestamp, scrollPosition: null }, url);\n    }\n    else {\n        replaceHistoryState(getHistoryState(), url);\n    }\n}\nfunction assertState(state) {\n    assert(isObject(state));\n    if ('timestamp' in state) {\n        const { timestamp } = state;\n        assert(typeof timestamp === 'number');\n    }\n    if ('scrollPosition' in state) {\n        const { scrollPosition } = state;\n        if (scrollPosition !== null) {\n            assert(hasProp(scrollPosition, 'x', 'number') && hasProp(scrollPosition, 'y', 'number'));\n        }\n    }\n}\nfunction replaceHistoryState(state, url) {\n    window.history.replaceState(state, '', url !== null && url !== void 0 ? url : null);\n}\nfunction pushHistoryState(state, url) {\n    window.history.pushState(state, '', url);\n}\n","export { navigate };\nexport { reload };\nexport { defineNavigate };\nimport { assertUsage, isBrowser, getGlobalObject, assertClientRouting, checkIfClientRouting, getCurrentUrl } from './utils';\nassertClientRouting();\nconst globalObject = getGlobalObject('navigate.ts', {});\n/** Programmatically navigate to a new page.\n *\n * https://vite-plugin-ssr.com/navigate\n *\n * @param url - The URL of the new page.\n * @param keepScrollPosition - Don't scroll to the top of the page, instead keep the current scroll position.\n * @param overwriteLastHistoryEntry - Don't create a new entry in the browser's history, instead let the new URL replace the current URL. (This effectively removes the current URL from the browser history).\n */\nasync function navigate(url, { keepScrollPosition = false, overwriteLastHistoryEntry = false } = {}) {\n    assertUsage(isBrowser(), '[`navigate(url)`] The `navigate(url)` function is only callable in the browser but you are calling it in Node.js.', { showStackTrace: true });\n    const errMsg = 'navigate() only works with Client Routing, see https://vite-plugin-ssr.com/navigate';\n    assertUsage(globalObject.navigate, errMsg, { showStackTrace: true });\n    assertUsage(checkIfClientRouting(), errMsg, { showStackTrace: true });\n    assertUsage(url, '[navigate(url)] Missing argument `url`.', { showStackTrace: true });\n    assertUsage(typeof url === 'string', '[navigate(url)] Argument `url` should be a string (but we got `typeof url === \"' + typeof url + '\"`.', { showStackTrace: true });\n    assertUsage(typeof keepScrollPosition === 'boolean', '[navigate(url, { keepScrollPosition })] Argument `keepScrollPosition` should be a boolean (but we got `typeof keepScrollPosition === \"' +\n        typeof keepScrollPosition +\n        '\"`.', { showStackTrace: true });\n    assertUsage(typeof overwriteLastHistoryEntry === 'boolean', '[navigate(url, { overwriteLastHistoryEntry })] Argument `overwriteLastHistoryEntry` should be a boolean (but we got `typeof keepScrollPosition === \"' +\n        typeof overwriteLastHistoryEntry +\n        '\"`.', { showStackTrace: true });\n    assertUsage(url.startsWith('/'), '[navigate(url)] Argument `url` should start with a leading `/`.', {\n        showStackTrace: true\n    });\n    await globalObject.navigate(url, { keepScrollPosition, overwriteLastHistoryEntry });\n}\nfunction defineNavigate(navigate_) {\n    globalObject.navigate = navigate_;\n}\nasync function reload() {\n    await navigate(getCurrentUrl());\n}\n","export { useClientRouter };\nexport { disableClientRouting };\nexport { isDisableAutomaticLinkInterception };\nimport { assert, getCurrentUrl, isEquivalentError, objectAssign, serverSideRouteTo, throttle, sleep, getGlobalObject, executeHook } from './utils';\nimport { navigationState } from '../navigationState';\nimport { checkIf404, getPageContext, getPageContextErrorPage, isAlreadyServerSideRouted } from './getPageContext';\nimport { createPageContext } from './createPageContext';\nimport { addLinkPrefetchHandlers } from './prefetch';\nimport { assertInfo, assertWarning, isReact } from './utils';\nimport { executeOnRenderClientHook } from '../executeOnRenderClientHook';\nimport { assertHook } from '../../shared/getHook';\nimport { isClientSideRoutable, skipLink } from './skipLink';\nimport { isErrorFetchingStaticAssets } from '../loadPageFilesClientSide';\nimport { initHistoryState, getHistoryState, pushHistory, saveScrollPosition } from './history';\nimport { defineNavigate } from './navigate';\nimport { getPageContextFromAllRewrites, isAbortError, logAbortErrorHandled } from '../../shared/route/abort';\nconst globalObject = getGlobalObject('useClientRouter.ts', { previousState: getState() });\nsetupNativeScrollRestoration();\ninitHistoryState();\nfunction disableClientRouting(err, log) {\n    assert(isErrorFetchingStaticAssets(err));\n    globalObject.clientRoutingIsDisabled = true;\n    if (log) {\n        // We don't use console.error() to avoid flooding error trackers such as Sentry\n        console.log(err);\n    }\n    assertInfo(false, [\n        'Failed to fetch static asset.',\n        import.meta.env.PROD ? 'This usually happens when a new frontend is deployed.' : null,\n        'Falling back to Server Routing.',\n        '(The next page navigation will use Server Routing instead of Client Routing.)'\n    ]\n        .filter(Boolean)\n        .join(' '), { onlyOnce: true });\n}\nfunction useClientRouter() {\n    autoSaveScrollPosition();\n    onLinkClick((url, { keepScrollPosition }) => {\n        const scrollTarget = keepScrollPosition ? 'preserve-scroll' : 'scroll-to-top-or-hash';\n        fetchAndRender({\n            scrollTarget,\n            urlOriginal: url,\n            isBackwardNavigation: false,\n            checkClientSideRenderable: true\n        });\n    });\n    onBrowserHistoryNavigation((scrollTarget, isBackwardNavigation) => {\n        fetchAndRender({ scrollTarget, isBackwardNavigation });\n    });\n    defineNavigate(async (url, { keepScrollPosition = false, overwriteLastHistoryEntry = false } = {}) => {\n        const scrollTarget = keepScrollPosition ? 'preserve-scroll' : 'scroll-to-top-or-hash';\n        await fetchAndRender({\n            scrollTarget,\n            urlOriginal: url,\n            overwriteLastHistoryEntry,\n            isBackwardNavigation: false,\n            checkClientSideRenderable: true\n        });\n    });\n    let renderingCounter = 0;\n    let renderPromise;\n    let isTransitioning = false;\n    fetchAndRender({ scrollTarget: 'preserve-scroll', isBackwardNavigation: null });\n    return;\n    async function fetchAndRender({ scrollTarget, urlOriginal = getCurrentUrl(), overwriteLastHistoryEntry = false, isBackwardNavigation, checkClientSideRenderable, pageContextsFromRewrite = [] }) {\n        var _a, _b;\n        if (globalObject.clientRoutingIsDisabled) {\n            serverSideRouteTo(urlOriginal);\n            return;\n        }\n        const pageContextFromAllRewrites = getPageContextFromAllRewrites(pageContextsFromRewrite);\n        if (checkClientSideRenderable) {\n            const urlLogical = (_a = pageContextFromAllRewrites._urlRewrite) !== null && _a !== void 0 ? _a : urlOriginal;\n            let isClientRoutable;\n            try {\n                isClientRoutable = await isClientSideRoutable(urlLogical);\n            }\n            catch (err) {\n                if (!isAbortError(err)) {\n                    // If a route() hook has a bug\n                    throw err;\n                }\n                else {\n                    // If the user's route() hook throw redirect() / throw render()\n                    // We handle the abort error down below: the user's route() hook is called again in getPageContext()\n                    isClientRoutable = true;\n                }\n            }\n            if (!isClientRoutable) {\n                serverSideRouteTo(urlOriginal);\n                return;\n            }\n        }\n        const pageContextBase = {\n            urlOriginal,\n            isBackwardNavigation,\n            ...pageContextFromAllRewrites\n        };\n        const renderingNumber = ++renderingCounter;\n        assert(renderingNumber >= 1);\n        // Start transition before any await's\n        if (renderingNumber > 1) {\n            if (isTransitioning === false) {\n                (_b = globalObject.onPageTransitionStart) === null || _b === void 0 ? void 0 : _b.call(globalObject, pageContextBase);\n                isTransitioning = true;\n            }\n        }\n        let hydrationCanBeAborted = false;\n        const shouldAbort = () => {\n            {\n                // We should never abort the hydration if `hydrationCanBeAborted` isn't `true`\n                const isHydration = renderingNumber === 1;\n                if (isHydration && hydrationCanBeAborted === false) {\n                    return false;\n                }\n            }\n            // If there is a newer rendering, we should abort all previous renderings\n            if (renderingNumber !== renderingCounter) {\n                return true;\n            }\n            return false;\n        };\n        const pageContext = await createPageContext(pageContextBase);\n        if (shouldAbort()) {\n            return;\n        }\n        const isFirstRenderAttempt = renderingNumber === 1;\n        objectAssign(pageContext, {\n            _isFirstRenderAttempt: isFirstRenderAttempt\n        });\n        let pageContextAddendum;\n        let err;\n        let hasError = false;\n        try {\n            pageContextAddendum = await getPageContext(pageContext);\n        }\n        catch (err_) {\n            hasError = true;\n            err = err_;\n        }\n        if (hasError) {\n            if (!isAbortError(err)) {\n                // We don't swallow 404 errors:\n                //  - On the server-side, VPS swallows / doesn't show any 404 error log because it's expected that a user may go to some random non-existent URL. (We don't want to flood the app's error tracking with 404 logs.)\n                //  - On the client-side, if the user navigates to a 404 then it means that the UI has a broken link. (It isn't expected that users can go to some random URL using the client-side router, as it would require, for example, the user to manually change the URL of a link by manually manipulating the DOM which highly unlikely.)\n                console.error(err);\n            }\n            else {\n                // We swallow throw redirect()/render() called by client-side hooks onBeforeRender() and guard()\n                // We handle the abort error down below.\n            }\n            if (shouldSwallowAndInterrupt(err, pageContext))\n                return;\n            if (isAbortError(err)) {\n                const errAbort = err;\n                logAbortErrorHandled(err, pageContext._isProduction, pageContext);\n                const pageContextAbort = errAbort._pageContextAbort;\n                if (pageContextAbort._urlRewrite) {\n                    await fetchAndRender({\n                        scrollTarget,\n                        urlOriginal,\n                        overwriteLastHistoryEntry,\n                        isBackwardNavigation,\n                        pageContextsFromRewrite: [...pageContextsFromRewrite, pageContextAbort]\n                    });\n                    return;\n                }\n                if (pageContextAbort._urlRedirect) {\n                    await fetchAndRender({\n                        scrollTarget: 'scroll-to-top-or-hash',\n                        urlOriginal: pageContextAbort._urlRedirect.url,\n                        overwriteLastHistoryEntry: false,\n                        isBackwardNavigation: false,\n                        checkClientSideRenderable: true\n                    });\n                    return;\n                }\n                assert(pageContextAbort._abortStatusCode);\n                objectAssign(pageContext, pageContextAbort);\n            }\n            else {\n                objectAssign(pageContext, { is404: checkIf404(err) });\n            }\n            try {\n                pageContextAddendum = await getPageContextErrorPage(pageContext);\n            }\n            catch (err2) {\n                // - When user hasn't defined a `_error.page.js` file\n                // - Some unpexected vite-plugin-ssr internal error\n                if (shouldSwallowAndInterrupt(err2, pageContext))\n                    return;\n                if (!isFirstRenderAttempt) {\n                    setTimeout(() => {\n                        // We let the server show the 404 page\n                        window.location.pathname = urlOriginal;\n                    }, 0);\n                }\n                if (!isEquivalentError(err, err2)) {\n                    throw err2;\n                }\n                else {\n                    // Abort\n                    return;\n                }\n            }\n        }\n        assert(pageContextAddendum);\n        objectAssign(pageContext, pageContextAddendum);\n        assertHook(pageContext, 'onPageTransitionStart');\n        globalObject.onPageTransitionStart = pageContext.exports.onPageTransitionStart;\n        if (pageContext.exports.hydrationCanBeAborted) {\n            hydrationCanBeAborted = true;\n        }\n        else {\n            assertWarning(!isReact(), 'You seem to be using React; we recommend setting `hydrationCanBeAborted` to `true`, see https://vite-plugin-ssr.com/clientRouting', { onlyOnce: true });\n        }\n        if (shouldAbort()) {\n            return;\n        }\n        if (renderPromise) {\n            // Always make sure that the previous render has finished,\n            // otherwise that previous render may finish after this one.\n            await renderPromise;\n        }\n        if (shouldAbort()) {\n            return;\n        }\n        changeUrl(urlOriginal, overwriteLastHistoryEntry);\n        navigationState.markNavigationChange();\n        assert(renderPromise === undefined);\n        renderPromise = (async () => {\n            await executeOnRenderClientHook(pageContext, true);\n            addLinkPrefetchHandlers(pageContext);\n        })();\n        await renderPromise;\n        renderPromise = undefined;\n        if (pageContext._isFirstRenderAttempt) {\n            assertHook(pageContext, 'onHydrationEnd');\n            const { onHydrationEnd } = pageContext.exports;\n            if (onHydrationEnd) {\n                const hookFilePath = pageContext.exportsAll.onHydrationEnd[0].exportSource;\n                assert(hookFilePath);\n                await executeHook(() => onHydrationEnd(pageContext), 'onHydrationEnd', hookFilePath);\n            }\n        }\n        else if (renderingNumber === renderingCounter) {\n            if (pageContext.exports.onPageTransitionEnd) {\n                assertHook(pageContext, 'onPageTransitionEnd');\n                pageContext.exports.onPageTransitionEnd(pageContext);\n            }\n            isTransitioning = false;\n        }\n        setScrollPosition(scrollTarget);\n        browserNativeScrollRestoration_disable();\n        globalObject.initialRenderIsDone = true;\n    }\n}\nfunction onLinkClick(callback) {\n    document.addEventListener('click', onClick);\n    return;\n    // Code adapted from https://github.com/HenrikJoreteg/internal-nav-helper/blob/5199ec5448d0b0db7ec63cf76d88fa6cad878b7d/src/index.js#L11-L29\n    function onClick(ev) {\n        if (!isNormalLeftClick(ev))\n            return;\n        const linkTag = findLinkTag(ev.target);\n        if (!linkTag)\n            return;\n        const url = linkTag.getAttribute('href');\n        if (skipLink(linkTag))\n            return;\n        assert(url);\n        ev.preventDefault();\n        const keepScrollPosition = ![null, 'false'].includes(linkTag.getAttribute('keep-scroll-position'));\n        callback(url, { keepScrollPosition });\n    }\n    function isNormalLeftClick(ev) {\n        return ev.button === 0 && !ev.ctrlKey && !ev.shiftKey && !ev.altKey && !ev.metaKey;\n    }\n    function findLinkTag(target) {\n        while (target.tagName !== 'A') {\n            const { parentNode } = target;\n            if (!parentNode) {\n                return null;\n            }\n            target = parentNode;\n        }\n        return target;\n    }\n}\nfunction onBrowserHistoryNavigation(callback) {\n    // The `event` of `window.addEventListener('popstate', (event) => /*...*/)` is useless:\n    //  - The History API doesn't provide the previous state (the popped state): https://stackoverflow.com/questions/48055323/is-history-state-always-the-same-as-popstate-event-state\n    window.addEventListener('popstate', () => {\n        const currentState = getState();\n        const scrollTarget = currentState.historyState.scrollPosition || 'scroll-to-top-or-hash';\n        const isHashNavigation = currentState.urlWithoutHash === globalObject.previousState.urlWithoutHash;\n        const isBackwardNavigation = !currentState.historyState.timestamp || !globalObject.previousState.historyState.timestamp\n            ? null\n            : currentState.historyState.timestamp < globalObject.previousState.historyState.timestamp;\n        globalObject.previousState = currentState;\n        if (isHashNavigation) {\n            // - `history.state` is uninitialized (`null`) when:\n            //   - The vite-plugin-ssr app runs `window.location.hash = '#section'`.\n            //   - The user clicks on an anchor link `<a href=\"#section\">Section</a>`. (Because vite-plugin-ssr's `onLinkClick()` handler skips hash links.)\n            // - `history.state` is `null` when uninitialized: https://developer.mozilla.org/en-US/docs/Web/API/History/state\n            // - Alternatively, we completely take over hash navigation and reproduce the browser's native behavior upon hash navigation.\n            //   - Problem: we cannot intercept `window.location.hash = '#section'`. (Or maybe we can with the `hashchange` event?)\n            //   - Other potential problem: would there be a conflict when the user wants to override the browser's default behavior? E.g. for smooth scrolling, or when using hashes for saving states of some fancy animations.\n            // - Another alternative: we use the browser's scroll restoration mechanism (see `browserNativeScrollRestoration_enable()` below).\n            //   - Problem: not clear when to call `browserNativeScrollRestoration_disable()`/`browserNativeScrollRestoration_enable()`\n            //   - Other potential problem are inconsistencies between browsers: specification says that setting `window.history.scrollRestoration` only affects the current entry in the session history. But this seems to contradict what folks saying.\n            //     - Specification: https://html.spec.whatwg.org/multipage/history.html#the-history-interface\n            //     - https://stackoverflow.com/questions/70188241/history-scrollrestoration-manual-doesnt-prevent-safari-from-restoring-scrol\n            if (window.history.state === null) {\n                // The browser already scrolled to `#${hash}` => the current scroll position is the right one => we save it with `initHistoryState()`.\n                initHistoryState();\n                globalObject.previousState = getState();\n            }\n            else {\n                // If `history.state !== null` then it means that `popstate` was triggered by the user clicking on his browser's forward/backward history button.\n                setScrollPosition(scrollTarget);\n            }\n        }\n        else {\n            // Fetch & render new page\n            callback(scrollTarget, isBackwardNavigation);\n        }\n    });\n}\nfunction changeUrl(url, overwriteLastHistoryEntry) {\n    if (getCurrentUrl() === url)\n        return;\n    browserNativeScrollRestoration_disable();\n    pushHistory(url, overwriteLastHistoryEntry);\n    globalObject.previousState = getState();\n}\nfunction getState() {\n    return {\n        urlWithoutHash: getCurrentUrl({ withoutHash: true }),\n        historyState: getHistoryState()\n    };\n}\nfunction setScrollPosition(scrollTarget) {\n    if (scrollTarget === 'preserve-scroll') {\n        return;\n    }\n    let scrollPosition;\n    if (scrollTarget === 'scroll-to-top-or-hash') {\n        const hash = getUrlHash();\n        // We replicate the browser's native behavior\n        if (hash && hash !== 'top') {\n            const hashTarget = document.getElementById(hash) || document.getElementsByName(hash)[0];\n            if (hashTarget) {\n                hashTarget.scrollIntoView();\n                return;\n            }\n        }\n        scrollPosition = { x: 0, y: 0 };\n    }\n    else {\n        assert('x' in scrollTarget && 'y' in scrollTarget);\n        scrollPosition = scrollTarget;\n    }\n    setScroll(scrollPosition);\n}\n/** Change the browser's scoll position, in a way that works during a repaint. */\nfunction setScroll(scrollPosition) {\n    const scroll = () => window.scrollTo(scrollPosition.x, scrollPosition.y);\n    const done = () => window.scrollX === scrollPosition.x && window.scrollY === scrollPosition.y;\n    // In principle, this `done()` call should force the repaint to be finished. But that doesn't seem to be the case with `Firefox 97.0.1`.\n    if (done())\n        return;\n    scroll();\n    // Because `done()` doesn't seem to always force the repaint to be finished, we potentially need to retry again.\n    if (done())\n        return;\n    requestAnimationFrame(() => {\n        scroll();\n        if (done())\n            return;\n        setTimeout(async () => {\n            scroll();\n            if (done())\n                return;\n            // In principle, `requestAnimationFrame() -> setTimeout(, 0)` should be enough.\n            //  - https://stackoverflow.com/questions/61281139/waiting-for-repaint-in-javascript\n            //  - But it's not enough for `Firefox 97.0.1`.\n            //  - The following strategy is very agressive. It doesn't need to be that aggressive for Firefox. But we do it to be safe.\n            const start = new Date().getTime();\n            while (true) {\n                await sleep(10);\n                scroll();\n                if (done())\n                    return;\n                const millisecondsElapsed = new Date().getTime() - start;\n                if (millisecondsElapsed > 100)\n                    return;\n            }\n        }, 0);\n    });\n}\nfunction autoSaveScrollPosition() {\n    // Safari cannot handle more than 100 `history.replaceState()` calls within 30 seconds (https://github.com/brillout/vite-plugin-ssr/issues/46)\n    window.addEventListener('scroll', throttle(saveScrollPosition, Math.ceil(1000 / 3)), { passive: true });\n    onPageHide(saveScrollPosition);\n}\nfunction getUrlHash() {\n    let { hash } = window.location;\n    if (hash === '')\n        return null;\n    assert(hash.startsWith('#'));\n    hash = hash.slice(1);\n    return hash;\n}\n// We use the browser's native scroll restoration mechanism only for the first render\nfunction setupNativeScrollRestoration() {\n    browserNativeScrollRestoration_enable();\n    onPageHide(browserNativeScrollRestoration_enable);\n    onPageShow(() => globalObject.initialRenderIsDone && browserNativeScrollRestoration_disable());\n}\nfunction browserNativeScrollRestoration_disable() {\n    if ('scrollRestoration' in window.history) {\n        window.history.scrollRestoration = 'manual';\n    }\n}\nfunction browserNativeScrollRestoration_enable() {\n    if ('scrollRestoration' in window.history) {\n        window.history.scrollRestoration = 'auto';\n    }\n}\nfunction onPageHide(listener) {\n    window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'hidden') {\n            listener();\n        }\n    });\n}\nfunction onPageShow(listener) {\n    window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'visible') {\n            listener();\n        }\n    });\n}\nfunction shouldSwallowAndInterrupt(err, pageContext) {\n    if (isAlreadyServerSideRouted(err))\n        return true;\n    if (handleErrorFetchingStaticAssets(err, pageContext))\n        return true;\n    return false;\n}\nfunction handleErrorFetchingStaticAssets(err, pageContext) {\n    if (!isErrorFetchingStaticAssets(err)) {\n        return false;\n    }\n    if (pageContext._isFirstRenderAttempt) {\n        disableClientRouting(err, false);\n        // This may happen if the frontend was newly deployed during hydration.\n        // Ideally: re-try a couple of times by reloading the page (not entirely trivial to implement since `localStorage` is needed.)\n        throw err;\n    }\n    else {\n        disableClientRouting(err, true);\n    }\n    serverSideRouteTo(pageContext.urlOriginal);\n    return true;\n}\nfunction isDisableAutomaticLinkInterception() {\n    // @ts-ignore\n    return !!window._disableAutomaticLinkInterception;\n    /* globalObject should be used if we want to make disableAutomaticLinkInterception a page-by-page setting\n    return globalObject.disableAutomaticLinkInterception ?? false\n    */\n}\n","import { assertClientRouting } from '../../utils/assertRoutingType';\nassertClientRouting();\nimport './pageFiles';\nimport { useClientRouter } from './useClientRouter';\nimport { onClientEntry_ClientRouting } from './utils';\nonClientEntry_ClientRouting(import.meta.env.PROD);\nuseClientRouter();\n"],"file":"assets/entries/entry-client-routing.e48048ee.js"}