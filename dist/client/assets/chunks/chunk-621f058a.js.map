{"version":3,"file":"chunk-621f058a.js","sources":["../../../../node_modules/vite-plugin-ssr/dist/esm/utils/getUrlPathname.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isExternalLink.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isPlainObject.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isReact.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isSameErrorMessage.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/serverSideRouteTo.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/sleep.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/throttle.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/utils.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/navigate.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/stringifyStringArray.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/hasPropertyGetter.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isPromise.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isObjectWithKeys.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/isStringRecord.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/utils.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/deduceRouteStringFromFilesystemPath.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/loadPageRoutes.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/addComputedUrlProps.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/resolveRouteString.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/resolvePrecedence.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/resolveRouteFunction.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/assertPageContextProvidedByUser.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/callOnBeforeRouteHook.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/debug.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/index.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/getBaseServer.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/createPageContext.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/getPageId.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide/getExportNames.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide/analyzeExports.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide/determineClientEntry.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageClientSide.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzeClientSide.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/skipLink/isClientSideRoutable.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/skipLink.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/prefetch/getPrefetchSettings.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/prefetch/alreadyPrefetched.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/navigationState.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageFiles/analyzePageServerSide.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/getPageContext/removeBuiltInOverrides.js","../../../../node_modules/vite-plugin-ssr/dist/esm/utils/urlToFile.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/getPageContextRequestUrl.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/assertObjectKeys.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/assertOnBeforeRenderHookReturn.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/getPageContext.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/history.js","../../../../node_modules/vite-plugin-ssr/dist/esm/shared/route/RenderErrorPage.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/useClientRouter.js","../../../../node_modules/vite-plugin-ssr/dist/esm/client/router/prefetch.js"],"sourcesContent":["export { getUrlPathname };\nimport { parseUrl } from './parseUrl';\nfunction getUrlPathname(url) {\n    const urlPathname = parseUrl(url, '/').pathname;\n    return urlPathname;\n}\n","export { isExternalLink };\nfunction isExternalLink(url) {\n    return !url.startsWith('/') && !url.startsWith('.') && !url.startsWith('?') && url !== '';\n}\n","export { isPlainObject };\nfunction isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    // Support `Object.create(null)`\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    return (\n    /* Doesn't work in Cloudlfare Pages workers\n    value.constructor === Object\n    */\n    value.constructor.name === 'Object');\n}\n","// There doesn't seem to be a reliable way to detect React:\n//  - https://stackoverflow.com/questions/73156433/detect-with-javascript-whether-the-website-is-using-react\nexport function isReact() {\n    var _a, _b, _c, _d;\n    // Heuristic using values set by React (Dev Tools)\n    // - `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` is an internal API for React Dev Tools\n    //   - https://stackoverflow.com/questions/46807826/how-does-react-developer-tools-determine-that-the-webpage-is-using-react/46808361#46808361\n    //   - In principle, `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` should exist only if React Dev Tools is installed. (Although it seems that it's sometimes defined even when React Dev Tools isn't installed; I don't know why.)\n    // - We use `isReact1`/`isReact2` merely to validate `isReact3` and `isReact4`. Because `isReact1`/`isReact2` can be false negatives:\n    //   - React populates `__REACT_DEVTOOLS_GLOBAL_HOOK__.renderers` fairly late => false negative early in the rendering phase\n    //   - `window.__REACT_DEVTOOLS_GLOBAL_HOOK__` is `undefined` if React Dev Tools isn't installed => false negative\n    const isReact1 = !!((_b = (_a = window.__REACT_DEVTOOLS_GLOBAL_HOOK__) === null || _a === void 0 ? void 0 : _a.renderers) === null || _b === void 0 ? void 0 : _b.size);\n    const isReact2 = !!((_d = (_c = window.__REACT_DEVTOOLS_GLOBAL_HOOK__) === null || _c === void 0 ? void 0 : _c.rendererInterfaces) === null || _d === void 0 ? void 0 : _d.size);\n    // Heuristic using values set by `@vitejs/plugin-react`\n    const isReact3 = !!window.__vite_plugin_react_preamble_installed__;\n    /* Also set by Preact Vite plugin `@preact/preset-vite`\n    const isReact4 = !!(window as any).$RefreshReg$\n    */\n    // console.log({ isReact1, isReact2, isReact3 })\n    return isReact1 || isReact2 || isReact3;\n}\n","export { isSameErrorMessage };\nfunction isSameErrorMessage(err1, err2) {\n    return (err1 === null || err1 === void 0 ? void 0 : err1.message) === (err2 === null || err2 === void 0 ? void 0 : err2.message);\n}\n","export { serverSideRouteTo };\nfunction serverSideRouteTo(url) {\n    window.location.href = url;\n}\n","export { sleep };\nfunction sleep(milliseconds) {\n    return new Promise((r) => setTimeout(r, milliseconds));\n}\n","export { throttle };\nfunction throttle(func, waitTime) {\n    let isQueued = false;\n    return () => {\n        if (!isQueued) {\n            isQueued = true;\n            setTimeout(() => {\n                isQueued = false;\n                func();\n            }, waitTime);\n        }\n    };\n}\n","// Utils needed by Client Routing.\n// Ensure we don't bloat the server-side with client utils\nimport { isBrowser } from '../../utils/isBrowser';\nimport { assert } from '../../utils/assert';\nassert(isBrowser());\n// Ensure we don't bloat Server Routing with Client Routing utils\nimport { assertClientRouting } from '../../utils/assertRoutingType';\nassertClientRouting();\n// We load the Server Routing utils: we tolerate the tiny amount of code that is only needed by Server Routing (only 1-2 lines).\n// We re-export some of the utils down below only to list the utils needed by Client Routing.\nexport * from '../../client/utils';\nexport * from '../../utils/assert';\nexport * from '../../utils/assertSingleInstance';\nexport * from '../../utils/callHookWithTimeout';\nexport * from '../../utils/getCurrentUrl';\nexport * from '../../utils/getGlobalObject';\nexport * from '../../utils/getUrlPathname';\nexport * from '../../utils/hasProp';\nexport * from '../../utils/isBrowser';\nexport * from '../../utils/isCallable';\nexport * from '../../utils/isExternalLink';\nexport * from '../../utils/isObject';\nexport * from '../../utils/isPlainObject';\nexport * from '../../utils/isReact';\nexport * from '../../utils/isSameErrorMessage';\nexport * from '../../utils/objectAssign';\nexport * from '../../utils/parseUrl';\nexport * from '../../utils/projectInfo';\nexport * from '../../utils/PromiseType';\nexport * from '../../utils/serverSideRouteTo';\nexport * from '../../utils/sleep';\nexport * from '../../utils/slice';\nexport * from '../../utils/throttle';\nexport * from '../../utils/assertRoutingType';\n","export { navigate };\nexport { defineNavigate };\nimport { assertUsage, isBrowser, getGlobalObject, assertClientRouting, checkIfClientRouting } from './utils';\nassertClientRouting();\nconst globalObject = getGlobalObject('navigate.ts', {});\n/** Programmatically navigate to a new page, see https://vite-plugin-ssr.com/navigate\n * @param url - The URL of the new page.\n * @param keepScrollPosition - Don't scroll to the top of the page, instead keep the current scroll position.\n * @param overwriteLastHistoryEntry - Don't create a new entry in the browser's history, instead let the new URL replace the current URL. (This effectively removes the current URL from the browser history).\n */\nasync function navigate(url, { keepScrollPosition = false, overwriteLastHistoryEntry = false } = {}) {\n    assertUsage(isBrowser(), '[`navigate(url)`] The `navigate(url)` function is only callable in the browser but you are calling it in Node.js.');\n    const errMsg = 'navigate() only works with Client Routing, see https://vite-plugin-ssr.com/navigate';\n    assertUsage(globalObject.navigate, errMsg);\n    assertUsage(checkIfClientRouting(), errMsg);\n    assertUsage(url, '[navigate(url)] Missing argument `url`.');\n    assertUsage(typeof url === 'string', '[navigate(url)] Argument `url` should be a string (but we got `typeof url === \"' + typeof url + '\"`.');\n    assertUsage(typeof keepScrollPosition === 'boolean', '[navigate(url, { keepScrollPosition })] Argument `keepScrollPosition` should be a boolean (but we got `typeof keepScrollPosition === \"' +\n        typeof keepScrollPosition +\n        '\"`.');\n    assertUsage(typeof overwriteLastHistoryEntry === 'boolean', '[navigate(url, { overwriteLastHistoryEntry })] Argument `overwriteLastHistoryEntry` should be a boolean (but we got `typeof keepScrollPosition === \"' +\n        typeof overwriteLastHistoryEntry +\n        '\"`.');\n    assertUsage(url.startsWith('/'), '[navigate(url)] Argument `url` should start with a leading `/`.');\n    await globalObject.navigate(url, { keepScrollPosition, overwriteLastHistoryEntry });\n}\nfunction defineNavigate(navigate_) {\n    globalObject.navigate = navigate_;\n}\n","export { stringifyStringArray };\nfunction stringifyStringArray(stringList) {\n    return '[' + stringList.map((str) => \"'\" + str + \"'\").join(', ') + ']';\n}\n","export function hasPropertyGetter(obj, prop) {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n    return !!descriptor && !('value' in descriptor) && !!descriptor.get;\n}\n","import { isCallable } from './isCallable';\nexport function isPromise(val) {\n    return typeof val === 'object' && val !== null && 'then' in val && isCallable(val.then);\n}\n","import { isPlainObject } from './isPlainObject';\nexport { isObjectWithKeys };\nfunction isObjectWithKeys(obj, keys) {\n    if (!isPlainObject(obj)) {\n        return false;\n    }\n    for (const key of Object.keys(obj)) {\n        if (!keys.includes(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n","export function isStringRecord(thing) {\n    return typeof thing === 'object' && thing !== null && Object.values(thing).every((val) => typeof val === 'string');\n}\n","// Utils needed by:\n//  - runtime of server\n//  - runtime of client (Client Routing)\n// Ensure we don't bloat runtime of Server Routing with the utils down below\nimport { assertClientRouting } from '../../utils/assertRoutingType';\nimport { isBrowser } from '../../utils/isBrowser';\nif (isBrowser()) {\n    assertClientRouting();\n}\nexport * from '../../utils/assert';\nexport * from '../../utils/hasProp';\nexport * from '../../utils/isObjectWithKeys';\nexport * from '../../utils/sorter';\nexport * from '../../utils/isPromise';\nexport * from '../../utils/isPlainObject';\nexport * from '../../utils/objectAssign';\nexport * from '../../utils/slice';\nexport * from '../../utils/isStringRecord';\nexport * from '../../utils/unique';\nexport * from '../../utils/isBrowser';\nexport * from '../../utils/parseUrl';\n","// Unit tests at ./deduceRouteStringFromFilesystemPath.spec.ts\nimport { assert, higherFirst, slice } from './utils';\nexport { deduceRouteStringFromFilesystemPath };\n// TODO/next-major-update: remove this and whole filesystemRoot mechanism\nfunction deduceRouteStringFromFilesystemPath(pageId, filesystemRoots) {\n    // Handle Filesystem Routing Root\n    const filesystemRootsMatch = filesystemRoots\n        .filter(({ filesystemRoot }) => pageId.startsWith(filesystemRoot))\n        .sort(higherFirst(({ filesystemRoot }) => filesystemRoot.length));\n    const fsBase = filesystemRootsMatch[0];\n    let filesystemRoute;\n    if (fsBase) {\n        // Example values:\n        //  - `{\"pageId\":\"/pages/index\",\"filesystemRoot\":\"/\",\"urlRoot\":\"/client_portal\"}`\n        const { filesystemRoot, urlRoot } = fsBase;\n        const debugInfo = { pageId, filesystemRoot, urlRoot };\n        assert(urlRoot.startsWith('/') && pageId.startsWith('/') && filesystemRoot.startsWith('/'), debugInfo);\n        assert(pageId.startsWith(filesystemRoot), debugInfo);\n        if (filesystemRoot !== '/') {\n            assert(!filesystemRoot.endsWith('/'), debugInfo);\n            filesystemRoute = slice(pageId, filesystemRoot.length, 0);\n        }\n        else {\n            filesystemRoute = pageId;\n        }\n        assert(filesystemRoute.startsWith('/'), debugInfo);\n        filesystemRoute = urlRoot + (urlRoot.endsWith('/') ? '' : '/') + slice(filesystemRoute, 1, 0);\n    }\n    else {\n        filesystemRoute = pageId;\n    }\n    assert(filesystemRoute.startsWith('/'));\n    // Remove `pages/`, `index/, and `src/`, directories\n    filesystemRoute = filesystemRoute\n        .split('/')\n        .filter((dir) => dir !== 'pages' && dir !== 'src' && dir !== 'index')\n        .join('/');\n    // Hanlde `/index.page.*` suffix\n    assert(!filesystemRoute.includes('.page.'));\n    assert(!filesystemRoute.endsWith('.'));\n    if (filesystemRoute.endsWith('/index')) {\n        filesystemRoute = slice(filesystemRoute, 0, -'/index'.length);\n    }\n    if (filesystemRoute === '') {\n        filesystemRoute = '/';\n    }\n    assert(filesystemRoute.startsWith('/'));\n    assert(!filesystemRoute.endsWith('/') || filesystemRoute === '/');\n    return filesystemRoute;\n}\n","import { isErrorPageId } from '../error-page';\nimport { assert, assertUsage, hasProp, slice } from './utils';\nimport { deduceRouteStringFromFilesystemPath } from './deduceRouteStringFromFilesystemPath';\nimport { isCallable } from '../utils';\nexport { loadPageRoutes };\nexport { findPageRouteFile };\nasync function loadPageRoutes(\n// TODO: remove all arguments and use GlobalContext instead\npageFilesAll, pageConfigs, pageConfigGlobal, allPageIds) {\n    await Promise.all(pageFilesAll.filter((p) => p.fileType === '.page.route').map((p) => { var _a; return (_a = p.loadFile) === null || _a === void 0 ? void 0 : _a.call(p); }));\n    const { onBeforeRouteHook, filesystemRoots } = getGlobalHooks(pageFilesAll, pageConfigs, pageConfigGlobal);\n    const pageRoutes = getPageRoutes(filesystemRoots, pageFilesAll, pageConfigs, allPageIds);\n    return { pageRoutes, onBeforeRouteHook };\n}\nfunction getPageRoutes(filesystemRoots, pageFilesAll, pageConfigs, allPageIds) {\n    const pageRoutes = [];\n    let pageIds = [...allPageIds];\n    // V1 Design\n    if (pageConfigs.length > 0) {\n        assert(filesystemRoots === null);\n        const comesFromV1PageConfig = true;\n        pageConfigs\n            .filter((p) => !p.isErrorPage)\n            .forEach((pageConfig) => {\n            const pageId = pageConfig.pageId;\n            pageIds = removePageId(pageIds, pageId);\n            let pageRoute = null;\n            {\n                const routeConfig = pageConfig.configElements.route;\n                if (routeConfig) {\n                    assert('configValue' in routeConfig); // Route files are eagerly loaded\n                    const route = routeConfig.configValue;\n                    const routeDefinedAt = routeConfig.configDefinedAt;\n                    assert(routeDefinedAt);\n                    if (typeof route === 'string') {\n                        pageRoute = { pageId, comesFromV1PageConfig, routeString: route, routeDefinedAt, routeType: 'STRING' };\n                    }\n                    else {\n                        assert(isCallable(route));\n                        let allowAsync = false;\n                        const allowSyncConfig = pageConfig.configElements.iKnowThePerformanceRisksOfAsyncRouteFunctions;\n                        if (allowSyncConfig) {\n                            const val = allowSyncConfig.configValue;\n                            assert(typeof val === 'boolean', `${allowSyncConfig.configDefinedAt} should be a boolean`);\n                            allowAsync = val;\n                        }\n                        pageRoute = {\n                            pageId,\n                            comesFromV1PageConfig,\n                            routeFunction: route,\n                            routeDefinedAt,\n                            routeType: 'FUNCTION',\n                            allowAsync\n                        };\n                    }\n                }\n            }\n            if (!pageRoute) {\n                const { routeFilesystem, routeFilesystemDefinedBy } = pageConfig;\n                assert(routeFilesystem);\n                assert(routeFilesystem.startsWith('/'));\n                assert(routeFilesystemDefinedBy);\n                pageRoute = {\n                    pageId,\n                    routeFilesystemDefinedBy,\n                    comesFromV1PageConfig,\n                    routeString: routeFilesystem,\n                    routeDefinedAt: null,\n                    routeType: 'FILESYSTEM'\n                };\n            }\n            assert(pageRoute);\n            pageRoutes.push(pageRoute);\n        });\n    }\n    // Old design\n    // TODO/v1-release: remove\n    if (pageConfigs.length === 0) {\n        assert(filesystemRoots);\n        const comesFromV1PageConfig = false;\n        pageIds\n            .filter((pageId) => !isErrorPageId(pageId, false))\n            .forEach((pageId) => {\n            const pageRouteFile = findPageRouteFile(pageId, pageFilesAll);\n            if (!pageRouteFile) {\n                const routeString = deduceRouteStringFromFilesystemPath(pageId, filesystemRoots);\n                assert(routeString.startsWith('/'));\n                assert(!routeString.endsWith('/') || routeString === '/');\n                pageRoutes.push({\n                    pageId,\n                    comesFromV1PageConfig,\n                    routeString,\n                    routeDefinedAt: null,\n                    routeFilesystemDefinedBy: `${pageId}.page.*`,\n                    routeType: 'FILESYSTEM'\n                });\n            }\n            else {\n                const { filePath, fileExports } = pageRouteFile;\n                assert(fileExports);\n                assertUsage('default' in fileExports, `${filePath} should have a default export.`);\n                if (hasProp(fileExports, 'default', 'string')) {\n                    const routeString = fileExports.default;\n                    assertUsage(routeString.startsWith('/'), `A Route String should start with a leading \\`/\\` but \\`${filePath}\\` has \\`export default '${routeString}'\\`. Make sure to \\`export default '/${routeString}'\\` instead.`);\n                    pageRoutes.push({\n                        pageId,\n                        comesFromV1PageConfig,\n                        routeString,\n                        routeDefinedAt: filePath,\n                        routeType: 'STRING'\n                    });\n                    return;\n                }\n                if (hasProp(fileExports, 'default', 'function')) {\n                    const routeFunction = fileExports.default;\n                    let allowAsync = false;\n                    const allowKey = 'iKnowThePerformanceRisksOfAsyncRouteFunctions';\n                    if (allowKey in fileExports) {\n                        assertUsage(hasProp(fileExports, allowKey, 'boolean'), `The export \\`${allowKey}\\` of ${filePath} should be a boolean.`);\n                        allowAsync = fileExports[allowKey];\n                    }\n                    pageRoutes.push({\n                        pageId,\n                        comesFromV1PageConfig,\n                        routeFunction,\n                        routeDefinedAt: filePath,\n                        allowAsync,\n                        routeType: 'FUNCTION'\n                    });\n                    return;\n                }\n                assertUsage(false, `The default export of ${filePath} should be a string or a function.`);\n            }\n        });\n    }\n    return pageRoutes;\n}\nfunction getGlobalHooks(pageFilesAll, pageConfigs, pageConfigGlobal) {\n    // V1 Design\n    if (pageConfigs.length > 0) {\n        if (pageConfigGlobal.onBeforeRoute) {\n            const hookFn = pageConfigGlobal.onBeforeRoute.configValue;\n            if (hookFn) {\n                const hookFilePath = pageConfigGlobal.onBeforeRoute.codeFilePath;\n                assert(hookFilePath);\n                assertUsage(isCallable(hookFn), `The hook onBeforeRoute() defined by ${hookFilePath} should be a function.`);\n                const onBeforeRouteHook = {\n                    hookFilePath: hookFilePath,\n                    onBeforeRoute: hookFn\n                };\n                return { onBeforeRouteHook, filesystemRoots: null };\n            }\n        }\n        return { onBeforeRouteHook: null, filesystemRoots: null };\n    }\n    // Old design\n    // TODO/v1-release: remove\n    let onBeforeRouteHook = null;\n    const filesystemRoots = [];\n    pageFilesAll\n        .filter((p) => p.fileType === '.page.route' && p.isDefaultPageFile)\n        .forEach(({ filePath, fileExports }) => {\n        assert(fileExports);\n        if ('onBeforeRoute' in fileExports) {\n            assertUsage(hasProp(fileExports, 'onBeforeRoute', 'function'), `\\`export { onBeforeRoute }\\` of ${filePath} should be a function.`);\n            const { onBeforeRoute } = fileExports;\n            onBeforeRouteHook = { hookFilePath: `${filePath} > \\`export { onBeforeRoute }\\``, onBeforeRoute };\n        }\n        if ('filesystemRoutingRoot' in fileExports) {\n            assertUsage(hasProp(fileExports, 'filesystemRoutingRoot', 'string'), `\\`export { filesystemRoutingRoot }\\` of ${filePath} should be a string.`);\n            assertUsage(hasProp(fileExports, 'filesystemRoutingRoot', 'string'), `\\`export { filesystemRoutingRoot }\\` of ${filePath} is \\`'${fileExports.filesystemRoutingRoot}'\\` but it should start with a leading slash \\`/\\`.`);\n            filesystemRoots.push({\n                filesystemRoot: dirname(filePath),\n                urlRoot: fileExports.filesystemRoutingRoot\n            });\n        }\n    });\n    return { onBeforeRouteHook, filesystemRoots };\n}\nfunction findPageRouteFile(pageId, pageFilesAll) {\n    return pageFilesAll.find((p) => p.pageId === pageId && p.fileType === '.page.route');\n}\nfunction dirname(filePath) {\n    assert(filePath.startsWith('/'));\n    assert(!filePath.endsWith('/'));\n    const paths = filePath.split('/');\n    const dirPath = slice(paths, 0, -1).join('/') || '/';\n    assert(dirPath.startsWith('/'));\n    assert(!dirPath.endsWith('/') || dirPath === '/');\n    return dirPath;\n}\nfunction removePageId(pageIds, pageId) {\n    const { length } = pageIds;\n    pageIds = pageIds.filter((id) => id !== pageId);\n    assert(pageIds.length === length - 1);\n    return pageIds;\n}\n","import { assert, parseUrl, assertWarning, isPlainObject, hasPropertyGetter } from './utils';\nexport { addComputedUrlProps };\nexport { assertURLs };\nfunction addComputedUrlProps(pageContext, enumerable = true) {\n    assert(pageContext.urlOriginal);\n    if ('urlPathname' in pageContext) {\n        assert(hasPropertyGetter(pageContext, 'urlPathname'));\n    }\n    Object.defineProperty(pageContext, 'urlPathname', {\n        get: urlPathnameGetter,\n        enumerable,\n        configurable: true\n    });\n    // TODO/v1-release: move pageContext.urlParsed to pageContext.url\n    if ('url' in pageContext)\n        assert(hasPropertyGetter(pageContext, 'url'));\n    Object.defineProperty(pageContext, 'url', {\n        get: urlGetter,\n        enumerable: false,\n        configurable: true\n    });\n    if ('urlParsed' in pageContext) {\n        assert(hasPropertyGetter(pageContext, 'urlParsed'));\n    }\n    Object.defineProperty(pageContext, 'urlParsed', {\n        get: urlParsedGetter,\n        enumerable,\n        configurable: true\n    });\n}\nfunction getUrlParsed(pageContext) {\n    let urlHandler = pageContext._urlHandler;\n    if (!urlHandler) {\n        urlHandler = (urlOriginal) => urlOriginal;\n    }\n    const url = urlHandler(pageContext.urlOriginal);\n    const baseServer = pageContext._baseServer;\n    assert(baseServer.startsWith('/'));\n    return parseUrl(url, baseServer);\n}\nfunction urlPathnameGetter() {\n    const { pathname } = getUrlParsed(this);\n    const urlPathname = pathname;\n    assert(urlPathname.startsWith('/'));\n    return urlPathname;\n}\nfunction urlGetter() {\n    assertWarning(false, '`pageContext.url` is outdated. Use `pageContext.urlPathname`, `pageContext.urlParsed`, or `pageContext.urlOriginal` instead. (See https://vite-plugin-ssr.com/migration/0.4.23 for more information.)', { onlyOnce: true, showStackTrace: true });\n    return urlPathnameGetter.call(this);\n}\nfunction urlParsedGetter() {\n    const urlParsedOriginal = getUrlParsed(this);\n    const { origin, pathname, pathnameOriginal, search, searchAll, searchOriginal, hash, hashOriginal } = urlParsedOriginal;\n    const urlParsed = {\n        origin,\n        pathname,\n        pathnameOriginal,\n        search,\n        searchAll,\n        searchOriginal,\n        hash,\n        hashOriginal,\n        get hashString() {\n            assertWarning(false, '`pageContext.urlParsed.hashString` has been renamed to `pageContext.urlParsed.hashOriginal`', { onlyOnce: true, showStackTrace: true });\n            return hashOriginal;\n        },\n        get searchString() {\n            assertWarning(false, '`pageContext.urlParsed.searchString` has been renamed to `pageContext.urlParsed.searchOriginal`', { onlyOnce: true, showStackTrace: true });\n            return searchOriginal;\n        }\n    };\n    makeNonEnumerable(urlParsed, 'hashString');\n    makeNonEnumerable(urlParsed, 'searchString');\n    return urlParsed;\n}\nfunction makeNonEnumerable(obj, prop) {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n    Object.defineProperty(obj, prop, { ...descriptor, enumerable: false });\n}\nfunction assertURLs(pageContext) {\n    assert(typeof pageContext.urlOriginal === 'string');\n    assert(typeof pageContext.urlPathname === 'string');\n    assert(isPlainObject(pageContext.urlParsed));\n    assert(pageContext.urlPathname === pageContext.urlParsed.pathname);\n}\n","// Unit tests at ./resolveRouteString.spec.ts\nexport { resolveRouteString };\nexport { getUrlFromRouteString };\nexport { isStaticRouteString };\nexport { analyzeRouteString };\n// export { assertRouteString }\nimport { assertWarning } from '../utils';\nimport { assert, assertUsage } from './utils';\nconst PARAM_TOKEN_NEW = '@';\nconst PARAM_TOKEN_OLD = ':';\nfunction assertRouteString(routeString, errMsgPrefix) {\n    assertUsage(routeString.startsWith('/') || routeString === '*', (() => {\n        if (!errMsgPrefix) {\n            errMsgPrefix = 'Invalid';\n        }\n        else {\n            errMsgPrefix = errMsgPrefix + ' invalid';\n        }\n        const routeStr = [`'${routeString}'`, routeString !== '' ? null : '(empty string)'].filter(Boolean).join(' ');\n        const errMsg = `${errMsgPrefix} Route String ${routeStr}: Route Strings should start with a leading slash '/' (or be '*')`;\n        return errMsg;\n    })());\n}\nfunction resolveRouteString(routeString, urlPathname) {\n    assertRouteString(routeString);\n    assert(urlPathname.startsWith('/'));\n    const routeSegments = routeString.split('/');\n    const urlSegments = urlPathname.split('/');\n    const routeParams = {};\n    assertGlob(routeString);\n    if (routeString === '*') {\n        routeString = '/*';\n    }\n    for (let i = 0; i < Math.max(routeSegments.length, urlSegments.length); i++) {\n        const routeSegment = routeSegments[i];\n        const urlSegment = urlSegments[i];\n        if (routeSegment === '*') {\n            routeParams['*'] = urlSegments.slice(Math.max(1, i)).join('/');\n            return { routeParams };\n        }\n        else if (routeSegment && isParam(routeSegment)) {\n            assertWarning(!routeSegment.startsWith(PARAM_TOKEN_OLD), `Outdated Route String \\`${routeString}\\`, use \\`${routeString\n                .split(PARAM_TOKEN_OLD)\n                .join(PARAM_TOKEN_NEW)}\\` instead.`, { showStackTrace: false, onlyOnce: true });\n            if (!urlSegment) {\n                return null;\n            }\n            routeParams[routeSegment.slice(1)] = urlSegment;\n        }\n        else {\n            if ((routeSegment || '') !== (urlSegment || '')) {\n                return null;\n            }\n        }\n    }\n    return { routeParams };\n}\nfunction getUrlFromRouteString(routeString) {\n    assert(routeString.startsWith('/'));\n    if (isStaticRouteString(routeString)) {\n        const url = routeString;\n        return url;\n    }\n    return null;\n}\nfunction assertGlob(routeString) {\n    const numberOfGlobChars = routeString.split('*').length - 1;\n    assertUsage(numberOfGlobChars <= 1, `Invalid Route String \\`${routeString}\\`: Route Strings are not allowed to contain more than one glob character \\`*\\`.`);\n    assertUsage(numberOfGlobChars === 0 || (numberOfGlobChars === 1 && routeString.endsWith('*')), `Invalid Route String \\`${routeString}\\`: make sure your Route String ends with the glob character \\`*\\`.`);\n}\nfunction analyzeRouteString(routeString) {\n    const routeSegments = routeString.split('/').filter((routeSegment) => routeSegment !== '' && routeSegment !== '*');\n    let numberOfStaticSegmentsBeginning = 0;\n    for (const routeSegment of routeSegments) {\n        if (isParam(routeSegment)) {\n            break;\n        }\n        numberOfStaticSegmentsBeginning++;\n    }\n    const numberOfStaticSegements = routeSegments.filter((s) => !isParam(s)).length;\n    const numberOfParameterSegments = routeSegments.filter((s) => isParam(s)).length;\n    const isCatchAll = routeString.endsWith('*');\n    return { numberOfParameterSegments, numberOfStaticSegmentsBeginning, numberOfStaticSegements, isCatchAll };\n}\nfunction isParam(routeSegment) {\n    return routeSegment.startsWith(PARAM_TOKEN_NEW) || routeSegment.startsWith(PARAM_TOKEN_OLD);\n}\nfunction isStaticRouteString(routeString) {\n    const url = routeString;\n    const match = resolveRouteString(routeString, url);\n    assert(match);\n    return Object.keys(match.routeParams).length === 0;\n}\n","export { resolvePrecendence };\n// export type { RouteMatch }\nimport { analyzeRouteString } from './resolveRouteString';\nimport { higherFirst } from './utils';\nimport { makeFirst } from './utils';\nimport { isStaticRouteString } from './resolveRouteString';\n// See https://vite-plugin-ssr.com/route-function#precedence\nfunction resolvePrecendence(routeMatches) {\n    // prettier-ignore\n    routeMatches\n        .sort(sortMatches)\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !!routeMatch.precedence && routeMatch.precedence < 0))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'STRING' && isStaticRouteString(routeMatch.routeString) === false))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !routeMatch.precedence))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'STRING' && isStaticRouteString(routeMatch.routeString) === true))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FILESYSTEM'))\n        .sort(makeFirst((routeMatch) => routeMatch.routeType === 'FUNCTION' && !!routeMatch.precedence && routeMatch.precedence > 0));\n}\n// -1 => routeMatch1 higher precedence\n// +1 => routeMatch2 higher precedence\nfunction sortMatches(routeMatch1, routeMatch2) {\n    var _a, _b;\n    {\n        const precedence1 = (_a = routeMatch1.precedence) !== null && _a !== void 0 ? _a : 0;\n        const precedence2 = (_b = routeMatch2.precedence) !== null && _b !== void 0 ? _b : 0;\n        if (precedence1 !== precedence2) {\n            return precedence1 > precedence2 ? -1 : 1;\n        }\n    }\n    if (!routeMatch2.routeString) {\n        return 0;\n    }\n    if (!routeMatch1.routeString) {\n        return 0;\n    }\n    // Return route with highest number of static path segments at beginning first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfStaticSegmentsBeginning;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            return result;\n        }\n    }\n    // Return route with highest number of static path segments in total first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfStaticSegements;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            return result;\n        }\n    }\n    // Return route with most parameter segements first\n    {\n        const getValue = (routeString) => analyzeRouteString(routeString).numberOfParameterSegments;\n        const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);\n        if (result !== 0) {\n            return result;\n        }\n    }\n    // Return catch-all routes last\n    {\n        if (analyzeRouteString(routeMatch2.routeString).isCatchAll) {\n            return -1;\n        }\n        if (analyzeRouteString(routeMatch1.routeString).isCatchAll) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","export { resolveRouteFunction };\nexport { assertRouteParams };\nimport { assertURLs } from '../addComputedUrlProps';\nimport { assert, assertUsage, hasProp, isPlainObject, isPromise, isStringRecord } from './utils';\nasync function resolveRouteFunction(routeFunction, allowAsync, pageContext, routeDefinedAt) {\n    assertURLs(pageContext);\n    let result = routeFunction(pageContext);\n    assertUsage(!isPromise(result) || allowAsync, `The Route Function ${routeDefinedAt} returned a promise; async route functions are opt-in, see https://vite-plugin-ssr.com/route-function#async`);\n    result = await result;\n    if (result === false) {\n        return null;\n    }\n    if (result === true) {\n        result = {};\n    }\n    assertUsage(isPlainObject(result), `The Route Function ${routeDefinedAt} should return a boolean or a plain JavaScript object, instead it returns \\`${hasProp(result, 'constructor') ? result.constructor : result}\\`.`);\n    if ('match' in result) {\n        const { match } = result;\n        assertUsage(typeof match === 'boolean', `The \\`match\\` value returned by the Route Function ${routeDefinedAt} should be a boolean.`);\n        if (!match) {\n            return null;\n        }\n    }\n    let precedence = null;\n    if ('precedence' in result) {\n        precedence = result.precedence;\n        assertUsage(typeof precedence === 'number', `The \\`precedence\\` value returned by the Route Function ${routeDefinedAt} should be a number.`);\n    }\n    assertRouteParams(result, `The \\`routeParams\\` object returned by the Route Function ${routeDefinedAt} should`);\n    const routeParams = result.routeParams || {};\n    assertUsage(!('pageContext' in result), 'Providing `pageContext` in Route Functions is prohibited, see https://vite-plugin-ssr.com/route-function#cannot-provide-pagecontext');\n    assert(isPlainObject(routeParams));\n    Object.keys(result).forEach((key) => {\n        assertUsage(key === 'match' || key === 'routeParams' || key === 'precedence', `The Route Function ${routeDefinedAt} returned an object with an unknown key \\`{ ${key} }\\`. Allowed keys: ['match', 'routeParams', 'precedence'].`);\n    });\n    return {\n        precedence,\n        routeParams\n    };\n}\nfunction assertRouteParams(result, errPrefix) {\n    assert(errPrefix.endsWith(' should'));\n    if (!hasProp(result, 'routeParams')) {\n        return;\n    }\n    assert(errPrefix.endsWith(' should'));\n    assertUsage(isPlainObject(result.routeParams), `${errPrefix} be a plain JavaScript object.`);\n    assertUsage(isStringRecord(result.routeParams), `${errPrefix} only hold string values.`);\n}\n","import { assert, assertUsage, assertWarning, isObject } from './utils';\nexport { assertPageContextProvidedByUser };\nfunction assertPageContextProvidedByUser(pageContextProvidedByUser, { hook, errorMessagePrefix, isRenderErrorPage }) {\n    const errPrefix = (() => {\n        if (errorMessagePrefix) {\n            return errorMessagePrefix;\n        }\n        else {\n            assert(hook);\n            const { hookName, hookFilePath } = hook;\n            assert(!hookName.endsWith(')'));\n            return `The \\`pageContext\\` object provided by the ${hookName}() hook defined by ${hookFilePath}`;\n        }\n    })();\n    assertUsage(isObject(pageContextProvidedByUser), `${errPrefix} should be an object instead of \\`${typeof pageContextProvidedByUser}\\``);\n    assertUsage(!('_objectCreatedByVitePluginSsr' in pageContextProvidedByUser), `${errPrefix} shouldn't be the whole \\`pageContext\\` object, see https://vite-plugin-ssr.com/pageContext-manipulation#do-not-return-entire-pagecontext`);\n    // In principle, it's possible to use `onBeforeRoute()` to override and define the whole routing.\n    // Is that a good idea to allow users to do this? Beyond deep integration with Vue Router or React Router, is there a use case for this?\n    assertWarning(!('_pageId' in pageContextProvidedByUser), `${errPrefix} sets \\`pageContext._pageId\\` which means that vite-plugin-ssr's routing is overriden. This is an experimental feature: make sure to contact a vite-plugin-ssr maintainer before using this.`, { showStackTrace: false, onlyOnce: true });\n    if (!isRenderErrorPage) {\n        assertUsage(!('is404' in pageContextProvidedByUser), `${errPrefix} sets \\`pageContext.is404\\` which is forbidden, use \\`throw RenderErrorPage()\\` instead, see https://vite-plugin-ssr.com/RenderErrorPage`);\n    }\n}\n","import { assertPageContextProvidedByUser } from '../assertPageContextProvidedByUser';\nimport { assertUsage, hasProp, isObjectWithKeys, objectAssign, assertWarning, assertUsageUrl } from './utils';\nimport { assertRouteParams } from './resolveRouteFunction';\nexport { callOnBeforeRouteHook };\nasync function callOnBeforeRouteHook(onBeforeRouteHook, pageContext) {\n    const hookReturn = await onBeforeRouteHook.onBeforeRoute(pageContext);\n    const errPrefix = `The onBeforeRoute() hook defined by ${onBeforeRouteHook.hookFilePath}`;\n    assertUsage(hookReturn === null ||\n        hookReturn === undefined ||\n        (isObjectWithKeys(hookReturn, ['pageContext']) && hasProp(hookReturn, 'pageContext')), `${errPrefix} should return \\`null\\`, \\`undefined\\`, or a plain JavaScript object \\`{ pageContext: { /* ... */ } }\\`.`);\n    if (hookReturn === null || hookReturn === undefined) {\n        return null;\n    }\n    assertUsage(hasProp(hookReturn, 'pageContext', 'object'), `${errPrefix} returned \\`{ pageContext }\\` but pageContext should be a plain JavaScript object.`);\n    if (hasProp(hookReturn.pageContext, '_pageId') && !hasProp(hookReturn.pageContext, '_pageId', 'null')) {\n        const errPrefix2 = `${errPrefix} returned \\`{ pageContext: { _pageId } }\\` but _pageId should be`;\n        assertUsage(hasProp(hookReturn.pageContext, '_pageId', 'string'), `${errPrefix2} a string or null`);\n        assertUsage(pageContext._allPageIds.includes(hookReturn.pageContext._pageId), `${errPrefix2} one of following values: \\`[${pageContext._allPageIds.map((s) => `'${s}'`).join(', ')}]\\`.`);\n    }\n    if (hasProp(hookReturn.pageContext, 'routeParams')) {\n        assertRouteParams(hookReturn.pageContext, `${errPrefix} returned \\`{ pageContext: { routeParams } }\\` but routeParams should`);\n    }\n    const pageContextAddendumHook = {};\n    if (hasProp(hookReturn.pageContext, 'url')) {\n        assertWarning(false, `${errPrefix} returned \\`{ pageContext: { url } }\\` but \\`pageContext.url\\` has been renamed to \\`pageContext.urlOriginal\\`. Return \\`{ pageContext: { urlOriginal } }\\` instead. (See https://vite-plugin-ssr.com/migration/0.4.23 for more information.)`, { showStackTrace: false, onlyOnce: true });\n        hookReturn.pageContext.urlOriginal = hookReturn.pageContext.url;\n        delete hookReturn.pageContext.url;\n    }\n    if (hasProp(hookReturn.pageContext, 'urlOriginal')) {\n        assertUsageUrl(hookReturn.pageContext.urlOriginal, `${errPrefix} returned \\`{ pageContext: { urlOriginal } }\\` but urlOriginal`);\n        objectAssign(pageContextAddendumHook, { _urlPristine: pageContext.urlOriginal });\n    }\n    assertPageContextProvidedByUser(hookReturn.pageContext, {\n        hook: { hookFilePath: onBeforeRouteHook.hookFilePath, hookName: 'onBeforeRoute' }\n    });\n    objectAssign(pageContextAddendumHook, hookReturn.pageContext);\n    return pageContextAddendumHook;\n}\n","export { debug };\nvar _debug;\nfunction debug(...args) {\n    var _a, _b;\n    if (!_debug) {\n        // We use this trick instead of `import { createDebugger } from '../../utils/debug` in order to ensure that the `debug` mechanism is only loaded on the server-side\n        _debug = (_b = (_a = globalThis).__brillout_debug_createDebugger) === null || _b === void 0 ? void 0 : _b.call(_a, 'vps:routing');\n    }\n    if (_debug) {\n        _debug(...args);\n    }\n}\n","export { route };\nexport { loadPageRoutes } from './loadPageRoutes';\n// Ensure we don't bloat runtime of Server Routing\nimport { assertClientRouting } from '../../utils/assertRoutingType';\nimport { isBrowser } from '../../utils/isBrowser';\nif (isBrowser()) {\n    assertClientRouting();\n}\nimport { assert, assertUsage, hasProp, isPlainObject, objectAssign } from './utils';\nimport { addComputedUrlProps } from '../addComputedUrlProps';\nimport { resolvePrecendence } from './resolvePrecedence';\nimport { resolveRouteString } from './resolveRouteString';\nimport { resolveRouteFunction } from './resolveRouteFunction';\nimport { callOnBeforeRouteHook } from './callOnBeforeRouteHook';\nimport { loadPageRoutes } from './loadPageRoutes';\nimport { debug } from './debug';\nasync function route(pageContext) {\n    addComputedUrlProps(pageContext);\n    const { pageRoutes, onBeforeRouteHook } = await loadPageRoutes(pageContext._pageFilesAll, pageContext._pageConfigs, pageContext._pageConfigGlobal, pageContext._allPageIds);\n    debug('Pages routes:', pageRoutes);\n    const pageContextAddendum = {};\n    if (onBeforeRouteHook) {\n        const pageContextAddendumHook = await callOnBeforeRouteHook(onBeforeRouteHook, pageContext);\n        if (pageContextAddendumHook) {\n            objectAssign(pageContextAddendum, pageContextAddendumHook);\n            if (hasProp(pageContextAddendum, '_pageId', 'string') || hasProp(pageContextAddendum, '_pageId', 'null')) {\n                // We bypass `vite-plugin-ssr`'s routing\n                if (!hasProp(pageContextAddendum, 'routeParams')) {\n                    objectAssign(pageContextAddendum, { routeParams: {} });\n                }\n                else {\n                    assert(hasProp(pageContextAddendum, 'routeParams', 'object'));\n                }\n                objectAssign(pageContextAddendum, {\n                    _routingProvidedByOnBeforeRouteHook: true,\n                    _routeMatches: 'CUSTOM_ROUTE'\n                });\n                return { pageContextAddendum };\n            }\n            // We already assign so that `pageContext.urlOriginal === pageContextAddendum.urlOriginal`; enabling the `onBeforeRoute()` hook to mutate `pageContext.urlOriginal` before routing.\n            objectAssign(pageContext, pageContextAddendum);\n        }\n    }\n    objectAssign(pageContextAddendum, {\n        _routingProvidedByOnBeforeRouteHook: false\n    });\n    // `vite-plugin-ssr`'s routing\n    const allPageIds = pageContext._allPageIds;\n    assert(allPageIds.length >= 0);\n    assertUsage(pageContext._pageFilesAll.length > 0 || pageContext._pageConfigs.length > 0, 'No *.page.js file found. You must create at least one *.page.js file.');\n    assertUsage(allPageIds.length > 0, \"You must create at least one *.page.js file that isn't _default.page.*\");\n    const { urlPathname } = pageContext;\n    assert(urlPathname.startsWith('/'));\n    const routeMatches = [];\n    await Promise.all(pageRoutes.map(async (pageRoute) => {\n        const { pageId, routeType } = pageRoute;\n        // Filesytem Routing\n        if (pageRoute.routeType === 'FILESYSTEM') {\n            const { routeString } = pageRoute;\n            const match = resolveRouteString(routeString, urlPathname);\n            if (match) {\n                const { routeParams } = match;\n                routeMatches.push({ pageId, routeParams, routeString, routeType });\n            }\n            return;\n        }\n        // Route String defined in `.page.route.js`\n        if (pageRoute.routeType === 'STRING') {\n            const { routeString } = pageRoute;\n            const match = resolveRouteString(routeString, urlPathname);\n            if (match) {\n                const { routeParams } = match;\n                assert(routeType === 'STRING');\n                routeMatches.push({\n                    pageId,\n                    routeString,\n                    routeParams,\n                    routeType\n                });\n            }\n            return;\n        }\n        // Route Function defined in `.page.route.js`\n        if (pageRoute.routeType === 'FUNCTION') {\n            const { routeFunction, allowAsync, routeDefinedAt } = pageRoute;\n            const match = await resolveRouteFunction(routeFunction, allowAsync, pageContext, routeDefinedAt);\n            if (match) {\n                const { routeParams, precedence } = match;\n                routeMatches.push({ pageId, precedence, routeParams, routeType });\n            }\n            return;\n        }\n        assert(false);\n    }));\n    resolvePrecendence(routeMatches);\n    const winner = routeMatches[0];\n    debug(`Route matches for URL \\`${urlPathname}\\` (in precedence order):`, routeMatches);\n    objectAssign(pageContextAddendum, { _routeMatches: routeMatches });\n    if (!winner) {\n        objectAssign(pageContextAddendum, {\n            _pageId: null,\n            routeParams: {}\n        });\n        return { pageContextAddendum };\n    }\n    {\n        const { routeParams } = winner;\n        assert(isPlainObject(routeParams));\n        objectAssign(pageContextAddendum, {\n            _pageId: winner.pageId,\n            routeParams: winner.routeParams\n        });\n    }\n    return { pageContextAddendum };\n}\n","import { assert } from './utils';\nexport function getBaseServer() {\n    const baseServer = import.meta.env.BASE_SERVER;\n    assert(isBaseServer(baseServer));\n    return baseServer;\n}\n// We don't use isBaseServer() defined in utils/parseUrl.ts to avoid loading the whole file in the browser\nfunction isBaseServer(baseServer) {\n    return baseServer.startsWith('/');\n}\n","export { createPageContext };\nimport { addComputedUrlProps } from '../../shared/addComputedUrlProps';\nimport { getPageFilesAll } from '../../shared/getPageFiles';\nimport { getBaseServer } from '../getBaseServer';\nimport { assert, isBaseServer, objectAssign, getGlobalObject } from './utils';\nconst globalObject = getGlobalObject('createPageContext.ts', {});\nasync function createPageContext(pageContextBase) {\n    if (!globalObject.pageFilesData) {\n        globalObject.pageFilesData = await getPageFilesAll(true);\n    }\n    const { pageFilesAll, allPageIds, pageConfigs, pageConfigGlobal } = globalObject.pageFilesData;\n    const baseServer = getBaseServer();\n    assert(isBaseServer(baseServer));\n    const pageContext = {\n        _objectCreatedByVitePluginSsr: true,\n        _urlHandler: null,\n        _baseServer: baseServer,\n        _isProduction: import.meta.env.PROD,\n        // TODO: use GlobalContext instead\n        _pageFilesAll: pageFilesAll,\n        _pageConfigs: pageConfigs,\n        _pageConfigGlobal: pageConfigGlobal,\n        _allPageIds: allPageIds\n    };\n    objectAssign(pageContext, pageContextBase);\n    addComputedUrlProps(pageContext);\n    return pageContext;\n}\n","export { getPageId };\nimport { route } from '../../shared/route';\nimport { createPageContext } from './createPageContext';\nasync function getPageId(url) {\n    const pageContext = await createPageContext({\n        urlOriginal: url\n    });\n    const routeContext = await route(pageContext);\n    const pageFilesAll = pageContext._pageFilesAll;\n    const pageConfigs = pageContext._pageConfigs;\n    if (!('pageContextAddendum' in routeContext)) {\n        return { pageId: null, pageFilesAll, pageConfigs };\n    }\n    const pageId = routeContext.pageContextAddendum._pageId;\n    if (!pageId) {\n        return { pageId: null, pageFilesAll, pageConfigs };\n    }\n    return { pageId, pageFilesAll, pageConfigs };\n}\n","export { getExportNames };\nimport { assert } from '../../utils';\nfunction getExportNames(p) {\n    if (p.fileType === '.css') {\n        return [];\n    }\n    if (p.exportNames) {\n        return p.exportNames;\n    }\n    assert(p.fileExports, p.filePath);\n    const exportNames = Object.keys(p.fileExports);\n    return exportNames;\n}\n","export { analyzeExports };\nimport { getExportNames } from './getExportNames';\nimport { assertUsage } from '../../utils';\n// TODO/v1-release: remove\nfunction analyzeExports({ pageFilesClientSide, pageFilesServerSide, pageId }) {\n    return { isHtmlOnly: isHtmlOnly(), isClientRouting: isClientRouting() };\n    function isHtmlOnly() {\n        {\n            const hasPageIdIsmrphFile = pageFilesServerSide.some((p) => p.pageId === pageId && p.fileType === '.page');\n            if (hasPageIdIsmrphFile) {\n                assertClientSideRenderHook();\n                return false;\n            }\n        }\n        {\n            const hasPageIdServerFile = pageFilesServerSide.some((p) => p.pageId === pageId && p.fileType === '.page.server');\n            if (!hasPageIdServerFile) {\n                return false;\n            }\n        }\n        {\n            const definesClientRenderer = pageFilesClientSide.some((p) => p.pageId === pageId && p.fileType === '.page.client' && getExportNames(p).includes('render'));\n            if (definesClientRenderer) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function assertClientSideRenderHook() {\n        const hasClientSideRenderHook = pageFilesClientSide.some((p) => {\n            return getExportNames(p).includes('render');\n        });\n        assertUsage(hasClientSideRenderHook, [\n            'No client-side `render()` hook found.',\n            'See https://vite-plugin-ssr.com/render-modes for more information.',\n            [\n                'Loaded client-side page files (none of them `export { render }`):',\n                ...pageFilesClientSide.map((p, i) => ` (${i + 1}): ${p.filePath}`)\n            ].join('\\n')\n        ].join(' '));\n    }\n    function isClientRouting() {\n        const hasClientRoutingExport = pageFilesClientSide.some((p) => {\n            return getExportNames(p).includes('clientRouting');\n        });\n        return hasClientRoutingExport;\n    }\n}\n","export { determineClientEntry };\nexport { getVPSClientEntry };\nfunction determineClientEntry({ pageFilesClientSide, pageFilesServerSide, isHtmlOnly, isClientRouting }) {\n    let clientEntries = [];\n    const pageFilesServerSideOnly = pageFilesServerSide.filter((p) => !pageFilesClientSide.includes(p));\n    const clientDependencies = [];\n    clientDependencies.push(...pageFilesClientSide.map((p) => ({ id: p.filePath, onlyAssets: false, eagerlyImported: false })));\n    // CSS & assets\n    clientDependencies.push(...pageFilesServerSideOnly.map((p) => ({ id: p.filePath, onlyAssets: true, eagerlyImported: false })));\n    // Handle SPA & SSR pages.\n    if (isHtmlOnly) {\n        clientEntries = pageFilesClientSide.map((p) => p.filePath);\n    }\n    else {\n        // Add the vps client entry\n        const clientEntry = getVPSClientEntry(isClientRouting);\n        clientDependencies.push({ id: clientEntry, onlyAssets: false, eagerlyImported: false });\n        clientEntries = [clientEntry];\n    }\n    // console.log(pageFilesClientSide, pageFilesServerSide, clientDependencies, clientEntry)\n    return { clientEntries, clientDependencies };\n}\nfunction getVPSClientEntry(isClientRouting) {\n    return isClientRouting\n        ? // dist/client/entries/entry-client-routing.js\n            '@@vite-plugin-ssr/dist/esm/client/router/entry.js'\n        : // dist/client/entries/entry-server-routing.js\n            '@@vite-plugin-ssr/dist/esm/client/entry.js';\n}\n","export { analyzePageClientSide };\nexport { analyzePageClientSideInit };\nimport { analyzeExports } from './analyzePageClientSide/analyzeExports';\nimport { determineClientEntry } from './analyzePageClientSide/determineClientEntry';\nimport { getPageFilesClientSide } from './getAllPageIdFiles';\nimport { getPageFilesServerSide } from './getAllPageIdFiles';\nimport { assert } from '../utils';\nimport { getExportNames } from './analyzePageClientSide/getExportNames';\n// TODO/v1-release: remove analyzePageClientSide(), use analyzeClientSide() instead\nfunction analyzePageClientSide(pageFilesAll, pageId) {\n    let pageFilesClientSide = getPageFilesClientSide(pageFilesAll, pageId);\n    const pageFilesServerSide = getPageFilesServerSide(pageFilesAll, pageId);\n    const { isHtmlOnly, isClientRouting } = analyzeExports({ pageFilesClientSide, pageFilesServerSide, pageId });\n    if (isHtmlOnly) {\n        // HTML-only pages don't need any client-side `render()` hook. For apps that have both HTML-only and SSR/SPA pages, we skip the `.page.client.js` file that defines `render()` for HTML-only pages.\n        pageFilesClientSide = pageFilesClientSide.filter((p) => p.isEnv('CLIENT_ONLY') && !getExportNames(p).includes('render'));\n        pageFilesClientSide = removeOverridenPageFiles(pageFilesClientSide);\n    }\n    const { clientEntries, clientDependencies } = determineClientEntry({\n        pageFilesClientSide,\n        pageFilesServerSide,\n        isHtmlOnly,\n        isClientRouting\n    });\n    return { isHtmlOnly, isClientRouting, clientEntries, clientDependencies, pageFilesClientSide, pageFilesServerSide };\n}\nasync function analyzePageClientSideInit(pageFilesAll, pageId, { sharedPageFilesAlreadyLoaded }) {\n    const pageFilesClientSide = getPageFilesClientSide(pageFilesAll, pageId);\n    await Promise.all(pageFilesClientSide.map(async (p) => {\n        var _a;\n        assert(p.isEnv('CLIENT_ONLY') || p.isEnv('CLIENT_AND_SERVER'));\n        if (sharedPageFilesAlreadyLoaded && p.isEnv('CLIENT_AND_SERVER')) {\n            return;\n        }\n        // TODO: Is `loadExportNames()` cached ? Does it use filesExports if possible? HMR?\n        await ((_a = p.loadExportNames) === null || _a === void 0 ? void 0 : _a.call(p));\n        /*\n        if (pageFile.exportNames) {\n          return pageFile.exportNames.includes(clientRouting)\n        }\n        if (pageFile.fileExports) {\n          return Object.keys(pageFile.fileExports).includes(clientRouting)\n        }\n        */\n    }));\n}\n// [WIP] Just an experiment needed by https://vite-plugin-ssr.com/banner\n//  - Not sure I want to make something like a public API: the CSS of `_default.page.server.js` are still loaded -> weird DX.\nfunction removeOverridenPageFiles(pageFilesClientSide) {\n    const pageFilesClientSide_ = [];\n    for (const p of pageFilesClientSide) {\n        pageFilesClientSide_.push(p);\n        if (getExportNames(p).includes('overrideDefaultPages')) {\n            break;\n        }\n    }\n    return pageFilesClientSide_;\n}\n","export { analyzeClientSide };\nimport { getCodeFilePath, getConfigValue } from '../page-configs/utils';\nimport { analyzePageClientSide } from './analyzePageClientSide';\nfunction analyzeClientSide(pageConfig, pageFilesAll, pageId) {\n    var _a;\n    if (pageConfig) {\n        const isClientRouting = (_a = getConfigValue(pageConfig, 'clientRouting', 'boolean')) !== null && _a !== void 0 ? _a : false;\n        const onRenderClientExists = !!getCodeFilePath(pageConfig, 'onRenderClient');\n        const PageExists = !!getCodeFilePath(pageConfig, 'Page') && pageConfig.configElements.Page.configEnv !== 'server-only';\n        const isClientSideRenderable = onRenderClientExists && PageExists;\n        return { isClientSideRenderable, isClientRouting };\n    }\n    else {\n        // TOOD: globally rename isHtmlOnly to !isClientSideRenderable\n        const { isHtmlOnly, isClientRouting } = analyzePageClientSide(pageFilesAll, pageId);\n        return { isClientSideRenderable: !isHtmlOnly, isClientRouting };\n    }\n}\n","export { isClientSideRoutable };\nimport { getPageId } from '../getPageId';\nimport { analyzePageClientSideInit } from '../../../shared/getPageFiles/analyzePageClientSide';\nimport { findPageConfig } from '../../../shared/page-configs/findPageConfig';\nimport { analyzeClientSide } from '../../../shared/getPageFiles/analyzeClientSide';\nasync function isClientSideRoutable(url) {\n    const { pageId, pageFilesAll, pageConfigs } = await getPageId(url);\n    if (!pageId) {\n        return false;\n    }\n    await analyzePageClientSideInit(pageFilesAll, pageId, { sharedPageFilesAlreadyLoaded: false });\n    const pageConfig = findPageConfig(pageConfigs, pageId);\n    const { isClientSideRenderable, isClientRouting } = analyzeClientSide(pageConfig, pageFilesAll, pageId);\n    return isClientSideRenderable && isClientRouting;\n}\n","export { skipLink };\nexport { isClientSideRoutable } from './skipLink/isClientSideRoutable';\nimport { getBaseServer } from '../getBaseServer';\nimport { assert, parseUrl, isBaseServer, isParsable, isExternalLink } from './utils';\nfunction skipLink(linkTag) {\n    const url = linkTag.getAttribute('href');\n    if (url === null)\n        return true;\n    if (url === '')\n        return true;\n    if (isExternalLink(url))\n        return true;\n    if (isNewTabLink(linkTag))\n        return true;\n    if (isHashUrl(url))\n        return true;\n    if (!hasBaseServer(url)) {\n        return true;\n    }\n    if (!isParsable(url)) {\n        return true;\n    }\n    return false;\n}\nfunction isNewTabLink(linkTag) {\n    const target = linkTag.getAttribute('target');\n    const rel = linkTag.getAttribute('rel');\n    return target === '_blank' || target === '_external' || rel === 'external' || linkTag.hasAttribute('download');\n}\nfunction isHashUrl(url) {\n    if (url.startsWith('#')) {\n        return true;\n    }\n    const removeHash = (url) => url.split('#')[0];\n    if (url.includes('#') && removeHash(url) === removeHash(window.location.href)) {\n        return true;\n    }\n    return false;\n}\nfunction hasBaseServer(url) {\n    const baseServer = getBaseServer();\n    assert(isBaseServer(baseServer));\n    const { hasBaseServer } = parseUrl(url, baseServer);\n    return hasBaseServer;\n}\n","export { getPrefetchSettings };\nimport { assert, assertUsage, assertInfo, assertWarning, isPlainObject } from '../utils';\nfunction getPrefetchSettings(pageContext, linkTag) {\n    let prefetchStaticAssets = getPrefetchStaticAssets(pageContext, linkTag);\n    if (prefetchStaticAssets === 'viewport' && !pageContext._isProduction) {\n        assertInfo(false, 'Viewport prefetching is disabled in development', { onlyOnce: true });\n        prefetchStaticAssets = 'hover';\n    }\n    return {\n        prefetchStaticAssets\n    };\n}\nfunction getPrefetchStaticAssets(pageContext, linkTag) {\n    {\n        const prefetchAttribute = getPrefetchAttribute(linkTag);\n        if (prefetchAttribute !== null)\n            return prefetchAttribute;\n    }\n    if ('prefetchLinks' in pageContext.exports) {\n        assertUsage(false, '`export { prefetchLinks }` is deprecated, use `export { prefetchStaticAssets }` instead.');\n    }\n    if ('prefetchStaticAssets' in pageContext.exports) {\n        const { prefetchStaticAssets } = pageContext.exports;\n        if (prefetchStaticAssets === false) {\n            return false;\n        }\n        if (prefetchStaticAssets === 'hover') {\n            return 'hover';\n        }\n        if (prefetchStaticAssets === 'viewport') {\n            return 'viewport';\n        }\n        const wrongUsageMsg = \"prefetchStaticAssets value should be false, 'hover', or 'viewport'\";\n        // TODO/v1-release: remove\n        assertUsage(isPlainObject(prefetchStaticAssets), wrongUsageMsg);\n        const keys = Object.keys(prefetchStaticAssets);\n        assertUsage(keys.length === 1 && keys[0] === 'when', wrongUsageMsg);\n        const { when } = prefetchStaticAssets;\n        if (when === 'HOVER' || when === 'VIEWPORT') {\n            const correctValue = when.toLowerCase();\n            assertWarning(false, `prefetchStaticAssets value \\`{ when: '${when}' }\\` is outdated: set prefetchStaticAssets to '${correctValue}' instead`, { onlyOnce: true, showStackTrace: false });\n            return correctValue;\n        }\n        assertUsage(false, wrongUsageMsg);\n    }\n    return 'hover';\n}\nfunction getPrefetchAttribute(linkTag) {\n    const attr = linkTag.getAttribute('data-prefetch-static-assets');\n    const attrOld = linkTag.getAttribute('data-prefetch');\n    if (attr === null && attrOld === null) {\n        return null;\n    }\n    const deprecationNotice = 'The attribute data-prefetch is outdated, use data-prefetch-static-assets instead.';\n    if (attr) {\n        assertUsage(attrOld === null, deprecationNotice);\n        if (attr === 'hover' || attr === 'viewport') {\n            return attr;\n        }\n        if (attr === 'false') {\n            return false;\n        }\n        assertUsage(false, `data-prefetch-static-assets has value \"${attr}\" but it should instead be \"false\", \"hover\", or \"viewport\"`);\n    }\n    // TODO/v1-release: remove\n    if (attrOld) {\n        assert(!attr);\n        assertWarning(false, deprecationNotice, {\n            showStackTrace: false,\n            onlyOnce: true\n        });\n        if (attrOld === 'true') {\n            return 'viewport';\n        }\n        if (attrOld === 'false') {\n            return 'hover';\n        }\n        assertUsage(false, `data-prefetch has value \"${attrOld}\" but it should instead be \"true\" or \"false\"`);\n    }\n    assert(false);\n}\n","export { isAlreadyPrefetched };\nexport { markAsAlreadyPrefetched };\nimport { getUrlPathname } from '../utils';\nconst linkAlreadyPrefetched = new Map();\nfunction isAlreadyPrefetched(url) {\n    const prefetchUrl = getPrefetchUrl(url);\n    return linkAlreadyPrefetched.has(prefetchUrl);\n}\nfunction markAsAlreadyPrefetched(url) {\n    const prefetchUrl = getPrefetchUrl(url);\n    linkAlreadyPrefetched.set(prefetchUrl, true);\n}\nfunction getPrefetchUrl(url) {\n    return getUrlPathname(url);\n}\n","import { getCurrentUrl, getGlobalObject } from './utils';\nconst globalObject = getGlobalObject('navigationState.ts', {});\nconst urlFirst = getCurrentUrl();\nexport const navigationState = {\n    markNavigationChange() {\n        globalObject.navigationChanged = true;\n    },\n    get noNavigationChangeYet() {\n        return !globalObject.navigationChanged && this.isFirstUrl(getCurrentUrl());\n    },\n    isFirstUrl(url) {\n        return url === urlFirst;\n    }\n};\n","export { analyzePageServerSide };\nimport { assert } from '../utils';\nimport { getPageFilesServerSide } from './getAllPageIdFiles';\nasync function analyzePageServerSide(pageFilesAll, pageId) {\n    const pageFilesServerSide = getPageFilesServerSide(pageFilesAll, pageId);\n    const pageFilesServerSideOnly = pageFilesServerSide.filter((p) => p.fileType === '.page.server');\n    await Promise.all(pageFilesServerSideOnly.map(async (p) => {\n        // In production, `exportNames` are preload\n        if (p.exportNames) {\n            return;\n        }\n        assert(p.loadExportNames, pageId);\n        await p.loadExportNames();\n    }));\n    const hasOnBeforeRenderServerSideOnlyHook = pageFilesServerSideOnly.some(({ exportNames }) => {\n        assert(exportNames);\n        return exportNames.includes('onBeforeRender');\n    });\n    return { hasOnBeforeRenderServerSideOnlyHook };\n}\n","export { removeBuiltInOverrides };\nimport { assert, assertWarning } from '../utils';\nconst BUILT_IN_CLIENT_ROUTER = ['urlPathname', 'urlParsed'];\nconst BUILT_IN_CLIENT = ['Page', 'pageExports', 'exports'];\nfunction removeBuiltInOverrides(pageContext) {\n    const alreadySet = [...BUILT_IN_CLIENT, ...BUILT_IN_CLIENT_ROUTER];\n    alreadySet.forEach((prop) => {\n        if (prop in pageContext) {\n            // We need to cast `BUILT_IN_CLIENT` to `string[]`\n            //  - https://stackoverflow.com/questions/56565528/typescript-const-assertions-how-to-use-array-prototype-includes\n            //  - https://stackoverflow.com/questions/57646355/check-if-string-is-included-in-readonlyarray-in-typescript\n            if (BUILT_IN_CLIENT_ROUTER.includes(prop)) {\n                assert(prop.startsWith('url'));\n                assertWarning(false, `\\`pageContext.${prop}\\` is already available in the browser when using Client Routing; including \\`${prop}\\` in \\`passToClient\\` has no effect.`, { showStackTrace: false, onlyOnce: true });\n            }\n            else {\n                assertWarning(false, `\\`pageContext.${prop}\\` is a built-in that cannot be overriden; including \\`${prop}\\` in \\`passToClient\\` has no effect.`, { showStackTrace: false, onlyOnce: true });\n            }\n            delete pageContext[prop];\n        }\n    });\n}\n","export { urlToFile };\nexport { baseServer };\nimport { assert } from './assert';\nimport { parseUrl } from './parseUrl';\nimport { slice } from './slice';\n// - When doing a `.pageContext.json` HTTP request, the base URL should be preserved. (The server-side will handle the base URL.)\n// - While prerendering there is no base URL\nconst baseServer = '/';\nfunction urlToFile(url, fileExtension, doNotCreateExtraDirectory) {\n    const { pathnameOriginal, searchOriginal, hashOriginal } = parseUrl(url, baseServer);\n    if (url.startsWith('/')) {\n        assert(url === `${pathnameOriginal}${searchOriginal || ''}${hashOriginal || ''}`, { url });\n    }\n    const hasTrailingSlash = pathnameOriginal.endsWith('/');\n    let pathnameModified;\n    if (doNotCreateExtraDirectory && pathnameOriginal !== '/') {\n        if (hasTrailingSlash) {\n            pathnameModified = slice(pathnameOriginal, 0, -1);\n        }\n        else {\n            pathnameModified = pathnameOriginal;\n        }\n        assert(!pathnameModified.endsWith('/'), { url });\n        assert(pathnameModified !== '');\n    }\n    else {\n        pathnameModified = pathnameOriginal + (hasTrailingSlash ? '' : '/') + 'index';\n    }\n    assert(pathnameModified);\n    pathnameModified = pathnameModified + fileExtension;\n    const fileUrl = `${pathnameModified}${searchOriginal || ''}${hashOriginal || ''}`;\n    return fileUrl;\n}\n","export { getPageContextRequestUrl };\nexport { fileExtension };\nexport { doNotCreateExtraDirectory };\n// This module isn't loaded by the client-side of Server Routing => we don't inlcude `urlToFile` to `./utils.ts`\nimport { urlToFile } from '../utils/urlToFile';\nconst fileExtension = '.pageContext.json';\n// `/some-base-url/index.pageContext.json` instead of `/some-base-url.pageContext.json` in order to comply to common reverse proxy setups, see https://github.com/brillout/vite-plugin-ssr/issues/443\nconst doNotCreateExtraDirectory = false;\n// See node/renderPage/handlePageContextRequestUrl.ts\nfunction getPageContextRequestUrl(url) {\n    const pageContextRequestUrl = urlToFile(url, fileExtension, doNotCreateExtraDirectory);\n    return pageContextRequestUrl;\n}\n","export { assertObjectKeys };\nimport { assert, assertUsage, stringifyStringArray } from './utils';\nfunction assertObjectKeys(obj, keysExpected, errPrefix) {\n    assert(!errPrefix.endsWith(' '));\n    const keysUnknown = [];\n    const keys = Object.keys(obj);\n    for (const key of keys) {\n        if (!keysExpected.includes(key)) {\n            keysUnknown.push(key);\n        }\n    }\n    assertUsage(keysUnknown.length === 0, [\n        errPrefix,\n        'returned an object with following unknown keys:',\n        stringifyStringArray(keysUnknown) + '.',\n        'Only following keys are allowed:',\n        stringifyStringArray(keysExpected) + '.'\n    ].join(' '));\n}\n","export { assertOnBeforeRenderHookReturn };\nimport { assertUsage, isPlainObject } from './utils';\nimport { assertPageContextProvidedByUser } from './assertPageContextProvidedByUser';\nimport { assertObjectKeys } from './assertObjectKeys';\nfunction assertOnBeforeRenderHookReturn(hookReturnValue, hookFilePath) {\n    if (hookReturnValue === undefined || hookReturnValue === null) {\n        return;\n    }\n    const errPrefix = `The onBeforeRender() hook defined by ${hookFilePath}`;\n    assertUsage(isPlainObject(hookReturnValue), `${errPrefix} should return a plain JavaScript object or \\`undefined\\`/\\`null\\``);\n    assertObjectKeys(hookReturnValue, ['pageContext'], errPrefix);\n    if (hookReturnValue.pageContext) {\n        assertPageContextProvidedByUser(hookReturnValue['pageContext'], {\n            hook: { hookName: 'onBeforeRender', hookFilePath }\n        });\n    }\n}\n","export { getPageContext };\nexport { getPageContextErrorPage };\nexport { checkIf404 };\nimport { navigationState } from '../navigationState';\nimport { assert, assertUsage, hasProp, isPlainObject, objectAssign, getProjectError, serverSideRouteTo, callHookWithTimeout, isObject } from './utils';\nimport { parse } from '@brillout/json-serializer/parse';\nimport { getPageContextSerializedInHtml } from '../getPageContextSerializedInHtml';\nimport { analyzePageServerSide } from '../../shared/getPageFiles/analyzePageServerSide';\nimport { route } from '../../shared/route';\nimport { getErrorPageId } from '../../shared/error-page';\nimport { getHook } from '../../shared/getHook';\nimport { releasePageContext } from '../releasePageContext';\nimport { loadPageFilesClientSide } from '../loadPageFilesClientSide';\nimport { removeBuiltInOverrides } from './getPageContext/removeBuiltInOverrides';\nimport { getPageContextRequestUrl } from '../../shared/getPageContextRequestUrl';\nimport { getCodeFilePath, getPageConfig } from '../../shared/page-configs/utils';\nimport { assertOnBeforeRenderHookReturn } from '../../shared/assertOnBeforeRenderHookReturn';\nasync function getPageContext(pageContext) {\n    if (pageContext._isFirstRenderAttempt && navigationState.isFirstUrl(pageContext.urlOriginal)) {\n        assert(hasProp(pageContext, '_isFirstRenderAttempt', 'true'));\n        return getPageContextFirstRender(pageContext);\n    }\n    else {\n        assert(hasProp(pageContext, '_isFirstRenderAttempt', 'false'));\n        return getPageContextUponNavigation(pageContext);\n    }\n}\nasync function getPageContextFirstRender(pageContext) {\n    const pageContextAddendum = getPageContextSerializedInHtml();\n    removeBuiltInOverrides(pageContextAddendum);\n    objectAssign(pageContextAddendum, {\n        isHydration: true,\n        _comesDirectlyFromServer: true\n    });\n    objectAssign(pageContextAddendum, await loadPageFilesClientSide(pageContext._pageFilesAll, pageContext._pageConfigs, pageContextAddendum._pageId));\n    return pageContextAddendum;\n}\nasync function getPageContextErrorPage(pageContext) {\n    const errorPageId = getErrorPageId(pageContext._pageFilesAll, pageContext._pageConfigs);\n    if (!errorPageId) {\n        throw new Error('No error page');\n    }\n    const pageContextAddendum = {\n        isHydration: false,\n        _pageId: errorPageId,\n        _pageContextRetrievedFromServer: null,\n        _comesDirectlyFromServer: false\n    };\n    objectAssign(pageContextAddendum, await loadPageFilesClientSide(pageContext._pageFilesAll, pageContext._pageConfigs, pageContextAddendum._pageId));\n    return pageContextAddendum;\n}\nasync function getPageContextUponNavigation(pageContext) {\n    let pageContextAddendum = {};\n    objectAssign(pageContextAddendum, {\n        isHydration: false\n    });\n    objectAssign(pageContextAddendum, await getPageContextFromRoute(pageContext));\n    objectAssign(pageContextAddendum, await loadPageFilesClientSide(pageContext._pageFilesAll, pageContext._pageConfigs, pageContextAddendum._pageId));\n    const pageContextFromHook = await onBeforeRenderExecute({ ...pageContext, ...pageContextAddendum });\n    assert([true, false].includes(pageContextFromHook._comesDirectlyFromServer));\n    if (!pageContextFromHook['_isError']) {\n        objectAssign(pageContextAddendum, pageContextFromHook);\n        return pageContextAddendum;\n    }\n    else {\n        pageContextAddendum = {};\n        assert(pageContextFromHook._comesDirectlyFromServer === true);\n        assert(hasProp(pageContextFromHook, 'is404', 'boolean'));\n        assert(hasProp(pageContextFromHook, 'pageProps', 'object'));\n        assert(hasProp(pageContextFromHook.pageProps, 'is404', 'boolean'));\n        // When the user hasn't define a `_error.page.js` file: the mechanism with `serverSideError: true` is used instead\n        assert(!('serverSideError' in pageContextFromHook));\n        const errorPageId = getErrorPageId(pageContext._pageFilesAll, pageContext._pageConfigs);\n        assert(errorPageId);\n        objectAssign(pageContextAddendum, {\n            isHydration: false,\n            _pageId: errorPageId\n        });\n        objectAssign(pageContextAddendum, pageContextFromHook);\n        objectAssign(pageContextAddendum, await loadPageFilesClientSide(pageContext._pageFilesAll, pageContext._pageConfigs, pageContextAddendum._pageId));\n        return pageContextAddendum;\n    }\n}\nasync function onBeforeRenderExecute(pageContext) {\n    // `export { onBeforeRender }` defined in `.page.client.js` or `.page.js`\n    const hook = getHook(pageContext, 'onBeforeRender');\n    if (hook) {\n        const onBeforeRender = hook.hookFn;\n        const pageContextAddendum = {\n            _comesDirectlyFromServer: false,\n            _pageContextRetrievedFromServer: null\n        };\n        const pageContextReadyForRelease = releasePageContext({\n            ...pageContext,\n            ...pageContextAddendum\n        }, true);\n        const hookResult = await callHookWithTimeout(() => onBeforeRender(pageContextReadyForRelease), 'onBeforeRender', hook.hookFilePath);\n        assertOnBeforeRenderHookReturn(hookResult, hook.hookFilePath);\n        const pageContextFromHook = hookResult === null || hookResult === void 0 ? void 0 : hookResult.pageContext;\n        objectAssign(pageContextAddendum, pageContextFromHook);\n        return pageContextAddendum;\n    }\n    // `export { onBeforeRender }` defined in `.page.server.js`\n    if (await onBeforeRenderServerSideExists(pageContext)) {\n        const pageContextFromServer = await retrievePageContextFromServer(pageContext);\n        const pageContextAddendum = {};\n        Object.assign(pageContextAddendum, pageContextFromServer);\n        objectAssign(pageContextAddendum, {\n            _comesDirectlyFromServer: true,\n            _pageContextRetrievedFromServer: pageContextFromServer\n        });\n        return pageContextAddendum;\n    }\n    // No `export { onBeforeRender }` defined\n    const pageContextAddendum = { _comesDirectlyFromServer: false, _pageContextRetrievedFromServer: null };\n    return pageContextAddendum;\n}\nasync function onBeforeRenderServerSideExists(pageContext) {\n    if (pageContext._pageConfigs.length > 0) {\n        const pageConfig = getPageConfig(pageContext._pageId, pageContext._pageConfigs);\n        return (!!getCodeFilePath(pageConfig, 'onBeforeRender') &&\n            pageConfig.configElements.onBeforeRender.configEnv === 'server-only');\n    }\n    else {\n        const { hasOnBeforeRenderServerSideOnlyHook } = await analyzePageServerSide(pageContext._pageFilesAll, pageContext._pageId);\n        return hasOnBeforeRenderServerSideOnlyHook;\n    }\n}\nasync function getPageContextFromRoute(pageContext) {\n    const routeResult = await route(pageContext);\n    const pageContextFromRoute = routeResult.pageContextAddendum;\n    if (!pageContextFromRoute._pageId) {\n        const err = new Error('No routing match');\n        markIs404(err);\n        throw err;\n    }\n    assert(hasProp(pageContextFromRoute, '_pageId', 'string'));\n    return pageContextFromRoute;\n}\nfunction markIs404(err) {\n    objectAssign(err, { _is404: true });\n}\nfunction checkIf404(err) {\n    return isObject(err) && err._is404 === true;\n}\nasync function retrievePageContextFromServer(pageContext) {\n    var _a;\n    const pageContextUrl = getPageContextRequestUrl((_a = pageContext._urlPristine) !== null && _a !== void 0 ? _a : pageContext.urlOriginal);\n    const response = await fetch(pageContextUrl);\n    {\n        const contentType = response.headers.get('content-type');\n        const isRightContentType = contentType && contentType.includes('application/json');\n        // Static hosts + page doesn't exist\n        if (!isRightContentType && response.status === 404) {\n            serverSideRouteTo(pageContext.urlOriginal);\n            const err = new Error(\"Page doesn't exist\");\n            Object.assign(err, { _abortRendering: true });\n            throw err;\n        }\n        assertUsage(isRightContentType, `Wrong HTTP Response Header \\`content-type\\` value for URL ${pageContextUrl} (it should be \\`application/json\\` but we got \\`${contentType}\\`). Make sure to use \\`pageContext.httpResponse.contentType\\`, see https://github.com/brillout/vite-plugin-ssr/issues/191`);\n    }\n    const responseText = await response.text();\n    const responseObject = parse(responseText);\n    if ('serverSideError' in responseObject) {\n        throw getProjectError('`pageContext` could not be fetched from the server as an error occurred on the server; check your server logs.');\n    }\n    assert(hasProp(responseObject, 'pageContext'));\n    const pageContextFromServer = responseObject.pageContext;\n    assert(isPlainObject(pageContextFromServer));\n    assert(hasProp(pageContextFromServer, '_pageId', 'string'));\n    removeBuiltInOverrides(pageContextFromServer);\n    return pageContextFromServer;\n}\n","export { initHistoryState, getHistoryState, pushHistory, saveScrollPosition };\nimport { assert, hasProp, isObject } from './utils';\n// Fill missing state information.\n//  - The very first render => `history.state` is uninitialized (`null`).\n//  - The vite-plugin-ssr app runs `location.hash = '#section'` => `history.state` is uninitialized (`null`).\n//  - The user clicks on an anchor link `<a href=\"#section\">Section</a>` => `history.state` is uninitialized (`null`).\n//  - `history.state` set by an old vite-plugin-ssr version => state information may be incomplete. (E.g. `state.timestamp` was introduced for `pageContext.isBackwardNavigation` in `0.4.19`.)\nfunction initHistoryState() {\n    let state = window.history.state;\n    if (!state) {\n        state = {};\n    }\n    let hasModifications = false;\n    if (!('timestamp' in state)) {\n        hasModifications = true;\n        state.timestamp = getTimestamp();\n    }\n    if (!('scrollPosition' in state)) {\n        hasModifications = true;\n        state.scrollPosition = getScrollPosition();\n    }\n    assertState(state);\n    if (hasModifications) {\n        replaceHistoryState(state);\n    }\n}\nfunction getHistoryState() {\n    const state = window.history.state || {};\n    assertState(state);\n    return state;\n}\nfunction getScrollPosition() {\n    const scrollPosition = { x: window.scrollX, y: window.scrollY };\n    return scrollPosition;\n}\nfunction getTimestamp() {\n    return new Date().getTime();\n}\nfunction saveScrollPosition() {\n    const scrollPosition = getScrollPosition();\n    const state = getHistoryState();\n    replaceHistoryState({ ...state, scrollPosition });\n}\nfunction pushHistory(url, overwriteLastHistoryEntry) {\n    if (!overwriteLastHistoryEntry) {\n        const timestamp = getTimestamp();\n        pushHistoryState({ timestamp, scrollPosition: null }, url);\n    }\n    else {\n        replaceHistoryState(getHistoryState(), url);\n    }\n}\nfunction assertState(state) {\n    assert(isObject(state));\n    if ('timestamp' in state) {\n        const { timestamp } = state;\n        assert(typeof timestamp === 'number');\n    }\n    if ('scrollPosition' in state) {\n        const { scrollPosition } = state;\n        if (scrollPosition !== null) {\n            assert(hasProp(scrollPosition, 'x', 'number') && hasProp(scrollPosition, 'y', 'number'));\n        }\n    }\n}\nfunction replaceHistoryState(state, url) {\n    window.history.replaceState(state, '', url !== null && url !== void 0 ? url : null);\n}\nfunction pushHistoryState(state, url) {\n    window.history.pushState(state, '', url);\n}\n","export { isRenderErrorPageException };\nexport { RenderErrorPage };\nexport { assertRenderErrorPageExceptionUsage };\nimport { assertPageContextProvidedByUser } from '../assertPageContextProvidedByUser';\nimport { assertUsage, objectAssign } from './utils';\nconst stamp = '__isRenderErrorPageException';\nfunction isRenderErrorPageException(thing) {\n    assertRenderErrorPageExceptionUsage(thing);\n    return typeof thing === 'object' && thing !== null && stamp in thing;\n}\nfunction RenderErrorPage({ pageContext } = {}) {\n    {\n        // @ts-ignore\n        const that = this;\n        assertUsage(!(typeof that === 'object' && (that === null || that === void 0 ? void 0 : that.constructor) === RenderErrorPage), \"Don't use the `new` operator: use `throw RenderErrorPage()` instead of `throw new RenderErrorPage()`.\");\n    }\n    assertPageContextProvidedByUser(pageContext, {\n        errorMessagePrefix: 'The `pageContext` object provided by `throw RenderErrorPage({ pageContext })`',\n        isRenderErrorPage: true\n    });\n    const err = new Error('RenderErrorPage');\n    objectAssign(err, { pageContext, [stamp]: true });\n    return err;\n}\nfunction assertRenderErrorPageExceptionUsage(err) {\n    assertUsage(err !== RenderErrorPage, 'Missing parentheses `()` in `throw RenderErrorPage`: it should be `throw RenderErrorPage()`.');\n}\n","export { useClientRouter };\nexport { disableClientRouting };\nimport { assert, getCurrentUrl, isSameErrorMessage, objectAssign, serverSideRouteTo, throttle, sleep, getGlobalObject, callHookWithTimeout, isObject } from './utils';\nimport { navigationState } from '../navigationState';\nimport { checkIf404, getPageContext, getPageContextErrorPage } from './getPageContext';\nimport { createPageContext } from './createPageContext';\nimport { addLinkPrefetchHandlers } from './prefetch';\nimport { assertInfo, assertWarning, isReact } from './utils';\nimport { executeOnRenderClientHook } from '../executeOnRenderClientHook';\nimport { assertHook } from '../../shared/getHook';\nimport { isClientSideRoutable, skipLink } from './skipLink';\nimport { isErrorFetchingStaticAssets } from '../loadPageFilesClientSide';\nimport { initHistoryState, getHistoryState, pushHistory, saveScrollPosition } from './history';\nimport { defineNavigate } from './navigate';\nimport { isRenderErrorPageException } from '../../shared/route/RenderErrorPage';\nconst globalObject = getGlobalObject('useClientRouter.ts', { previousState: getState() });\nsetupNativeScrollRestoration();\ninitHistoryState();\nfunction disableClientRouting(err, logError) {\n    assert(isErrorFetchingStaticAssets(err));\n    globalObject.clientRoutingIsDisabled = true;\n    if (logError) {\n        // We don't use console.error() to avoid flooding error trackers such as Sentry\n        console.log(err);\n    }\n    assertInfo(false, [\n        'Failed to fetch static asset.',\n        import.meta.env.PROD ? 'This usually happens when a new frontend is deployed.' : null,\n        'Falling back to Server Routing.',\n        '(The next page navigation will use Server Routing instead of Client Routing.)'\n    ]\n        .filter(Boolean)\n        .join(' '), { onlyOnce: true });\n}\nfunction useClientRouter() {\n    autoSaveScrollPosition();\n    onLinkClick((url, { keepScrollPosition }) => {\n        const scrollTarget = keepScrollPosition ? 'preserve-scroll' : 'scroll-to-top-or-hash';\n        fetchAndRender({ scrollTarget, url, isBackwardNavigation: false, checkClientSideRenderable: true });\n    });\n    onBrowserHistoryNavigation((scrollTarget, isBackwardNavigation) => {\n        fetchAndRender({ scrollTarget, isBackwardNavigation });\n    });\n    defineNavigate(async (url, { keepScrollPosition = false, overwriteLastHistoryEntry = false } = {}) => {\n        const scrollTarget = keepScrollPosition ? 'preserve-scroll' : 'scroll-to-top-or-hash';\n        await fetchAndRender({\n            scrollTarget,\n            url,\n            overwriteLastHistoryEntry,\n            isBackwardNavigation: false,\n            checkClientSideRenderable: true\n        });\n    });\n    let renderingCounter = 0;\n    let renderPromise;\n    let isTransitioning = false;\n    fetchAndRender({ scrollTarget: 'preserve-scroll', isBackwardNavigation: null });\n    return;\n    async function fetchAndRender({ scrollTarget, url = getCurrentUrl(), overwriteLastHistoryEntry = false, isBackwardNavigation, checkClientSideRenderable }) {\n        var _a;\n        if (globalObject.clientRoutingIsDisabled) {\n            serverSideRouteTo(url);\n            return;\n        }\n        if (checkClientSideRenderable) {\n            let isClientRoutable;\n            try {\n                isClientRoutable = await isClientSideRoutable(url);\n            }\n            catch (err) {\n                if (!isRenderErrorPageException(err)) {\n                    // If a route() hook has a bug\n                    throw err;\n                }\n                else {\n                    // If a route() hook `throw RenderErrorPage()`\n                    // RenderErrorPage is handled down below\n                    isClientRoutable = true;\n                }\n            }\n            if (!isClientRoutable) {\n                serverSideRouteTo(url);\n                return;\n            }\n        }\n        const pageContextBase = {\n            urlOriginal: url,\n            isBackwardNavigation\n        };\n        const renderingNumber = ++renderingCounter;\n        assert(renderingNumber >= 1);\n        // Start transition before any await's\n        if (renderingNumber > 1) {\n            if (isTransitioning === false) {\n                (_a = globalObject.onPageTransitionStart) === null || _a === void 0 ? void 0 : _a.call(globalObject, pageContextBase);\n                isTransitioning = true;\n            }\n        }\n        let hydrationCanBeAborted = false;\n        const shouldAbort = () => {\n            {\n                // We should never abort the hydration if `hydrationCanBeAborted` isn't `true`\n                const isHydration = renderingNumber === 1;\n                if (isHydration && hydrationCanBeAborted === false) {\n                    return false;\n                }\n            }\n            // If there is a newer rendering, we should abort all previous renderings\n            if (renderingNumber !== renderingCounter) {\n                return true;\n            }\n            return false;\n        };\n        const pageContext = await createPageContext(pageContextBase);\n        if (shouldAbort()) {\n            return;\n        }\n        const isFirstRenderAttempt = renderingNumber === 1;\n        objectAssign(pageContext, {\n            _isFirstRenderAttempt: isFirstRenderAttempt\n        });\n        let pageContextAddendum;\n        try {\n            pageContextAddendum = await getPageContext(pageContext);\n        }\n        catch (err) {\n            // We never swallow errors on the client-side, even if it's a 404, because:\n            //  - On the client-side, if the user navigates to a 404 then it means that the UI has a broken link.\n            //    - It isn't expected that users can go to some random URL using the client-side router, as it would require, for example, the user to manually change the URL of a link by manually manipulating the DOM which highly unlikely.\n            //    - In contrast, on the server-side, VPS swallows / doesn't show any 404 error log because it's expected that a user may go to some random non-existent URL, and we don't want to flood the app's error tracking with 404 logs.\n            console.error(err);\n            if (checkIfAbort(err, pageContext))\n                return;\n            if (isRenderErrorPageException(err)) {\n                objectAssign(pageContext, { is404: true });\n                objectAssign(pageContext, err.pageContext);\n            }\n            else {\n                objectAssign(pageContext, { is404: checkIf404(err) });\n            }\n            try {\n                pageContextAddendum = await getPageContextErrorPage(pageContext);\n            }\n            catch (err2) {\n                // - When user hasn't defined a `_error.page.js` file\n                // - Some unpexected vite-plugin-ssr internal error\n                if (checkIfAbort(err2, pageContext))\n                    return;\n                if (!isFirstRenderAttempt) {\n                    setTimeout(() => {\n                        // We let the server show the 404 page\n                        window.location.pathname = url;\n                    }, 0);\n                }\n                if (!isSameErrorMessage(err, err2)) {\n                    throw err2;\n                }\n                else {\n                    // Abort\n                    return;\n                }\n            }\n        }\n        objectAssign(pageContext, pageContextAddendum);\n        assertHook(pageContext, 'onPageTransitionStart');\n        globalObject.onPageTransitionStart = pageContext.exports.onPageTransitionStart;\n        if (pageContext.exports.hydrationCanBeAborted) {\n            hydrationCanBeAborted = true;\n        }\n        else {\n            assertWarning(!isReact(), 'You seem to be using React; we recommend setting `hydrationCanBeAborted` to `true`, see https://vite-plugin-ssr.com/clientRouting', { showStackTrace: false, onlyOnce: true });\n        }\n        if (shouldAbort()) {\n            return;\n        }\n        if (renderPromise) {\n            // Always make sure that the previous render has finished,\n            // otherwise that previous render may finish after this one.\n            await renderPromise;\n        }\n        if (shouldAbort()) {\n            return;\n        }\n        changeUrl(url, overwriteLastHistoryEntry);\n        navigationState.markNavigationChange();\n        assert(renderPromise === undefined);\n        renderPromise = (async () => {\n            await executeOnRenderClientHook(pageContext, true);\n            addLinkPrefetchHandlers(pageContext);\n        })();\n        await renderPromise;\n        renderPromise = undefined;\n        if (pageContext._isFirstRenderAttempt) {\n            assertHook(pageContext, 'onHydrationEnd');\n            const { onHydrationEnd } = pageContext.exports;\n            if (onHydrationEnd) {\n                const hookFilePath = pageContext.exportsAll.onHydrationEnd[0].exportSource;\n                assert(hookFilePath);\n                await callHookWithTimeout(() => onHydrationEnd(pageContext), 'onHydrationEnd', hookFilePath);\n            }\n        }\n        else if (renderingNumber === renderingCounter) {\n            if (pageContext.exports.onPageTransitionEnd) {\n                assertHook(pageContext, 'onPageTransitionEnd');\n                pageContext.exports.onPageTransitionEnd(pageContext);\n            }\n            isTransitioning = false;\n        }\n        setScrollPosition(scrollTarget);\n        browserNativeScrollRestoration_disable();\n        globalObject.initialRenderIsDone = true;\n    }\n}\nfunction onLinkClick(callback) {\n    document.addEventListener('click', onClick);\n    return;\n    // Code adapted from https://github.com/HenrikJoreteg/internal-nav-helper/blob/5199ec5448d0b0db7ec63cf76d88fa6cad878b7d/src/index.js#L11-L29\n    async function onClick(ev) {\n        if (!isNormalLeftClick(ev))\n            return;\n        const linkTag = findLinkTag(ev.target);\n        if (!linkTag)\n            return;\n        const url = linkTag.getAttribute('href');\n        if (skipLink(linkTag))\n            return;\n        assert(url);\n        ev.preventDefault();\n        const keepScrollPosition = ![null, 'false'].includes(linkTag.getAttribute('keep-scroll-position'));\n        callback(url, { keepScrollPosition });\n    }\n    function isNormalLeftClick(ev) {\n        return ev.button === 0 && !ev.ctrlKey && !ev.shiftKey && !ev.altKey && !ev.metaKey;\n    }\n    function findLinkTag(target) {\n        while (target.tagName !== 'A') {\n            const { parentNode } = target;\n            if (!parentNode) {\n                return null;\n            }\n            target = parentNode;\n        }\n        return target;\n    }\n}\nfunction onBrowserHistoryNavigation(callback) {\n    // The `event` of `window.addEventListener('popstate', (event) => /*...*/)` is useless:\n    //  - The History API doesn't provide the previous state (the popped state): https://stackoverflow.com/questions/48055323/is-history-state-always-the-same-as-popstate-event-state\n    window.addEventListener('popstate', () => {\n        const currentState = getState();\n        const scrollTarget = currentState.historyState.scrollPosition || 'scroll-to-top-or-hash';\n        const isHashNavigation = currentState.urlWithoutHash === globalObject.previousState.urlWithoutHash;\n        const isBackwardNavigation = !currentState.historyState.timestamp || !globalObject.previousState.historyState.timestamp\n            ? null\n            : currentState.historyState.timestamp < globalObject.previousState.historyState.timestamp;\n        globalObject.previousState = currentState;\n        if (isHashNavigation) {\n            // - `history.state` is uninitialized (`null`) when:\n            //   - The vite-plugin-ssr app runs `window.location.hash = '#section'`.\n            //   - The user clicks on an anchor link `<a href=\"#section\">Section</a>`. (Because vite-plugin-ssr's `onLinkClick()` handler skips hash links.)\n            // - `history.state` is `null` when uninitialized: https://developer.mozilla.org/en-US/docs/Web/API/History/state\n            // - Alternatively, we completely take over hash navigation and reproduce the browser's native behavior upon hash navigation.\n            //   - Problem: we cannot intercept `window.location.hash = '#section'`. (Or maybe we can with the `hashchange` event?)\n            //   - Other potential problem: would there be a conflict when the user wants to override the browser's default behavior? E.g. for smooth scrolling, or when using hashes for saving states of some fancy animations.\n            // - Another alternative: we use the browser's scroll restoration mechanism (see `browserNativeScrollRestoration_enable()` below).\n            //   - Problem: not clear when to call `browserNativeScrollRestoration_disable()`/`browserNativeScrollRestoration_enable()`\n            //   - Other potential problem are inconsistencies between browsers: specification says that setting `window.history.scrollRestoration` only affects the current entry in the session history. But this seems to contradict what folks saying.\n            //     - Specification: https://html.spec.whatwg.org/multipage/history.html#the-history-interface\n            //     - https://stackoverflow.com/questions/70188241/history-scrollrestoration-manual-doesnt-prevent-safari-from-restoring-scrol\n            if (window.history.state === null) {\n                // The browser already scrolled to `#${hash}` => the current scroll position is the right one => we save it with `initHistoryState()`.\n                initHistoryState();\n                globalObject.previousState = getState();\n            }\n            else {\n                // If `history.state !== null` then it means that `popstate` was triggered by the user clicking on his browser's forward/backward history button.\n                setScrollPosition(scrollTarget);\n            }\n        }\n        else {\n            // Fetch & render new page\n            callback(scrollTarget, isBackwardNavigation);\n        }\n    });\n}\nfunction changeUrl(url, overwriteLastHistoryEntry) {\n    if (getCurrentUrl() === url)\n        return;\n    browserNativeScrollRestoration_disable();\n    pushHistory(url, overwriteLastHistoryEntry);\n    globalObject.previousState = getState();\n}\nfunction getState() {\n    return {\n        urlWithoutHash: getCurrentUrl({ withoutHash: true }),\n        historyState: getHistoryState()\n    };\n}\nfunction setScrollPosition(scrollTarget) {\n    if (scrollTarget === 'preserve-scroll') {\n        return;\n    }\n    let scrollPosition;\n    if (scrollTarget === 'scroll-to-top-or-hash') {\n        const hash = getUrlHash();\n        // We replicate the browser's native behavior\n        if (hash && hash !== 'top') {\n            const hashTarget = document.getElementById(hash) || document.getElementsByName(hash)[0];\n            if (hashTarget) {\n                hashTarget.scrollIntoView();\n                return;\n            }\n        }\n        scrollPosition = { x: 0, y: 0 };\n    }\n    else {\n        assert('x' in scrollTarget && 'y' in scrollTarget);\n        scrollPosition = scrollTarget;\n    }\n    setScroll(scrollPosition);\n}\n/** Change the browser's scoll position, in a way that works during a repaint. */\nfunction setScroll(scrollPosition) {\n    const scroll = () => window.scrollTo(scrollPosition.x, scrollPosition.y);\n    const done = () => window.scrollX === scrollPosition.x && window.scrollY === scrollPosition.y;\n    // In principle, this `done()` call should force the repaint to be finished. But that doesn't seem to be the case with `Firefox 97.0.1`.\n    if (done())\n        return;\n    scroll();\n    // Because `done()` doesn't seem to always force the repaint to be finished, we potentially need to retry again.\n    if (done())\n        return;\n    requestAnimationFrame(() => {\n        scroll();\n        if (done())\n            return;\n        setTimeout(async () => {\n            scroll();\n            if (done())\n                return;\n            // In principle, `requestAnimationFrame() -> setTimeout(, 0)` should be enough.\n            //  - https://stackoverflow.com/questions/61281139/waiting-for-repaint-in-javascript\n            //  - But it's not enough for `Firefox 97.0.1`.\n            //  - The following strategy is very agressive. It doesn't need to be that aggressive for Firefox. But we do it to be safe.\n            const start = new Date().getTime();\n            while (true) {\n                await sleep(10);\n                scroll();\n                if (done())\n                    return;\n                const millisecondsElapsed = new Date().getTime() - start;\n                if (millisecondsElapsed > 100)\n                    return;\n            }\n        }, 0);\n    });\n}\nfunction autoSaveScrollPosition() {\n    // Safari cannot handle more than 100 `history.replaceState()` calls within 30 seconds (https://github.com/brillout/vite-plugin-ssr/issues/46)\n    window.addEventListener('scroll', throttle(saveScrollPosition, Math.ceil(1000 / 3)), { passive: true });\n    onPageHide(saveScrollPosition);\n}\nfunction getUrlHash() {\n    let { hash } = window.location;\n    if (hash === '')\n        return null;\n    assert(hash.startsWith('#'));\n    hash = hash.slice(1);\n    return hash;\n}\n// We use the browser's native scroll restoration mechanism only for the first render\nfunction setupNativeScrollRestoration() {\n    browserNativeScrollRestoration_enable();\n    onPageHide(browserNativeScrollRestoration_enable);\n    onPageShow(() => globalObject.initialRenderIsDone && browserNativeScrollRestoration_disable());\n}\nfunction browserNativeScrollRestoration_disable() {\n    if ('scrollRestoration' in window.history) {\n        window.history.scrollRestoration = 'manual';\n    }\n}\nfunction browserNativeScrollRestoration_enable() {\n    if ('scrollRestoration' in window.history) {\n        window.history.scrollRestoration = 'auto';\n    }\n}\nfunction onPageHide(listener) {\n    window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'hidden') {\n            listener();\n        }\n    });\n}\nfunction onPageShow(listener) {\n    window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'visible') {\n            listener();\n        }\n    });\n}\nfunction checkIfAbort(err, pageContext) {\n    if (isObject(err) && err._abortRendering)\n        return true;\n    if (handleErrorFetchingStaticAssets(err, pageContext)) {\n        return true;\n    }\n    return false;\n}\nfunction handleErrorFetchingStaticAssets(err, pageContext) {\n    if (!isErrorFetchingStaticAssets(err)) {\n        return false;\n    }\n    if (pageContext._isFirstRenderAttempt) {\n        disableClientRouting(err, false);\n        // This may happen if the frontend was newly deployed during hydration.\n        // Ideally: re-try a couple of times by reloading the page (not entirely trivial to implement since `localStorage` is needed.)\n        throw err;\n    }\n    else {\n        disableClientRouting(err, true);\n    }\n    serverSideRouteTo(pageContext.urlOriginal);\n    return true;\n}\n","export { addLinkPrefetchHandlers, prefetch };\nimport { assert, assertClientRouting, assertUsage, checkIfClientRouting, isExternalLink } from './utils';\nimport { isErrorFetchingStaticAssets, loadPageFilesClientSide } from '../loadPageFilesClientSide';\nimport { isClientSideRoutable, skipLink } from './skipLink';\nimport { getPageId } from './getPageId';\nimport { getPrefetchSettings } from './prefetch/getPrefetchSettings';\nimport { isAlreadyPrefetched, markAsAlreadyPrefetched } from './prefetch/alreadyPrefetched';\nimport { disableClientRouting } from './useClientRouter';\nassertClientRouting();\nconst linkPrefetchHandlerAdded = new Map();\nasync function prefetch(url) {\n    assertUsage(checkIfClientRouting(), 'prefetch() only works with Client Routing, see https://vite-plugin-ssr.com/prefetch');\n    assertUsage(!isExternalLink(url), `You are trying to prefetch the URL ${url} of another domain which cannot be prefetched`);\n    if (isAlreadyPrefetched(url))\n        return;\n    markAsAlreadyPrefetched(url);\n    const { pageId, pageFilesAll, pageConfigs } = await getPageId(url);\n    if (pageId) {\n        try {\n            await loadPageFilesClientSide(pageFilesAll, pageConfigs, pageId);\n        }\n        catch (err) {\n            if (isErrorFetchingStaticAssets(err)) {\n                disableClientRouting(err, true);\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n}\nfunction addLinkPrefetchHandlers(pageContext) {\n    // Current URL is already prefetched\n    markAsAlreadyPrefetched(pageContext.urlOriginal);\n    const linkTags = [...document.getElementsByTagName('A')];\n    linkTags.forEach(async (linkTag) => {\n        if (linkPrefetchHandlerAdded.has(linkTag))\n            return;\n        linkPrefetchHandlerAdded.set(linkTag, true);\n        const url = linkTag.getAttribute('href');\n        if (skipLink(linkTag))\n            return;\n        assert(url);\n        try {\n            if (!(await isClientSideRoutable(url)))\n                return;\n        }\n        catch {\n            // If a route() hook has a bug or `throw RenderErrorPage()`\n            return;\n        }\n        if (isAlreadyPrefetched(url))\n            return;\n        const { prefetchStaticAssets } = getPrefetchSettings(pageContext, linkTag);\n        if (!prefetchStaticAssets) {\n            return;\n        }\n        else if (prefetchStaticAssets === 'hover') {\n            linkTag.addEventListener('mouseover', () => prefetch(url));\n            linkTag.addEventListener('touchstart', () => prefetch(url), { passive: true });\n        }\n        else if (prefetchStaticAssets === 'viewport') {\n            const observer = new IntersectionObserver((entries) => {\n                entries.forEach((entry) => {\n                    if (entry.isIntersecting) {\n                        prefetch(url);\n                        observer.disconnect();\n                    }\n                });\n            });\n            observer.observe(linkTag);\n        }\n    });\n}\n"],"names":["getUrlPathname","url","parseUrl","isExternalLink","isPlainObject","value","isReact","_a","_b","_c","_d","isReact1","isReact2","isReact3","isSameErrorMessage","err1","err2","serverSideRouteTo","sleep","milliseconds","r","throttle","func","waitTime","isQueued","assert","isBrowser","assertClientRouting","globalObject","getGlobalObject","navigate","keepScrollPosition","overwriteLastHistoryEntry","assertUsage","errMsg","checkIfClientRouting","defineNavigate","navigate_","stringifyStringArray","stringList","str","hasPropertyGetter","obj","prop","descriptor","isPromise","val","isCallable","isObjectWithKeys","keys","key","isStringRecord","thing","deduceRouteStringFromFilesystemPath","pageId","filesystemRoots","fsBase","filesystemRoot","higherFirst","filesystemRoute","urlRoot","debugInfo","slice","dir","loadPageRoutes","pageFilesAll","pageConfigs","pageConfigGlobal","allPageIds","p","onBeforeRouteHook","getGlobalHooks","getPageRoutes","pageRoutes","pageIds","comesFromV1PageConfig","pageConfig","removePageId","pageRoute","routeConfig","route","routeDefinedAt","allowAsync","allowSyncConfig","routeFilesystem","routeFilesystemDefinedBy","isErrorPageId","pageRouteFile","findPageRouteFile","filePath","fileExports","hasProp","routeString","routeFunction","allowKey","hookFn","hookFilePath","onBeforeRoute","dirname","paths","dirPath","length","id","addComputedUrlProps","pageContext","enumerable","urlPathnameGetter","urlGetter","urlParsedGetter","getUrlParsed","urlHandler","urlOriginal","baseServer","pathname","urlPathname","assertWarning","urlParsedOriginal","origin","pathnameOriginal","search","searchAll","searchOriginal","hash","hashOriginal","urlParsed","makeNonEnumerable","assertURLs","PARAM_TOKEN_NEW","PARAM_TOKEN_OLD","assertRouteString","errMsgPrefix","routeStr","resolveRouteString","routeSegments","urlSegments","routeParams","assertGlob","routeSegment","urlSegment","isParam","numberOfGlobChars","analyzeRouteString","numberOfStaticSegmentsBeginning","numberOfStaticSegements","numberOfParameterSegments","isCatchAll","isStaticRouteString","match","resolvePrecendence","routeMatches","sortMatches","makeFirst","routeMatch","routeMatch1","routeMatch2","precedence1","precedence2","result","resolveRouteFunction","precedence","assertRouteParams","errPrefix","assertPageContextProvidedByUser","pageContextProvidedByUser","hook","errorMessagePrefix","isRenderErrorPage","hookName","isObject","callOnBeforeRouteHook","hookReturn","errPrefix2","pageContextAddendumHook","assertUsageUrl","objectAssign","_debug","debug","args","pageContextAddendum","routeType","winner","getBaseServer","isBaseServer","createPageContext","pageContextBase","getPageFilesAll","getPageId","routeContext","getExportNames","analyzeExports","pageFilesClientSide","pageFilesServerSide","isHtmlOnly","isClientRouting","assertClientSideRenderHook","hasClientSideRenderHook","i","determineClientEntry","clientEntries","pageFilesServerSideOnly","clientDependencies","clientEntry","getVPSClientEntry","analyzePageClientSide","getPageFilesClientSide","getPageFilesServerSide","removeOverridenPageFiles","analyzePageClientSideInit","sharedPageFilesAlreadyLoaded","pageFilesClientSide_","analyzeClientSide","getConfigValue","onRenderClientExists","getCodeFilePath","PageExists","isClientSideRoutable","findPageConfig","isClientSideRenderable","skipLink","linkTag","isNewTabLink","isHashUrl","hasBaseServer","isParsable","target","rel","removeHash","getPrefetchSettings","prefetchStaticAssets","getPrefetchStaticAssets","assertInfo","prefetchAttribute","getPrefetchAttribute","wrongUsageMsg","when","correctValue","attr","attrOld","deprecationNotice","linkAlreadyPrefetched","isAlreadyPrefetched","prefetchUrl","getPrefetchUrl","markAsAlreadyPrefetched","urlFirst","getCurrentUrl","navigationState","analyzePageServerSide","exportNames","BUILT_IN_CLIENT_ROUTER","BUILT_IN_CLIENT","removeBuiltInOverrides","urlToFile","fileExtension","doNotCreateExtraDirectory","hasTrailingSlash","pathnameModified","getPageContextRequestUrl","assertObjectKeys","keysExpected","keysUnknown","assertOnBeforeRenderHookReturn","hookReturnValue","getPageContext","getPageContextFirstRender","getPageContextUponNavigation","getPageContextSerializedInHtml","loadPageFilesClientSide","getPageContextErrorPage","errorPageId","getErrorPageId","getPageContextFromRoute","pageContextFromHook","onBeforeRenderExecute","getHook","onBeforeRender","pageContextReadyForRelease","releasePageContext","hookResult","callHookWithTimeout","onBeforeRenderServerSideExists","pageContextFromServer","retrievePageContextFromServer","getPageConfig","hasOnBeforeRenderServerSideOnlyHook","pageContextFromRoute","err","markIs404","checkIf404","pageContextUrl","response","contentType","isRightContentType","responseText","responseObject","parse","getProjectError","initHistoryState","state","hasModifications","getTimestamp","getScrollPosition","assertState","replaceHistoryState","getHistoryState","saveScrollPosition","scrollPosition","pushHistory","timestamp","pushHistoryState","stamp","isRenderErrorPageException","assertRenderErrorPageExceptionUsage","RenderErrorPage","that","getState","setupNativeScrollRestoration","disableClientRouting","logError","isErrorFetchingStaticAssets","useClientRouter","autoSaveScrollPosition","onLinkClick","fetchAndRender","onBrowserHistoryNavigation","scrollTarget","isBackwardNavigation","renderingCounter","renderPromise","isTransitioning","checkClientSideRenderable","isClientRoutable","renderingNumber","hydrationCanBeAborted","shouldAbort","isFirstRenderAttempt","checkIfAbort","assertHook","changeUrl","executeOnRenderClientHook","addLinkPrefetchHandlers","onHydrationEnd","setScrollPosition","browserNativeScrollRestoration_disable","callback","onClick","ev","isNormalLeftClick","findLinkTag","parentNode","currentState","isHashNavigation","getUrlHash","hashTarget","setScroll","scroll","done","start","onPageHide","browserNativeScrollRestoration_enable","onPageShow","listener","handleErrorFetchingStaticAssets","linkPrefetchHandlerAdded","prefetch","observer","entries","entry"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49]}